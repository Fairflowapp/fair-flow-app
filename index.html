<!DOCTYPE html>

<html lang="en">

<head>

<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">

<meta charset="utf-8"/>

<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>FIRST FLOW ALMOST READY</title>

<style>

:root{

  --brand1:#9d68b9; --brand2:#ff9580;

  --bg:#ffffff; --muted:#f7f7f8; --text:#111827; --sub:#6b7280; --border:#e5e7eb;

  --held:#f7e096; --danger:#ef4444;

  --badge:#e5e7eb;

}

*{box-sizing:border-box}

body{margin:0;background:var(--bg);color:var(--text);font-family:'Avenir Next', 'Open Sans', Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}

/* Sticky header with left-aligned brand + toolbar */

.header{position:sticky;top:0;z-index:100000;background:rgba(255,255,255,.96);

  border-bottom:1px solid var(--border);backdrop-filter:saturate(1.2) blur(6px);pointer-events:auto}
  
/* Ensure toolbar buttons are always clickable */
.toolbar button{position:relative;z-index:100001;pointer-events:auto;cursor:pointer}


.header-inner{max-width:1140px;margin:0 auto;padding:10px 24px;display:grid;grid-template-columns:auto 1fr;gap:16px;align-items:center}

.brandbox{display:flex;align-items:center;gap:12px}

.logo{height:70px;width:auto;margin-right:12px;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.15));background:none;border:none;box-shadow:none;padding:0;border-radius:10px;object-fit:cover}

.title{display:flex;flex-direction:column}

.appname{font-size:14px;font-weight:900;letter-spacing:.3px}

header .brand{display:flex;align-items:center;gap:1rem}

.owner{font-size:12px;color:var(--sub)}
.owner-row{display:none}
.settings-row-brand{display:none}

.toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

.btn-pill{border-radius:999px;border:1px solid var(--border);background:#fff;padding:8px 14px;font-weight:700;cursor:pointer}

.btn-pill:hover{transform:translateY(-1px)}

.btn-danger{border-color:#fca5a5;color:#b91c1c}

/* Join row under header */

.joinbar{max-width:1140px;margin:6px auto 0;display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:0 24px 10px}

.grow{flex:1 1 260px}

select,input[type="password"],input[type="text"]{height:42px;padding:0 16px;border:1px solid var(--border);border-radius:22px;background:#fff;font-size:16px;width:100%}

.pinwrap{position:relative}

.eye{position:absolute;right:12px;top:10px;cursor:pointer;color:#6b7280}

/* 1. ×‘×¨×™×¨×ª ××—×“×œ â€“ ×œ×”×¡×ª×™×¨ ××ª ×›×¤×ª×•×¨ ×”×¢×™×Ÿ-×”×¨×•×‘×•×˜ ×‘×›×œ ××§×•× */
.ai-eye-button {
  display: none;
}

/* 2. ×œ×”×¦×™×’ ××ª ×›×¤×ª×•×¨ ×”×¢×™×Ÿ-×”×¨×•×‘×•×˜ ×¨×§ ×‘×©×•×¨×ª ×”-JOIN ×”×¢×œ×™×•× ×” */
.joinbar .ai-eye-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.btn-primary{border:0;background-image:linear-gradient(90deg,var(--brand1),var(--brand2));color:#fff;border-radius:999px;padding:10px 18px;font-weight:800;cursor:pointer;box-shadow:0 4px 10px rgba(0,0,0,.08)}

.btn-ghost{border:1px solid var(--border);background:#fff;border-radius:999px;padding:10px 18px;font-weight:800;cursor:pointer}

/* Main area */

.wrap{max-width:1140px;margin:0 auto;padding:10px 24px 28px}

.grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}

.col{background:var(--muted);border:1px solid var(--border);border-radius:14px;padding:14px;min-height:240px}

.col h2{margin:2px 0 10px;font-size:15px;color:var(--sub);letter-spacing:.4px}

.list{max-height:58vh;overflow:auto}

.available-list, .inservice-list {
    max-height: 90vh;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 6px;
}

ul{list-style:none;padding:0;margin:0}

.item{display:grid;grid-template-columns:50px 1fr auto;align-items:center;gap:10px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px;margin:8px 0}

.badge{min-width:32px;height:32px;border-radius:999px;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:13px;color:#374151;background:var(--badge)}

.name-pill{white-space:nowrap;font-size:18px;display:inline-block;padding:7px 12px;border-radius:999px;color:#fff;font-weight:900;letter-spacing:.2px}

.controls{display:flex;gap:8px;align-items:center;justify-content:flex-end}

/* Buttons in rows */

/* Shared neutral button style - used by START and SELECT buttons */
.btn-neutral{display:inline-flex;align-items:center;justify-content:center;padding:6px 12px;border-radius:8px;background:#e5e7eb;border:0;cursor:pointer;font-weight:800;font-size:13.3333px;color:#111827;line-height:normal;min-width:auto;box-shadow:none;outline:none}
.btn-neutral:hover{background:#d1d5db;transform:none;box-shadow:none}
.btn-neutral:focus-visible,.btn-neutral:active,.btn-neutral:focus{outline:none;box-shadow:none;transform:none}

.start-btn,.finish-btn{display:inline-flex;align-items:center;justify-content:center;padding:6px 12px;border-radius:8px;background:#e5e7eb;border:0;cursor:pointer;font-weight:800;font-size:13.3333px;color:#111827;line-height:normal;min-width:auto;box-shadow:none;outline:none}
.start-btn:hover,.finish-btn:hover{background:#d1d5db;transform:none;box-shadow:none}
.start-btn:focus-visible,.start-btn:active,.start-btn:focus,.finish-btn:focus-visible,.finish-btn:active,.finish-btn:focus{outline:none;box-shadow:none;transform:none}

/* SELECT button in MY LIST - uses shared btn-neutral class */

.hold-btn{padding:6px 12px;border-radius:8px;border:1px solid #e8d27a;background:var(--held);font-weight:800;cursor:pointer}

/* Red status dot for selectable tasks in MY LIST */
.task-status-dot {
  width: 8px;
  height: 8px;
  background: #EF4444;
  border-radius: 50%;
  display: inline-block;
  flex-shrink: 0;
  margin-right: 8px;
}

.item[held="true"]{background:#fff9e6;border-color:#ffcc00;opacity:.95}

/* Dialogs */

dialog{border:0;border-radius:14px;padding:0;width:min(980px,96vw)}
/* Ensure select dropdowns in dialogs are fully interactive */
dialog select, .code-dialog select {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1001;
  position: relative;
}
dialog select:not(:disabled), .code-dialog select:not(:disabled) {
  pointer-events: auto !important;
  cursor: pointer !important;
}
/* Ensure buttons in dialogs are fully interactive */
dialog button:not(:disabled), .code-dialog button:not(:disabled) {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1002;
  position: relative;
}
dialog footer button, .code-dialog footer button {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1002;
  position: relative;
}

.dlg{padding:18px}

.dlg h3{margin:0 0 8px}

.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}

.row{display:flex;gap:10px;align-items:center;margin:8px 0;flex-wrap:wrap}

.row input[type="color"]{height:32px;width:48px;padding:0;border:1px solid var(--border);border-radius:8px;background:#fff}

.workers-table{display:block}

.workers-header,.worker-row{display:grid;grid-template-columns:2fr 120px 40px 48px 48px 1fr 60px;gap:10px;align-items:center;margin-bottom:8px;padding-bottom:6px}

.workers-header{border-bottom:1px solid var(--border);font-size:12px;font-weight:600;color:var(--sub)}

.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:13px}

.small{font-size:12px;color:#777}

.dlg footer{display:flex;justify-content:flex-end;gap:8px;padding:12px 18px;background:#fafafa;border-top:1px solid var(--border);border-radius:0 0 14px 14px}

.palette{display:flex;gap:8px;flex-wrap:wrap}

.sw{width:26px;height:26px;border-radius:50%;border:1px solid var(--border);cursor:pointer}

.logo-thumb{width:56px;height:56px;border-radius:12px;border:1px solid var(--border);object-fit:cover;background:#fff}

.brand-logo-upload {

  display: none !important;

}

.pop{position:absolute;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px;box-shadow:0 10px 24px rgba(0,0,0,.08);z-index:100}

.wrow{position:relative}

.btn-mini{border:1px solid var(--border);background:#fff;border-radius:999px;padding:6px 10px;font-weight:700;cursor:pointer;font-size:12px}

.manager-grid{display:grid;grid-template-columns:1fr 200px auto;gap:10px;align-items:center}



.quick-colors{display:flex;gap:8px;margin-bottom:6px}

.quick-colors button{width:22px;height:22px;border-radius:999px;border:1px solid #ddd;cursor:pointer}

.name-pill{white-space:nowrap;font-size:18px;min-width:120px;display:inline-flex;justify-content:center}



/* Ensure all prompts/modals inherit the app font */

#codePromptOverlay *, dialog, .dlg, .btn-pill, .btn-primary, .btn-ghost, .btn-mini,

.header, .joinbar, .wrap, .col, .small, .pill, input, select, button {

  font-family: inherit !important;

}

.history-modal {

  position: fixed;

  inset: 0;

  display: flex;

  align-items: center;

  justify-content: center;

  z-index: 1000;

}

.history-modal-footer {

  display: flex;

  gap: 10px;

  justify-content: flex-end;

  margin-top: 16px;

  padding-top: 16px;

  border-top: 1px solid #eee;

}

.history-modal-footer button {

  padding: 8px 16px;

  border-radius: 8px;

  border: 1px solid #ddd;

  background: #fff;

  cursor: pointer;

  font-weight: 600;

}

.history-modal-footer button:hover {

  background: #f5f5f5;

}

#historyClearBtn {

  border-color: #fca5a5;

  color: #b91c1c;

}

.history-modal.hidden {

  display: none;

}

.history-modal-backdrop {

  position: absolute;

  inset: 0;

  background: rgba(0, 0, 0, 0.25);

}

.history-modal-dialog {

  position: relative;

  background: #ffffff;

  border-radius: 12px;

  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);

  padding: 16px 20px;

  width: min(1000px, 90vw);

  max-height: 80vh;

  display: flex;

  flex-direction: column;

  z-index: 1000;

}

.history-modal-header {

  display: flex;

  align-items: center;

  justify-content: space-between;

  margin-bottom: 8px;

}

.history-modal-body {

  overflow: hidden;

}

.history-close-btn {

  border: none;

  background: transparent;

  font-size: 20px;

  cursor: pointer;

  line-height: 1;

}

.history-table-wrapper {

  max-height: 320px;    /* ××ª××™× ×œ×› ~10 ×©×•×¨×•×ª */

  overflow-y: auto;

}

/* ××•× ×¢ ×§×¤×™×¦×” / ×¢×™×•×•×ª */

.history-table-wrapper table {

  width: 100%;

  border-collapse: collapse;

}

.history-table {

  width: 100%;

  border-collapse: collapse;

  font-size: 0.85rem;

}

.history-table th,

.history-table td {

  padding: 4px 8px;

  text-align: left;

  border-bottom: 1px solid #f0f0f0;

}



</style>



<style id="quick4-css">

  .wrow{display:flex;align-items:center;gap:6px;flex-wrap:wrap;padding-left:2px}

  .pinwrap{display:flex;align-items:center;gap:6px}

  .pin{height:32px;width:120px;padding:0 10px;border:1px solid #e5e7eb;border-radius:8px;text-align:center}

  .color{height:32px;width:46px;padding:0;border:1px solid #e5e7eb;border-radius:6px;background:#fff}

  .quick4{display:inline-flex;align-items:center;gap:6px;margin-left:6px}

  .quick4 .dot{width:18px;height:18px;border-radius:50%;border:1px solid #d0d0d0;cursor:pointer}

  .spacer{flex:1 1 auto}

</style>



<style>#reorderBtn.active{filter:brightness(1.2);box-shadow:0 0 0 2px rgba(255,255,255,.35) inset}</style>

</head>

<body>

  <!-- LOGIN SECTION -->
  <section id="login-section" style="max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h1 style="text-align:center;font-size:28px;margin-bottom:24px;">Fair Flow â€“ Login</h1>

    <input id="login-email" type="email" placeholder="Email"
           style="width:100%;margin-bottom:12px;padding:12px 16px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="login-password" type="password" placeholder="Password"
           style="width:100%;margin-bottom:16px;padding:12px 16px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="login-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;margin-bottom:16px;">
      Log in
    </button>

    <div id="forgot-password-container" style="margin-top:8px;text-align:center;font-size:13px;">
      <button id="forgot-password-button"
              type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;">
        Forgot your password?
      </button>
    </div>

    <div id="password-reset-message" style="margin-top:6px;font-size:13px;text-align:center;"></div>

    <div style="text-align:center;margin:8px 0;">or</div>

    <button id="google-login-button"
            style="width:100%;padding:12px 16px;border-radius:999px;border:1px solid #ddd;background:#fff;cursor:pointer;font-size:14px;">
      Continue with Google
    </button>

    <div id="login-error" style="color:red;margin-top:8px;text-align:center;"></div>

    <div id="login-to-signup-toggle" style="margin-top: 12px; text-align: center;">
      <span>Don't have an account?</span>
      <button id="show-signup-button" type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;margin-left:4px;">
        Sign up
      </button>
    </div>
  </section>

  <!-- SIGNUP SECTION -->
  <section id="signup-section" style="display:none;max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="text-align:center;font-size:24px;margin-bottom:20px;">Create your Fair Flow account</h2>

    <input id="signup-business-name" type="text" placeholder="Business name"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-owner-name" type="text" placeholder="Your name"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-email" type="email" placeholder="Email"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-password" type="password" placeholder="Password"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-password-confirm" type="password" placeholder="Confirm password"
           style="width:100%;margin-bottom:16px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="signup-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;">
      Create account
    </button>

    <div id="signup-error" style="color:red;margin-top:8px;text-align:center;"></div>

    <div id="signup-to-login-toggle" style="margin-top: 12px; text-align:center;">
      <span>Already have an account?</span>
      <button id="show-login-button" type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;margin-left:4px;">
        Log in
      </button>
    </div>
  </section>

  <!-- RESET PASSWORD SECTION -->
  <section id="reset-password-section"
           style="display:none;max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="text-align:center;font-size:24px;margin-bottom:20px;">Reset your password</h2>

    <p style="font-size:14px;color:#555;margin-bottom:12px;">
      Enter the email you use to sign in. We'll send you a link to reset your password.
    </p>

    <input id="reset-email"
           type="email"
           placeholder="Email"
           style="width:100%;margin-bottom:12px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="reset-password-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;">
      Send reset link
    </button>

    <div id="reset-error" style="color:red;margin-top:8px;text-align:center;"></div>
    <div id="reset-success" style="color:green;margin-top:8px;text-align:center;"></div>

    <div style="margin-top: 16px; text-align:center;">
      <button id="reset-back-to-login-button"
              type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;font-size:13px;">
        Back to login
      </button>
    </div>
  </section>

  <!-- Main App Content (visible after login) -->
  <!-- Reset Admin PIN Page -->
  <section id="reset-admin-pin-section" style="display:none;max-width:480px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="margin:0 0 8px;font-size:24px;font-weight:600;color:#111;">Reset Admin PIN</h2>
    <p id="reset-pin-status" style="margin:0 0 24px;font-size:14px;color:#666;">Verifying reset link...</p>
    
    <div id="reset-pin-form" style="display:none;">
      <p style="margin:0 0 16px;font-size:14px;color:#666;">Enter a new 4-6 digit PIN for admin access.</p>
      <div style="display:flex;flex-direction:column;gap:12px;margin-bottom:18px;">
        <div>
          <label style="display:block;font-size:13px;color:#666;margin-bottom:6px;font-weight:500;">New PIN (4-6 digits)</label>
          <input id="reset-pin-new" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Enter new PIN" style="width:100%;border:1px solid #ddd;border-radius:10px;padding:12px 16px;font-size:16px;outline:none;" />
        </div>
        <div>
          <label style="display:block;font-size:13px;color:#666;margin-bottom:6px;font-weight:500;">Confirm PIN</label>
          <input id="reset-pin-confirm" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Confirm new PIN" style="width:100%;border:1px solid #ddd;border-radius:10px;padding:12px 16px;font-size:16px;outline:none;" />
        </div>
      </div>
      <div id="reset-pin-error" style="color:#dc2626;font-size:13px;margin-bottom:12px;min-height:18px;"></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;">
        <button id="reset-pin-cancel" class="btn-pill" style="font-size:14px;">Cancel</button>
        <button id="reset-pin-submit" class="btn-primary" style="font-size:14px;">Reset PIN</button>
      </div>
    </div>
    
    <div id="reset-pin-success" style="display:none;">
      <div style="padding:16px;background:#f0fdf4;border:1px solid #86efac;border-radius:10px;margin-bottom:16px;">
        <p style="margin:0;font-size:14px;color:#166534;font-weight:500;">âœ“ Admin PIN has been reset successfully. You can now use the new PIN to access admin actions.</p>
      </div>
      <button id="reset-pin-close" class="btn-primary" style="font-size:14px;width:100%;">Return to App</button>
    </div>
    
    <div id="reset-pin-error-state" style="display:none;">
      <div style="padding:16px;background:#fef2f2;border:1px solid #fca5a5;border-radius:10px;margin-bottom:16px;">
        <p id="reset-pin-error-message" style="margin:0;font-size:14px;color:#991b1b;"></p>
      </div>
      <button id="reset-pin-try-again" class="btn-pill" style="font-size:14px;width:100%;">Request New Reset Link</button>
    </div>
  </section>

  <div id="main-app-content" style="display:none;">

  <!-- Owner View (contains existing Fair Flow app) -->
  <div id="owner-view" style="display:none;">
    <div class="header">

    <div class="header-inner">

      <div class="brandbox">

        <img id="brandLogo" class="logo" alt="Fair Flow App" src="fairflow-logo.png">

        <div class="title">

          <div class="appname">FAIR FLOW APP</div>

          <div class="owner owner-row" id="salonName">Owner: <strong>Shiri</strong></div>

        </div>

      </div>

      <div class="toolbar">

        <button id="settingsBtn" class="btn-pill">Settings</button>

        <button id="logBtn" class="btn-pill">History</button>

        <button id="reorderBtn" class="btn-pill">Reorder</button>

        <button id="tasksBtn" class="btn-pill">TASKS</button>

        <button id="resetBtn" class="btn-pill btn-danger">RESET</button>

        <button id="logout-button" class="btn-pill">Log out</button>

      </div>

    </div>

    <!-- Join row -->

    <div id="joinBar" class="joinbar">

      <label>JOIN</label>

      <select id="nameSelect" class="grow" style="cursor:pointer;"></select>

      <div class="grow pinwrap">

        <input id="pinInput" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="off" maxlength="6" placeholder="PIN (hidden)" style="cursor:text;"/>

        <span id="togglePin" class="eye">ğŸ‘ï¸</span>

      </div>

      <button id="joinBtn" class="btn-primary">Join</button>

      <span style="flex:1"></span>

      <button id="startFirstBtn" class="btn-ghost">START top</button>

    </div>

    <div id="joinError" style="max-width:1140px;margin:0 auto;padding:0 24px;color:red;font-size:13px;margin-top:6px;min-height:18px;display:none;"></div>

  </div>



  <div class="wrap">

    <div class="grid">

      <div class="col">

        <h2>AVAILABLE</h2>

        <div id="reorderHeader" style="display:none;background:#f3fbff;border:1px solid #60a5fa;border-radius:14px;padding:16px 12px;margin-bottom:10px;text-align:center;">

          <button id="addTechBtn" class="btn-primary">+ Add technician</button>

        </div>

        <div class="list available-list"><ul id="queueList"></ul></div>

      </div>

      <div class="col">

        <h2>IN SERVICE</h2>

        <div class="list inservice-list"><ul id="serviceList"></ul></div>

      </div>

    </div>

  </div>

  <div id="historyModal" class="history-modal code-dialog hidden">
    <div class="history-modal-backdrop"></div>
    <div class="history-modal-dialog">
      <div class="history-modal-header">
        <h3>History</h3>
        <button id="historyCloseBtn" class="history-close-btn" type="button">Ã—</button>
      </div>
      <div class="history-modal-body">
        <div class="history-table-wrapper">
          <table class="history-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Time</th>
                <th>Action</th>
                <th>Role</th>
                <th>Performed by</th>
                <th>Worker</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>
      </div>
      <div class="history-modal-footer">
        <button id="historyExportBtn" type="button">Export</button>
        <button id="historyClearBtn" type="button">Clear</button>
        <button id="historyCloseBtn2" type="button">Close</button>
      </div>
    </div>
  </div>



  <!-- Settings (ADMIN ONLY) -->

  <dialog id="settingsDlg" class="code-dialog">

    <form method="dialog">

      <div class="dlg">

        <h3>Settings</h3>

        <div class="row small">Admin only. Managers cannot access.</div>



        <h4>Codes</h4>

        <div class="row">

          <span class="pill">Admin code:

            <input id="adminCode" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="off" maxlength="6" style="height:32px;width:120px;padding:0 10px">

            <button class="btn-mini" type="button" data-eye="adminCode">ğŸ‘</button>

          </span>

        </div>



        <h4>Managers (name â€¢ code)</h4>

        <div id="managersBox"></div>

        <div class="row"><button id="addManager" type="button" class="btn-mini">+ Add manager</button></div>



        <div class="settings-row-brand">
          <h4>Brand</h4>

          <div class="row">

            <div class="brand-logo-upload">

              <img id="logoPreview" class="logo-thumb" alt="logo"/>

              <input id="logoFile" type="file" accept="image/*"/>

            </div>

            <input id="salonInput" type="text" placeholder="Business/Owner name" style="flex:1;height:32px;padding:0 10px">

          </div>
        </div>



        <h4>Workers (name â€¢ PIN â€¢ color)</h4>

        <div id="workersBox"></div>

        <div class="row"><button id="addWorker" type="button" class="btn-mini">+ Add worker</button></div>

        <div class="row small">Only these names can join. Duplicates are blocked.</div>

      </div>

      <footer>

        <button class="btn-pill" value="cancel">Cancel</button>

        <button id="saveSettings" class="btn-primary" value="default">Save</button>

      </footer>

    </form>

  </dialog>



  <!-- Log (ADMIN ONLY) -->

  <dialog id="logDlg">

    <form method="dialog">

      <div class="dlg">

        <h3>History</h3>

        <div id="logBox" style="max-height:55vh;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:10px;background:#fff;font-size:12px"></div>

      </div>

      <footer>

        <button class="btn-pill" value="cancel">Close</button>

        <button id="exportLog" class="btn-pill">Export</button>

        <button id="clearLog" class="btn-pill btn-danger">Clear</button>

      </footer>

    </form>

  </dialog>



  <!-- Add Technician (REORDER MODE ONLY) -->

  <dialog id="addTechDlg" class="code-dialog">

    <form method="dialog">

      <div class="dlg">

        <h3>Add Technician to AVAILABLE</h3>

        <div class="row">

          <label style="display:flex;flex-direction:column;gap:6px;width:100%;">

            <span style="font-weight:600;">Technician name:</span>

            <select id="addTechSelect" style="height:42px;padding:0 16px;border:1px solid var(--border);border-radius:22px;background:#fff;font-size:16px;width:100%">

              <option value="">-- Select technician --</option>

            </select>

          </label>

        </div>

        <p class="small" style="margin-top:8px;color:var(--sub);">

          The technician will be added to the end of the AVAILABLE list.

        </p>

      </div>

      <footer>

        <button type="button" id="addTechCancel" class="btn-pill">Cancel</button>

        <button type="button" id="addTechConfirm" class="btn-primary">Add</button>

      </footer>

    </form>

  </dialog>



<script>

// Helpers

const ls=(k,v)=>v===undefined?JSON.parse(localStorage.getItem(k)||"null"):localStorage.setItem(k,JSON.stringify(v));

const $=s=>document.querySelector(s); const $$=s=>Array.from(document.querySelectorAll(s));

const btn=(t,c)=>{const b=document.createElement("button"); b.textContent=t; b.className=c; return b;};

const stamp=()=>new Date().toLocaleString();

const escapeHtml=s=>(s||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));

function toDataURL(file){return new Promise(res=>{const r=new FileReader(); r.onload=e=>res(e.target.result); r.readAsDataURL(file);});}

function formatHistoryDate(date) {
  return date.toLocaleDateString('en-US', {
    month: '2-digit',
    day: '2-digit'
  });
}

function formatHistoryTime(date) {
  return date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  });
}



// State

const DEFAULTS={

  adminCode:"5050",

  managers:[{name:"Manager A", code:"6060"}],

  brand:{name:"Shiri", logo:null},

  brandPalette:["#FBE54D","#D4452D","#79A7E5","#8AD97A"],

  core:["#111827","#5b21b6","#7c3aed","#2563eb","#0ea5e9","#10b981","#84cc16","#f59e0b","#ef4444","#f472b6"],

  workers:[

    {name:"Katy", pin:"1111", color:"#c0841a"},

    {name:"Johanna", pin:"2222", color:"#2563eb"},

    {name:"Maya", pin:"3333", color:"#ef4444"},

    {name:"Daniel", pin:"4444", color:"#10b981"},

    {name:"Noa", pin:"5555", color:"#111827"}

  ]

};

let settings=ls("ffv24_settings")||DEFAULTS;

// Ensure settings.workers exists and is an array
if (!settings.workers || !Array.isArray(settings.workers) || settings.workers.length === 0) {
  console.warn('settings.workers is missing or empty, initializing from defaults');
  settings.workers = DEFAULTS.workers ? [...DEFAULTS.workers] : [];
  save();
}

// Initialize task reminder settings if not present
if (!settings.taskReminders) {
  settings.taskReminders = {
    Opening: { enabled: false, type: 'daily', time: '07:30' },
    Closing: { enabled: false, type: 'daily', time: '16:00' },
    Weekly: { enabled: false, type: 'weekly', weekday: 1, time: '09:00' }, // 1 = Monday
    Monthly: { enabled: false, type: 'monthly', day: 1, time: '09:00' },
    Yearly: { enabled: false, type: 'yearly', month: 1, day: 1, time: '09:00' } // month: 1-12, day: 1-31
  };
}

// Initialize task notes if not present (backward compatible)
if (!settings.taskNotes) {
  settings.taskNotes = {
    opening: '',
    closing: '',
    weekly: '',
    monthly: '',
    yearly: ''
  };
}

// Initialize tasks catalog globally
window.ff_tasks_catalog_v1 =
    window.ff_tasks_catalog_v1 ||
    JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");

// Initialize incomplete tasks badge setting (backward compatible)
if (settings.showIncompleteTasksBadge === undefined) {
  settings.showIncompleteTasksBadge = false; // Default to disabled
}

// Initialize brandPalette if missing (backward compatibility)

if(!settings.brandPalette){

  // Try to infer from first worker's quick colors, otherwise use defaults

  if(settings.workers && settings.workers.length>0 && settings.workers[0].quickColors){

    settings.brandPalette=settings.workers[0].quickColors.slice(0,4);

  }else{

    settings.brandPalette=DEFAULTS.brandPalette.slice();

  }

  // Ensure exactly 4 colors

  while(settings.brandPalette.length<4){

    settings.brandPalette.push(DEFAULTS.brandPalette[settings.brandPalette.length]||"#111827");

  }

}

let queue=ls("ffv24_queue")||[];      // {name, held:false}

let service=ls("ffv24_service")||[];  // {name}

let log=ls("ffv24_log")||[];

const history = [];

let reorderMode=false;



// Elements

// Get elements - use getElementById for more reliable selection
const nameSelect = document.getElementById("nameSelect") || $("#nameSelect");
const pinInput = document.getElementById("pinInput") || $("#pinInput");
const togglePin = document.getElementById("togglePin") || $("#togglePin");
const joinBtn = document.getElementById("joinBtn") || $("#joinBtn");

const startFirstBtn=$("#startFirstBtn"); // adminBtn removed

const resetBtn=$("#resetBtn"), reorderBtn=$("#reorderBtn"), logBtn=$("#logBtn"), settingsBtn=$("#settingsBtn");

// Declare salonName early to ensure it's available before renderBrand() is called
const salonName=$("#salonName"), salonInput=$("#salonInput"), brandLogo=$("#brandLogo");

// Numeric-only PIN/code input enforcement using event delegation
(function() {
  // Matcher function to identify PIN/code inputs
  function isPinLikeInput(el) {
    if (!el || el.tagName !== 'INPUT' || el.type === 'email' || el.type === 'file') {
      return false;
    }
    
    const id = (el.id || '').toLowerCase();
    const name = (el.name || '').toLowerCase();
    const placeholder = (el.placeholder || '').toLowerCase();
    const className = (el.className || '').toLowerCase();
    
    return (
      id.includes('pin') || id.includes('code') ||
      name.includes('pin') || name.includes('code') ||
      placeholder.includes('pin') || placeholder.includes('code') ||
      className.includes('pin') || className.includes('mcode') || className.includes('wpin')
    );
  }
  
  // Configure a PIN input with numeric attributes
  // Keep type="password" by default for visual hiding, but allow eye toggle to change to text
  function configurePinInput(el) {
    if (!el || !isPinLikeInput(el)) return;
    
    // Set to password by default (hidden), unless already text (eye toggle revealed it)
    // Don't override if eye toggle has set it to text
    if (el.type !== 'text') {
      el.type = "password";
    }
    // If type is already 'text' (from eye toggle), leave it as text
    
    el.inputMode = "numeric";
    el.pattern = "[0-9]*";
    // Use one-time-code for autocomplete, but allow override
    if (!el.hasAttribute('autocomplete')) {
      el.autocomplete = "one-time-code";
    }
  }
  
  // Focusin handler: configure input when focused
  document.addEventListener('focusin', function(e) {
    if (isPinLikeInput(e.target)) {
      configurePinInput(e.target);
    }
  }, true);
  
  // Input handler: strip non-digits
  document.addEventListener('input', function(e) {
    if (isPinLikeInput(e.target)) {
      e.target.value = e.target.value.replace(/\D/g, "");
    }
  }, true);
  
  // Paste handler: strip non-digits from pasted content
  document.addEventListener('paste', function(e) {
    if (isPinLikeInput(e.target)) {
      e.preventDefault();
      const pastedText = (e.clipboardData || window.clipboardData).getData('text');
      const numericOnly = pastedText.replace(/\D/g, "");
      if (numericOnly) {
        const start = e.target.selectionStart || 0;
        const end = e.target.selectionEnd || 0;
        const currentValue = e.target.value;
        e.target.value = currentValue.substring(0, start) + numericOnly + currentValue.substring(end);
        e.target.setSelectionRange(start + numericOnly.length, start + numericOnly.length);
        e.target.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }
  }, true);
  
  // Initialize existing inputs on DOM ready
  function initPinInputs() {
    document.querySelectorAll('input').forEach(function(input) {
      if (isPinLikeInput(input)) {
        configurePinInput(input);
      }
    });
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPinInputs);
  } else {
    initPinInputs();
  }
})();

const queueList=$("#queueList"), serviceList=$("#serviceList");

const settingsDlg=$("#settingsDlg");

const logoPreview=$("#logoPreview"), logoFile=$("#logoFile");

const logDlg=$("#logDlg"), logBox=$("#logBox");



// Roles helpers

function isManagerCode(code){ return (settings.managers||[]).some(m=>m.code.toString()===code.toString()); }

// Cache for admin PIN from Firestore
let cachedAdminPin = null;
let adminPinCacheTime = 0;
const ADMIN_PIN_CACHE_DURATION = 60000; // 1 minute cache

// Get admin PIN (checks Firestore first, then falls back to local settings)
async function getAdminPin() {
  // Try Firestore first
  if (window.getAdminPinFromFirestore && typeof window.getAdminPinFromFirestore === 'function') {
    const now = Date.now();
    // Use cache if available and not expired
    if (cachedAdminPin !== null && (now - adminPinCacheTime) < ADMIN_PIN_CACHE_DURATION) {
      return cachedAdminPin;
    }
    
    try {
      const firestorePin = await window.getAdminPinFromFirestore();
      if (firestorePin !== null) {
        cachedAdminPin = firestorePin;
        adminPinCacheTime = now;
        return firestorePin;
      }
    } catch (error) {
      console.error("[AdminPIN] Error getting PIN from Firestore, falling back to local:", error);
    }
  }
  
  // Fall back to local settings
  return (settings.adminCode || "").toString();
}

// Clear admin PIN cache (call after updating PIN)
function clearAdminPinCache() {
  cachedAdminPin = null;
  adminPinCacheTime = 0;
}

// Check if code matches admin PIN (checks Firestore first, then local)
async function isAdminCodeAsync(code) {
  const adminPin = await getAdminPin();
  return adminPin.toString() === code.toString();
}

// Synchronous version for backward compatibility (uses cached value or local)
// This is the main function used throughout the app
function isAdminCode(code) {
  // Use cached value if available
  if (cachedAdminPin !== null) {
    return cachedAdminPin.toString() === code.toString();
  }
  // Fall back to local settings
  return (settings.adminCode || "").toString() === code.toString();
}

// Initialize admin PIN cache on load
(async function initAdminPinCache() {
  if (window.getAdminPinFromFirestore && typeof window.getAdminPinFromFirestore === 'function') {
    try {
      const firestorePin = await window.getAdminPinFromFirestore();
      if (firestorePin !== null) {
        cachedAdminPin = firestorePin;
        adminPinCacheTime = Date.now();
        // Also update local settings for backward compatibility
        if (settings) {
          settings.adminCode = firestorePin;
        }
      }
    } catch (error) {
      console.error("[AdminPIN] Error initializing PIN cache:", error);
    }
  }
})();

// Get actor object for history logging
// Returns { role, name }
function getActorForAction(options) {
  // options:
  //   - workerName?  (for tech self-actions)
  //   - managerCode? (when a manager types a PIN)
  //   - adminCode?   (when admin code used)

  // Manager by PIN
  if (options && options.managerCode) {
    const pin = String(options.managerCode);
    const managers = (settings.managers || []);

    const manager = managers.find(m => String(m.code || m.pin) === pin);
    if (manager) {
      return {
        role: "Manager",
        name: manager.name || "Manager"
      };
    }
  }

  // Admin
  if (options && options.adminCode) {
    if (String(settings.adminCode) === String(options.adminCode)) {
      return {
        role: "Admin",
        name: settings.adminName || settings.ownerName || "Admin"
      };
    }
  }

  // Tech (default â€“ worker acts ×¢×œ ×¢×¦××•)
  if (options && options.workerName) {
    return {
      role: "Tech",
      name: options.workerName
    };
  }

  // Safety fallback
  return {
    role: "Tech",
    name: "-"
  };
}

function getCurrentActorRole() {
  // Check window.__ff_actorRole first (set by securePromptOnce wrapper)
  if (window.__ff_actorRole === 'Manager' || window.__ff_actorRole === 'Admin') {
    return window.__ff_actorRole;
  }
  // Fallback to old window.lastActorRole
  if (window.lastActorRole === 'Manager' || window.lastActorRole === 'Admin') {
    return window.lastActorRole;
  }
  return 'Tech';
}

function getCurrentActorName() {
  // Check window.__ff_actorName first (set by securePromptOnce wrapper)
  // Note: We check for undefined/null, not falsy, because empty string is a valid value
  if (window.__ff_actorName !== undefined && window.__ff_actorName !== null && window.__ff_actorName !== '') {
    return window.__ff_actorName;
  }
  // Check sessionStorage (also set by securePromptOnce wrapper)
  try {
    const storedName = sessionStorage.getItem('ff_actor_name');
    if (storedName && storedName !== '') {
      return storedName;
    }
  } catch(e) {}
  // Fallback to old window.lastManagerName
  return window.lastManagerName || '';
}

// Get actor information for history entry
// Returns { actorRole, actorName, workerName }
function getActorInfo(code = null, workerName = '') {
  let actorRole = 'Tech';
  let actorName = '';
  
  // If a code was provided, validate it to determine actor
  if (code != null) {
    if (isAdminCode(code)) {
      actorRole = 'Admin';
      actorName = (settings.ownerName || settings.adminName || (settings.owner && settings.owner.name) || 'Admin');
    } else if (isManagerCode(code)) {
      actorRole = 'Manager';
      // Find the manager by code - must match exactly
      const manager = (settings.managers || []).find(m => m.code && m.code.toString() === code.toString());
      actorName = (manager && manager.name) ? manager.name : 'Manager';
    } else {
      // Code provided but not admin/manager - must be worker PIN, so Tech
      actorRole = 'Tech';
      actorName = workerName || 'Tech';
    }
  } else {
    // No code provided - check if there's a current actor (from securePromptOnce)
    const currentRole = getCurrentActorRole();
    if (currentRole === 'Manager' || currentRole === 'Admin') {
      actorRole = currentRole;
      let currentName = getCurrentActorName();
      
      // For Manager: ensure we have the actual manager name, not just "Manager"
      if (currentRole === 'Manager') {
        // If name is missing, empty, or "Manager", try to get it from window.__ff_actorName directly
        if (!currentName || currentName === '' || currentName === 'Manager') {
          // Check window.__ff_actorName first (most recent)
          if (window.__ff_actorName && window.__ff_actorName !== '' && window.__ff_actorName !== 'Manager') {
            currentName = window.__ff_actorName;
          } else {
            // Check sessionStorage
            try {
              const storedName = sessionStorage.getItem('ff_actor_name');
              if (storedName && storedName !== '' && storedName !== 'Manager') {
                currentName = storedName;
              }
            } catch(e) {}
          }
        }
        
        // If we still don't have a proper name, use "Manager" as fallback
        // This should rarely happen if securePromptOnce wrapper works correctly
        actorName = (currentName && currentName !== '' && currentName !== 'Manager') ? currentName : 'Manager';
      } else {
        // Admin
        if (currentName && currentName !== '') {
          actorName = currentName;
        } else {
          actorName = (settings.ownerName || settings.adminName || 'Admin');
        }
      }
    } else {
      // Default to Tech with worker name
      actorRole = 'Tech';
      actorName = workerName || 'Tech';
    }
  }
  
  return {
    actorRole: actorRole,
    actorName: actorName || '-',
    workerName: workerName || ''
  };
}

function addHistoryEntry(actionText, actor, workerName) {
  const now = new Date();
  
  history.unshift({
    timestamp: now,
    date: formatHistoryDate(now),   // 11/16
    time: formatHistoryTime(now),   // 16:40
    action: actionText,
    role: actor.role,            // Tech / Manager / Admin
    performedBy: actor.name,     // Shiri / Leya / Admin / ...
    worker: workerName || '',
    // Keep backward compatibility fields
    actorRole: actor.role,
    actorName: actor.name,
    workerName: workerName || ''
  });
  renderHistory();
}

function renderHistory() {
  const tableBody = document.getElementById('historyBody');
  if (!tableBody) return;

  tableBody.innerHTML = history.map(entry => {
    const d = entry.timestamp;
    // Backwards compatibility: handle old structure
    let role = entry.role || entry.actorRole;
    let performedBy = entry.performedBy || entry.actorName;
    let worker = entry.worker || entry.workerName;
    
    // Try to get from old structure if missing
    if (!performedBy) {
      if (entry.performedBy) {
        performedBy = entry.performedBy;
      } else if (entry.actorName) {
        performedBy = entry.actorName;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        performedBy = entry.performedBy.name || '-';
      } else {
        performedBy = '-';
      }
    }
    
    if (!role) {
      if (entry.actorRole) {
        role = entry.actorRole;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        role = entry.performedBy.role || 'Tech';
      } else {
        role = 'Tech';
      }
    }
    
    if (!worker && entry.workerName) {
      worker = entry.workerName;
    }
    
    return `
      <tr>
        <td>${formatHistoryDate(d)}</td>
        <td>${formatHistoryTime(d)}</td>
        <td>${escapeHtml(entry.action)}</td>
        <td>${escapeHtml(role || '-')}</td>
        <td>${escapeHtml(performedBy || '-')}</td>
        <td>${escapeHtml(worker || '')}</td>
      </tr>
    `;
  }).join('');
}



// Render

function renderBrand(){
  if (salonName) {
    salonName.innerHTML="Owner: <strong>"+escapeHtml(settings.brand.name||"")+"</strong>";
  }

  if (brandLogo) {
    brandLogo.src = "fairflow-logo.png";
    brandLogo.style.visibility="visible";
  }
}

function loadTechniciansFromSettings() {
  // Load technicians from settings.workers (stored in localStorage)
  // This is the same data source used in Settings page
  console.log('[loadTechniciansFromSettings] Loading technicians from settings.workers');
  
  // Ensure settings.workers exists and is an array
  if (!settings.workers || !Array.isArray(settings.workers)) {
    console.warn('[loadTechniciansFromSettings] settings.workers is not defined or not an array, using defaults');
    settings.workers = DEFAULTS.workers ? [...DEFAULTS.workers] : [];
    save();
  }
  
  console.log('[loadTechniciansFromSettings] Found', settings.workers.length, 'technicians');
  console.log('[loadTechniciansFromSettings] Technicians:', settings.workers.map(w => ({ name: w.name, hasPin: !!w.pin })));
  
  return settings.workers;
}

function renderSelect(){
  // Try to get element if not already available
  const selectEl = document.getElementById("nameSelect");
  
  if (!selectEl) {
    console.error('[renderSelect] nameSelect element not found in DOM');
    // Try again after a short delay in case DOM isn't ready
    setTimeout(() => {
      const retryEl = document.getElementById("nameSelect");
      if (retryEl) {
        console.log('[renderSelect] Found element on retry, rendering now');
        renderSelect();
      } else {
        console.error('[renderSelect] Still cannot find nameSelect after retry');
      }
    }, 500);
    return;
  }

  // Check if owner-view is visible
  const ownerView = document.getElementById("owner-view");
  if (ownerView && ownerView.style.display === 'none') {
    console.log('[renderSelect] owner-view is hidden, will retry when visible');
    // Retry when view becomes visible
    setTimeout(renderSelect, 1000);
    return;
  }

  // Load technicians from the same data source as Settings page
  const technicians = loadTechniciansFromSettings();
  
  console.log('[renderSelect] Rendering dropdown with', technicians.length, 'technicians');
  
  selectEl.innerHTML="";

  // Ensure dropdown is enabled and interactive
  selectEl.disabled = false;
  selectEl.style.pointerEvents = 'auto';
  selectEl.style.cursor = 'pointer';
  selectEl.style.opacity = '1';
  selectEl.removeAttribute('readonly');
  selectEl.removeAttribute('disabled');

  if (technicians.length === 0) {
    console.warn('[renderSelect] No technicians found in settings.workers');
    // Add a placeholder option
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "No technicians available - Add in Settings";
    placeholder.disabled = true;
    placeholder.selected = true;
    selectEl.appendChild(placeholder);
    selectEl.disabled = true;
    return;
  }

  // Add a default "Select technician" option
  const defaultOption = document.createElement("option");
  defaultOption.value = "";
  defaultOption.textContent = "Select technician...";
  defaultOption.disabled = true;
  defaultOption.selected = true;
  selectEl.appendChild(defaultOption);

  // Populate dropdown with technicians from settings
  let addedCount = 0;
  technicians.forEach(technician => { 
    if (technician && technician.name && technician.name.trim()) {
      const option = document.createElement("option"); 
      option.value = technician.name.trim(); // Use name as the ID/value
      option.textContent = technician.name.trim(); 
      option.dataset.technicianId = technician.name.trim(); // Store ID for reference
      selectEl.appendChild(option);
      addedCount++;
    }
  });
  
  console.log('[renderSelect] Added', addedCount, 'technicians to dropdown');
  
  // Update global reference
  if (typeof window !== 'undefined') {
    window.nameSelect = selectEl;
  }
}

function colorOf(name){ const f=settings.workers.find(w=>w.name===name); return f?f.color:"#111827"; }

function fontColorOf(name){

  const w = (settings.workers||[]).find(x=>x.name===name);

  return (w && w.fcolor) ? w.fcolor : '#ffffff';

}



function namePill(name){

  const span=document.createElement('span');

  span.className='name-pill';

  span.style.background=colorOf(name);

  span.style.color=fontColorOf(name);

  span.textContent=name;

  return span;

}

function renderQueue(){

  queueList.innerHTML="";

  queue.forEach((q,i)=>{

    const li=document.createElement("li"); li.className="item"; li.setAttribute("held",q.held?"true":"false");

    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=i+1;

    const nm=document.createElement("div"); nm.appendChild(namePill(q.name));

    const ctrls=document.createElement("div"); ctrls.className="controls";

    const start=btn("START","start-btn");

    const hold=btn(q.held?"RELEASE":"HOLD","hold-btn");

    start.onclick=() =>guardStart(q.name, i, ()=>startSpecific(i));

    hold.onclick=() =>guardHold(()=>toggleHold(i));

    ctrls.append(hold,start);

    if(reorderMode){ const up=btn("â†‘","start-btn"), down=btn("â†“","start-btn"); up.onclick=() =>move(i,-1); down.onclick=() =>move(i,1); const del=btn("âœ–","finish-btn"); del.title="Remove from queue"; del.onclick=()=>guardHold(()=>removeFromQueue(i)); ctrls.prepend(up); ctrls.append(down); ctrls.append(del); }

    li.append(badge,nm,ctrls); queueList.appendChild(li);

  });

}



function removeFromQueue(i){

  if(i<0 || i>=queue.length) return;

  const rem = queue.splice(i,1)[0];

  save();

  renderQueue(); 

  log.push(`${new Date().toLocaleString()} â€“ REMOVED ${rem.name} by admin/manager`);

  save();

  // Remove from queue is always done by manager/admin (guardHold ensures this)
  // Use the last validated code or current actor state
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry('Remove from queue', actor, rem.name);

}

function renderService(){

  serviceList.innerHTML="";

  service.forEach((s,i)=>{

    const li=document.createElement("li"); li.className="item";

    const badge=document.createElement("div"); badge.className="badge"; badge.textContent="â€¢";

    const nm=document.createElement("div"); const pill=namePill(s.name); pill.textContent=s.name; nm.appendChild(pill);

    const fin=btn("FINISH","finish-btn"); fin.onclick=() =>guardFinish(s.name, ()=>finish(i));

    li.append(badge,nm,fin); serviceList.appendChild(li);

  });

}



// Actions

function handleJoin(){
  try {
  console.log('[handleJoin] Join button clicked');

  const joinErrorEl = document.getElementById('joinError');
  
  // Clear any previous error
  if (joinErrorEl) {
    joinErrorEl.textContent = '';
    joinErrorEl.style.display = 'none';
  }

  // Get elements fresh to ensure they exist
  const nameSelectEl = document.getElementById("nameSelect");
  const pinInputEl = document.getElementById("pinInput");
  
  if (!nameSelectEl) {
    console.error('[handleJoin] nameSelect element not found');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: Dropdown not found. Please refresh the page.';
      joinErrorEl.style.display = 'block';
    }
    return;
  }
  
  if (!pinInputEl) {
    console.error('[handleJoin] pinInput element not found');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: PIN input not found. Please refresh the page.';
      joinErrorEl.style.display = 'block';
    }
    return;
  }

  // Get selected technician name (this is the technician ID in this app)
  const selectedTechnicianName = nameSelectEl.value;
  const pin = (pinInputEl.value || "").toString().trim();
  
  console.log('[handleJoin] Join clicked', selectedTechnicianName, pin);
  console.log('[handleJoin] Available workers:', settings.workers?.length || 0);
  
  // Validate that both name and PIN are provided
  if (!selectedTechnicianName || selectedTechnicianName === '' || selectedTechnicianName === 'Select technician...') {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Please select a technician';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Please select a technician');
    }
    return;
  }

  if (!pin || pin === '') {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Please enter a PIN';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Please enter a PIN');
    }
    return;
  }

  // Load the selected technician from settings.workers
  const technician = settings.workers.find(w => w.name === selectedTechnicianName);
  
  if (!technician) {
    console.error('[handleJoin] Technician not found:', selectedTechnicianName);
    console.log('[handleJoin] Available technicians:', settings.workers.map(w => w.name));
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Technician not found in settings';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Technician not found');
    }
    return;
  }

  console.log('[handleJoin] Found technician:', technician.name, 'Stored PIN:', technician.pin);

  // Verify that the entered PIN matches the technician's stored PIN
  const storedPin = (technician.pin || "").toString();
  const enteredPin = pin.toString();
  
  if (storedPin !== enteredPin) {
    console.error('[handleJoin] PIN mismatch. Expected:', storedPin, 'Got:', enteredPin);
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Incorrect PIN';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Incorrect PIN');
    }
    // Clear PIN field on error
    pinInputEl.value = '';
    return;
  }

  // Check if technician is already in queue or service
  if (queue.some(x => x.name === selectedTechnicianName) || service.some(x => x.name === selectedTechnicianName)) {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'This technician is already active';
      joinErrorEl.style.display = 'block';
    } else {
      alert('This technician is already active');
    }
    return;
  }

  // All validations passed - add to queue
  console.log('[handleJoin] Adding technician to queue:', selectedTechnicianName);
  queue.push({name: selectedTechnicianName, held: false});
  log.unshift(stamp() + ` join: ${selectedTechnicianName}`);
  save();
  renderQueue();
  
  // Clear PIN field and error message on success
  pinInputEl.value = '';
  if (joinErrorEl) {
    joinErrorEl.textContent = '';
    joinErrorEl.style.display = 'none';
  }
  
  console.log('[handleJoin] Successfully added', selectedTechnicianName, 'to queue');

  // Join is done directly by worker (Tech action)
  const techActor = getActorForAction({ workerName: selectedTechnicianName });
  addHistoryEntry('Join', techActor, selectedTechnicianName);
  } catch (e) {
    console.error('[handleJoin] Error in handleJoin:', e);
    const joinErrorEl = document.getElementById('joinError');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: ' + (e.message || 'Unknown error');
      joinErrorEl.style.display = 'block';
    } else {
      alert('Error joining: ' + (e.message || 'Unknown error'));
    }
  }
}

// Keep backward compatibility
function join() {
  return handleJoin();
}

function startFirst(){

  const idx=queue.findIndex(x=>!x.held); if(idx===-1) return alert("No available worker (empty or all on HOLD)");

  const target=queue[idx]; guardStart(target.name, idx, ()=>startSpecific(idx));

}

function startSpecific(idx){

  const [it]=queue.splice(idx,1); service.push({name:it.name});

  log.unshift(stamp()+` START -> IN SERVICE: ${it.name}`); save(); renderQueue(); renderService();

  // Actor info is already set by guardStart (manager/admin code or worker PIN)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Worker PIN was used - tech action
    actor = getActorForAction({ workerName: it.name });
  }
  addHistoryEntry('Start (Available â†’ In service)', actor, it.name);

}

function toggleHold(i){ queue[i].held=!queue[i].held; log.unshift(stamp()+` ${queue[i].held?"HOLD":"RELEASE"}: ${queue[i].name}`); save(); renderQueue(); 

  // Actor info is already set by guardHold (manager/admin code)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry(queue[i].held ? 'Hold' : 'Release', actor, queue[i].name);

}

function finish(i){

  const [it]=service.splice(i,1);

  queue.push({name:it.name, held:false}); // back to end

  log.unshift(stamp()+` FINISH -> Back to end: ${it.name}`); save(); renderQueue(); renderService();

  // Actor info is already set by guardFinish (manager/admin code or worker PIN)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Worker PIN was used - tech action
    actor = getActorForAction({ workerName: it.name });
  }
  addHistoryEntry('Finish (In service â†’ Available)', actor, it.name);

}

function move(i,d){ const j=i+d; if(j<0||j>=queue.length) return; const t=queue[j]; queue[j]=queue[i]; queue[i]=t; save(); renderQueue(); 

  // Reorder is done in reorder mode which requires manager/admin code
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry('Reorder list', actor, '');

}

async function resetDay(){
  // Check if user is owner/admin - block if not
  if (typeof window.isCurrentUserOwner === 'function') {
    try {
      const isOwner = await window.isCurrentUserOwner();
      if (!isOwner) {
        alert("Not authorized - Only admin/owner can reset the day");
        return;
      }
    } catch (e) {
      console.warn('[Reset] Could not verify user role, proceeding with admin code check:', e);
      // Continue to admin code check if role verification fails
    }
  }
  
  // Step 1: Show confirmation modal
  const confirmed = await showResetConfirmation();
  if (!confirmed) {
    return; // User cancelled
  }
  
  // Step 2: Show admin/manager PIN modal (same as REORDER) with inline error handling
  const code = await showResetPinPrompt();
  if (code == null || !code) {
    return; // User cancelled or invalid code (error already shown)
  }
  
  // Set actor info if using securePromptOnce wrapper
  if (window.securePromptOnce) {
    // Actor info is already set by securePromptOnce wrapper
    window.__ff_lastValidatedCode = code;
  } else {
    // If using prompt, set actor info manually
    const actorInfo = getActorInfo(code, '');
    window.__ff_actorRole = actorInfo.actorRole;
    window.__ff_actorName = actorInfo.actorName;
    window.__ff_lastValidatedCode = code;
  }
  
  // Proceed with reset - clear queues only, NOT history
  queue = [];
  service = [];
  // History is NOT cleared - log and history arrays remain untouched
  save();
  renderQueue();
  renderService();
  
  // Tasks feature removed - no Tasks state to clear
}

// Helper function to show RESET confirmation modal (Step 1)
function showResetConfirmation() {
  return new Promise((resolve) => {
    const overlay = document.getElementById('resetConfirmOverlay');
    const cancelBtn = document.getElementById('resetConfirmCancel');
    const continueBtn = document.getElementById('resetConfirmContinue');
    
    if (!overlay || !cancelBtn || !continueBtn) {
      // Fallback to native confirm if modal elements not found
      resolve(confirm("Are you sure you want to RESET THE DAY? This will clear all queues. History will NOT be deleted."));
      return;
    }
    
    // Show modal
    overlay.style.display = 'flex';
    overlay.style.pointerEvents = 'auto';
    overlay.style.visibility = 'visible';
    
    // Clean up previous handlers
    const newCancelBtn = cancelBtn.cloneNode(true);
    const newContinueBtn = continueBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    continueBtn.parentNode.replaceChild(newContinueBtn, continueBtn);
    
    // Set up handlers
    newCancelBtn.onclick = () => {
      hideResetConfirmation();
      resolve(false);
    };
    
    newContinueBtn.onclick = () => {
      hideResetConfirmation();
      resolve(true);
    };
    
    // Close on overlay click (outside modal)
    const overlayClickHandler = (e) => {
      if (e.target === overlay) {
        hideResetConfirmation();
        overlay.removeEventListener('click', overlayClickHandler);
        resolve(false);
      }
    };
    overlay.addEventListener('click', overlayClickHandler);
    
    // Close on Escape key
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        hideResetConfirmation();
        document.removeEventListener('keydown', escapeHandler);
        resolve(false);
      }
    };
    document.addEventListener('keydown', escapeHandler);
  });
}

// Helper function to hide RESET confirmation modal
function hideResetConfirmation() {
  const overlay = document.getElementById('resetConfirmOverlay');
  if (overlay) {
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';
    overlay.style.visibility = 'hidden';
  }
}

// Helper function to show RESET PIN prompt with inline error handling (same as REORDER modal)
async function showResetPinPrompt() {
  if (!window.securePromptOnce) {
    // Fallback: native prompt if securePromptOnce not available
    const code = prompt("Enter admin/manager code to RESET");
    if (code == null) return null;
    if (isAdminCode(code) || isManagerCode(code)) {
      return code;
    } else {
      alert('Invalid admin/manager code - Reset cancelled');
      return null;
    }
  }
  
  // Use securePromptOnce but handle errors inline
  let code = await window.securePromptOnce("Enter admin/manager code to RESET");
  if (code == null) {
    return null; // User cancelled
  }
  
  // Verify PIN
  const isValid = isAdminCode(code) || isManagerCode(code);
  if (!isValid) {
    // Show error inline - reopen modal with error message
    const overlay = document.getElementById('codePromptOverlay');
    const msg = document.getElementById('codePromptMsg');
    const input = document.getElementById('codePromptInput');
    
    if (overlay && msg && input) {
      // Update message
      msg.textContent = 'Enter admin/manager code to RESET';
      msg.style.color = '#111';
      
      // Clear input
      input.value = '';
      input.type = 'password';
      
      // Create or update error element
      let errorEl = document.getElementById('codePromptError');
      if (!errorEl) {
        errorEl = document.createElement('div');
        errorEl.id = 'codePromptError';
        errorEl.style.cssText = 'color:#dc2626;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;';
        // Insert error before the "Forgot Admin PIN?" button container
        const forgotPinContainer = document.getElementById('codePromptForgotPin')?.parentElement;
        if (forgotPinContainer && forgotPinContainer.parentElement) {
          forgotPinContainer.parentElement.insertBefore(errorEl, forgotPinContainer);
        } else {
          // Fallback: insert before buttons
          const buttonsContainer = document.getElementById('codePromptOk')?.parentElement;
          if (buttonsContainer && buttonsContainer.parentElement) {
            buttonsContainer.parentElement.insertBefore(errorEl, buttonsContainer);
          }
        }
      }
      errorEl.textContent = 'Invalid admin/manager code';
      errorEl.style.display = 'block';
      
      // Show modal again
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      overlay.style.visibility = 'visible';
      
      // Focus input
      setTimeout(() => input.focus(), 50);
      
      // Wait for retry or cancel
      const retryCode = await window.securePromptOnce("Enter admin/manager code to RESET");
      if (retryCode == null) {
        // Hide error on cancel
        if (errorEl) errorEl.style.display = 'none';
        return null; // User cancelled
      }
      
      // Verify retry code
      const retryValid = isAdminCode(retryCode) || isManagerCode(retryCode);
      if (!retryValid) {
        // Still wrong - update error message
        if (errorEl) {
          errorEl.textContent = 'Invalid admin/manager code - Reset cancelled';
        }
        return null;
      }
      
      // Retry code is valid
      if (errorEl) errorEl.style.display = 'none';
      return retryCode;
    } else {
      // Modal elements not found - fallback to alert
      alert('Invalid admin/manager code - Reset cancelled');
      return null;
    }
  }
  
  return code; // Valid code
}



// Guards

function gateAdmin(){ const code=prompt("Admin code"); if(code===null) return false; return isAdminCode(code); }

function gateManager(){ const code=prompt("Manager code"); if(code===null) return false; return isManagerCode(code); }

function workerGate(name){ const w=settings.workers.find(x=>x.name===name); if(!w) return false; const code=prompt(`PIN for ${name}`); if(code===null) return false; return code.toString()===(w.pin||"").toString(); }

async function guardHold(fn){

  const entry = window.securePromptOnce

    ? await window.securePromptOnce('Enter admin or manager code')

    : prompt('Enter admin or manager code');

  if (entry == null) return;

  if (isAdminCode(entry) || isManagerCode(entry)) { 
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, '');
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    fn(); 
  }

  else alert('Not authorized');

}

async function guardStart(workerName, idx, fn){

  const entry = window.securePromptOnce ? await window.securePromptOnce('Enter admin/manager code or worker PIN to START') : prompt('Enter admin/manager code or worker PIN to START');

  if(entry==null) return;

  if(isAdminCode(entry)||isManagerCode(entry)) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, workerName);
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    return fn();
  }

  const w=settings.workers.find(x=>x.name===workerName);

  if(w && entry.toString()===(w.pin||"").toString()) {
    // Worker PIN - Tech action, clear any previous actor info
    window.__ff_actorRole = 'Tech';
    window.__ff_actorName = workerName;
    window.__ff_lastValidatedCode = null; // Clear code since it's worker action
    return fn();
  }

  alert("Not authorized");

}

async function guardFinish(workerName, fn){

  const entry = window.securePromptOnce ? await window.securePromptOnce('Enter admin/manager code or worker PIN to FINISH') : prompt('Enter admin/manager code or worker PIN to FINISH');

  if(entry==null) return;

  if(isAdminCode(entry)||isManagerCode(entry)) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, workerName);
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    return fn();
  }

  const w=settings.workers.find(x=>x.name===workerName);

  if(w && entry.toString()===(w.pin||"").toString()) {
    // Worker PIN - Tech action, clear any previous actor info
    window.__ff_actorRole = 'Tech';
    window.__ff_actorName = workerName;
    window.__ff_lastValidatedCode = null; // Clear code since it's worker action
    return fn();
  }

  alert("Not authorized");

}



// Settings + Log

async function openSettingsSecure(){

  // Modal-based admin code prompt (with eye). No other logic changed.

  if(!window.securePromptOnce){ return alert("Admin only"); }

  const code = await window.securePromptOnce("Enter admin code");

  if(code==null || !isAdminCode(code)) { alert("Admin only"); return; }

  renderSettings();
  
  settingsDlg.showModal();

}

// Expose globally for onclick handlers
window.openSettingsSecure = openSettingsSecure;

function renderSettings(){

  // Admin code

  $("#adminCode").value=settings.adminCode||"";

  // Managers - only initialize if empty

  const mb=$("#managersBox");
  
  if (mb.children.length === 0) {
    // First time rendering - build all rows
    (settings.managers||[]).forEach((m,i)=>mb.appendChild(managerRow(i,m)));
  }

  // Brand

  $("#salonInput").value=settings.brand.name||""; logoPreview.src=settings.brand.logo||"";

  // Workers - only initialize if empty

  const wb=$("#workersBox");
  
  if (wb.children.length === 0) {
    // First time rendering - build structure and all rows
    
    // Global Color Palette (inside workersBox, above workers)
    const paletteRow = document.createElement("div");
    paletteRow.className = "row";
    paletteRow.style.cssText = "margin-bottom:12px;align-items:center;gap:12px";

    const paletteLabel = document.createElement("span");
    paletteLabel.textContent = "Color palette:";
    paletteLabel.style.cssText = "font-weight:600;font-size:13px";

    const paletteContainer = document.createElement("span");
    paletteContainer.className = "quick4";
    paletteContainer.style.cssText = "display:inline-flex;gap:6px;align-items:center";

    (settings.brandPalette||DEFAULTS.brandPalette).forEach((color,idx)=>{
      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.cssText = "width:18px;height:18px;border-radius:50%;border:1px solid #d0d0d0;cursor:pointer;background:"+color;
      dot.title = color;
      dot.dataset.paletteIndex = idx;
      dot.onclick = () => editPaletteColor(idx);
      paletteContainer.appendChild(dot);
    });

    paletteRow.appendChild(paletteLabel);
    paletteRow.appendChild(paletteContainer);
    wb.appendChild(paletteRow);

    // Create workers table container
    const workersTable = document.createElement("div");
    workersTable.className = "workers-table";

    // Create grid header row
    const workersHeader = document.createElement("div");
    workersHeader.className = "workers-header";

    const nameHeader = document.createElement("span");
    nameHeader.textContent = "";
    const pinHeader = document.createElement("span");
    pinHeader.textContent = "";
    const eyeHeader = document.createElement("span");
    eyeHeader.textContent = "";
    const buttonHeader = document.createElement("span");
    buttonHeader.textContent = "Button";
    buttonHeader.style.cssText = "text-align:center";
    const fontHeader = document.createElement("span");
    fontHeader.textContent = "Font";
    fontHeader.style.cssText = "text-align:center";
    const paletteHeader = document.createElement("span");
    paletteHeader.textContent = "";
    const deleteHeader = document.createElement("span");
    deleteHeader.textContent = "";

    workersHeader.append(nameHeader, pinHeader, eyeHeader, buttonHeader, fontHeader, paletteHeader, deleteHeader);
    workersTable.appendChild(workersHeader);

    // Add worker rows
    (settings.workers||[]).forEach((w,i)=>workersTable.appendChild(workerRow(i,w)));

    wb.appendChild(workersTable);
  }
  
  // Tasks-related UI removed (Task Reminders, Task Notes sections)
  // These will be rebuilt from scratch in the future

}

// Guard against infinite loop in renderTaskReminders
let isRenderingTaskReminders = false;

// Render task reminders settings
function renderTaskReminders() {
  // GUARD: Prevent infinite loop if already rendering
  if (isRenderingTaskReminders) {
    console.warn('[Tasks] renderTaskReminders already rendering, skipping to prevent loop');
    return;
  }
  
  const container = document.getElementById('taskRemindersBox');
  if (!container) return;
  
  // Set guard flag
  isRenderingTaskReminders = true;
  
  try {
    // Clear existing content
    container.innerHTML = '';
    
    // Ensure taskReminders exists
    if (!settings.taskReminders) {
      settings.taskReminders = {
        Opening: { enabled: false, type: 'daily', time: '07:30' },
        Closing: { enabled: false, type: 'daily', time: '16:00' },
        Weekly: { enabled: false, type: 'weekly', weekday: 1, time: '09:00' },
        Monthly: { enabled: false, type: 'monthly', day: 1, time: '09:00' },
        Yearly: { enabled: false, type: 'yearly', month: 1, day: 1, time: '09:00' }
      };
    }
    
    const categories = [
      { key: 'Opening', label: 'Opening', type: 'daily' },
      { key: 'Closing', label: 'Closing', type: 'daily' },
      { key: 'Weekly', label: 'Weekly', type: 'weekly' },
      { key: 'Monthly', label: 'Monthly', type: 'monthly' },
      { key: 'Yearly', label: 'Yearly', type: 'yearly' }
    ];
    
    categories.forEach(cat => {
      const reminder = settings.taskReminders[cat.key] || { enabled: false, type: cat.type };
      
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:16px;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb;';
      
      // Enable/disable checkbox
      const header = document.createElement('div');
      header.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:8px;';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = reminder.enabled || false;
      checkbox.id = `reminder-${cat.key}-enabled`;
      checkbox.addEventListener('change', () => {
        if (!settings.taskReminders[cat.key]) {
          settings.taskReminders[cat.key] = { enabled: false, type: cat.type };
        }
        settings.taskReminders[cat.key].enabled = checkbox.checked;
        save();
        // DEFERRED re-render to prevent infinite loop - use setTimeout to break recursion
        setTimeout(() => {
          isRenderingTaskReminders = false; // Clear flag before calling
          renderTaskReminders(); // Re-render to show/hide config
        }, 0);
      });
    
    const label = document.createElement('label');
    label.htmlFor = `reminder-${cat.key}-enabled`;
    label.textContent = cat.label;
    label.style.cssText = 'font-weight:600;font-size:14px;cursor:pointer;';
    
    header.appendChild(checkbox);
    header.appendChild(label);
    row.appendChild(header);
    
    // Configuration fields (only shown if enabled)
    if (checkbox.checked) {
      const configDiv = document.createElement('div');
      configDiv.style.cssText = 'margin-left:24px;display:flex;flex-direction:column;gap:8px;';
      
      if (cat.type === 'daily') {
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Start showing reminders at:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '07:30';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'weekly') {
        const weekdayLabel = document.createElement('label');
        weekdayLabel.textContent = 'Reminder weekday:';
        weekdayLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const weekdaySelect = document.createElement('select');
        weekdaySelect.style.cssText = 'width:140px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        weekdays.forEach((day, idx) => {
          const option = document.createElement('option');
          option.value = idx;
          option.textContent = day;
          if ((reminder.weekday || 1) === idx) option.selected = true;
          weekdaySelect.appendChild(option);
        });
        weekdaySelect.addEventListener('change', () => {
          settings.taskReminders[cat.key].weekday = parseInt(weekdaySelect.value);
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(weekdayLabel);
        configDiv.appendChild(weekdaySelect);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'monthly') {
        const dayLabel = document.createElement('label');
        dayLabel.textContent = 'Reminder day of month (1-28):';
        dayLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const dayInput = document.createElement('input');
        dayInput.type = 'number';
        dayInput.min = 1;
        dayInput.max = 28;
        dayInput.value = reminder.day || 1;
        dayInput.style.cssText = 'width:80px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        dayInput.addEventListener('change', () => {
          const day = Math.min(28, Math.max(1, parseInt(dayInput.value) || 1));
          settings.taskReminders[cat.key].day = day;
          dayInput.value = day;
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(dayLabel);
        configDiv.appendChild(dayInput);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'yearly') {
        const monthLabel = document.createElement('label');
        monthLabel.textContent = 'Reminder month:';
        monthLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const monthSelect = document.createElement('select');
        monthSelect.style.cssText = 'width:140px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        months.forEach((month, idx) => {
          const option = document.createElement('option');
          option.value = idx + 1;
          option.textContent = month;
          if ((reminder.month || 1) === (idx + 1)) option.selected = true;
          monthSelect.appendChild(option);
        });
        monthSelect.addEventListener('change', () => {
          settings.taskReminders[cat.key].month = parseInt(monthSelect.value);
          save();
          updateAllTabBadges();
        });
        
        const dayLabel = document.createElement('label');
        dayLabel.textContent = 'Reminder day:';
        dayLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const dayInput = document.createElement('input');
        dayInput.type = 'number';
        dayInput.min = 1;
        dayInput.max = 31;
        dayInput.value = reminder.day || 1;
        dayInput.style.cssText = 'width:80px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        dayInput.addEventListener('change', () => {
          const day = Math.min(31, Math.max(1, parseInt(dayInput.value) || 1));
          settings.taskReminders[cat.key].day = day;
          dayInput.value = day;
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(monthLabel);
        configDiv.appendChild(monthSelect);
        configDiv.appendChild(dayLabel);
        configDiv.appendChild(dayInput);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      }
      
      row.appendChild(configDiv);
    }
    
    container.appendChild(row);
  });
    
    // Clear guard flag after rendering completes
    isRenderingTaskReminders = false;
  } catch (error) {
    console.error('[Tasks] Error in renderTaskReminders:', error);
    isRenderingTaskReminders = false; // Clear flag on error
  }
}

// Render incomplete tasks badge setting
function renderIncompleteTasksBadgeSetting() {
  const container = document.getElementById('taskNotesBox');
  if (!container) return;
  
  // Check if setting toggle already exists
  let toggleRow = document.getElementById('incompleteTasksBadgeToggle');
  if (!toggleRow) {
    toggleRow = document.createElement('div');
    toggleRow.id = 'incompleteTasksBadgeToggle';
    toggleRow.style.cssText = 'margin-bottom:20px;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb;';
    
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;';
    
    const label = document.createElement('label');
    label.textContent = 'Show incomplete tasks badge on Home screen';
    label.style.cssText = 'font-size:14px;font-weight:600;color:var(--text);cursor:pointer;';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = settings.showIncompleteTasksBadge === true;
    checkbox.style.cssText = 'width:18px;height:18px;cursor:pointer;';
    
    checkbox.addEventListener('change', (e) => {
      settings.showIncompleteTasksBadge = e.target.checked;
      save();
    });
    
    label.addEventListener('click', () => {
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    header.appendChild(label);
    header.appendChild(checkbox);
    
    const description = document.createElement('p');
    description.textContent = 'When enabled, a red badge with the number of incomplete tasks will appear on the Tasks button on the Home screen.';
    description.style.cssText = 'font-size:12px;color:var(--sub);margin:0;line-height:1.5;';
    
    toggleRow.appendChild(header);
    toggleRow.appendChild(description);
    
    // Insert before task notes section
    container.insertBefore(toggleRow, container.firstChild);
  } else {
    // Update checkbox state if it already exists
    const checkbox = toggleRow.querySelector('input[type="checkbox"]');
    if (checkbox) {
      checkbox.checked = settings.showIncompleteTasksBadge === true;
    }
  }
}

// Render task notes settings
function renderTaskNotes() {
  const container = document.getElementById('taskNotesBox');
  if (!container) return;
  
  // Clear existing content
  container.innerHTML = '';
  
  // Ensure taskNotes exists
  if (!settings.taskNotes) {
    settings.taskNotes = {
      opening: '',
      closing: '',
      weekly: '',
      monthly: '',
      yearly: ''
    };
  }
  
  const categories = [
    { key: 'opening', label: 'Opening tasks note' },
    { key: 'closing', label: 'Closing tasks note' },
    { key: 'weekly', label: 'Weekly tasks note' },
    { key: 'monthly', label: 'Monthly tasks note' },
    { key: 'yearly', label: 'Yearly tasks note' }
  ];
  
  categories.forEach(cat => {
    const note = settings.taskNotes[cat.key] || '';
    
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:16px;';
    
    const label = document.createElement('label');
    label.textContent = cat.label;
    label.style.cssText = 'display:block;font-size:13px;color:#666;font-weight:500;margin-bottom:6px;';
    
    const textarea = document.createElement('textarea');
    textarea.value = note || '';
    textarea.placeholder = `Note for ${cat.label.toLowerCase()} (optional)`;
    textarea.rows = 2;
    textarea.style.cssText = 'width:100%;border:1px solid #ddd;border-radius:6px;padding:8px 12px;font-size:13px;outline:none;background:#fff;font-family:inherit;resize:vertical;min-height:60px;';
    
    textarea.addEventListener('input', (e) => {
      const value = e.target.value.trim();
      if (!settings.taskNotes) {
        settings.taskNotes = {};
      }
      settings.taskNotes[cat.key] = value || '';
      // Auto-save on change
      save();
    });
    
    row.appendChild(label);
    row.appendChild(textarea);
    container.appendChild(row);
  });
}

// Append a single manager row without rebuilding the table
function appendManagerRow() {
  const mb = $("#managersBox");
  if (!mb) return;
  
  const index = settings.managers.length;
  const newManager = {name: "", code: ""};
  settings.managers.push(newManager);
  
  const row = managerRow(index, newManager);
  mb.appendChild(row);
  
  save();
}

// Update manager row indices after deletion
function updateManagerIndices() {
  const mb = $("#managersBox");
  if (!mb) return;
  
  const rows = mb.querySelectorAll('.manager-grid');
  rows.forEach((row, newIndex) => {
    const inputs = row.querySelectorAll('.mname, .mcode');
    const buttons = row.querySelectorAll('.mdel, .eyeBtn');
    
    inputs.forEach(input => {
      input.dataset.i = newIndex;
    });
    
    buttons.forEach(button => {
      button.dataset.i = newIndex;
    });
  });
}

// Append a single worker row without rebuilding the table
function appendWorkerRow() {
  const wb = $("#workersBox");
  if (!wb) return;
  
  // Find the workers table (should be the last child after palette row)
  const workersTable = wb.querySelector('.workers-table');
  if (!workersTable) {
    // If table doesn't exist, need to initialize first
    renderSettings();
    return;
  }
  
  const index = settings.workers.length;
  const newWorker = {
    name: "",
    pin: "",
    color: "#111827",
    fcolor: "#ffffff"
  };
  settings.workers.push(newWorker);
  
  const row = workerRow(index, newWorker);
  workersTable.appendChild(row);
  
  save();
}

// Update worker row indices after deletion
function updateWorkerIndices() {
  const wb = $("#workersBox");
  if (!wb) return;
  
  const workersTable = wb.querySelector('.workers-table');
  if (!workersTable) return;
  
  const rows = workersTable.querySelectorAll('.worker-row');
  rows.forEach((row, newIndex) => {
    const inputs = row.querySelectorAll('.wname, .wpin');
    const buttons = row.querySelectorAll('.wdel');
    const colorInputs = row.querySelectorAll('.wcolor, .wfont');
    
    // Update data-i for inputs
    inputs.forEach(input => {
      input.dataset.i = newIndex;
      input.dataset.index = newIndex;
    });
    
    // Update data-i for delete button
    buttons.forEach(button => {
      button.dataset.i = newIndex;
    });
    
    // Update data-index for color inputs
    colorInputs.forEach(input => {
      input.dataset.index = newIndex;
    });
  });
}

function editPaletteColor(index){

  const currentColor = (settings.brandPalette||DEFAULTS.brandPalette)[index]||"#111827";

  // Create a temporary color input to trigger the native color picker

  const colorInput = document.createElement("input");

  colorInput.type = "color";

  colorInput.value = currentColor;

  // Position the color picker near the Color palette row

  const paletteRow = document.querySelector("#workersBox .row:first-child");

  if(paletteRow){

    const rect = paletteRow.getBoundingClientRect();

    colorInput.style.position = "fixed";

    colorInput.style.left = `${rect.left + 150}px`;

    colorInput.style.top = `${rect.bottom + 40}px`;

    colorInput.style.zIndex = "10000";

  }else{

    colorInput.style.position = "fixed";

    colorInput.style.left = "50%";

    colorInput.style.top = "50%";

    colorInput.style.zIndex = "10000";

  }

  colorInput.style.opacity = "0";

  colorInput.style.pointerEvents = "none";

  document.body.appendChild(colorInput);

  // Cleanup function

  const cleanup = ()=>{

    if(document.body.contains(colorInput)){

      document.body.removeChild(colorInput);

    }

  };

  // Handle color change

  colorInput.addEventListener("change", ()=>{

    const newColor = colorInput.value;

    if(!settings.brandPalette) settings.brandPalette = DEFAULTS.brandPalette.slice();

    settings.brandPalette[index] = newColor;

    // Update all worker rows to reflect the new palette color

    renderSettings();

    cleanup();

  });

  // Handle cancel/close - only cleanup when dialog closes, not on timeout

  colorInput.addEventListener("cancel", cleanup);

  // Click outside to close - handle blur but don't auto-close immediately

  colorInput.addEventListener("blur", ()=>{

    // Small delay to allow change event to fire first

    setTimeout(()=>{

      if(document.body.contains(colorInput) && document.activeElement !== colorInput){

        cleanup();

      }

    }, 100);

  });

  colorInput.click();

}

function managerRow(i,m){

  const div=document.createElement("div"); div.className="manager-grid";

  div.innerHTML=`

    <input class="mname" data-i="${i}" type="text" placeholder="Manager name" value="${escapeHtml(m.name||"")}">

    <div style="display:flex;gap:8px;align-items:center">

      <input class="mcode" data-i="${i}" type="text" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Code" value="${escapeHtml(m.code||"")}" style="height:32px;padding:0 10px;width:120px">

      <button class="btn-mini eyeBtn" data-for="mcode" data-i="${i}" type="button">ğŸ‘</button>

    </div>

    <button class="btn-mini mdel" data-i="${i}" type="button">Delete</button>`;

  div.querySelector(".mdel").onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    settings.managers.splice(idx,1); 
    // Remove the row from DOM
    const row = e.target.closest('.manager-grid');
    if (row) row.remove();
    // Update indices of remaining rows
    updateManagerIndices();
    save();
  };

  div.querySelector(".eyeBtn").onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    const inp=div.querySelector('.mcode'); 
    // Toggle between password (hidden) and text (visible)
    inp.type = (inp.type === "password") ? "text" : "password";
  };
  
  // Apply numeric enforcement to the manager code input
  const mcodeInput = div.querySelector('.mcode');
  // Manager code input will be configured automatically by event delegation

  return div;

}







function workerRow(i,w){

  const wrap=document.createElement("div"); wrap.className="worker-row";

  // Name

  const name = document.createElement("input");

  name.className="wname"; name.dataset.i=i; name.type="text"; name.placeholder="Worker name";

  name.value = (w.name||"");

  name.style.cssText="flex:2;min-width:260px;height:32px;padding:0 10px";
  
  // Update settings.workers directly on input
  name.dataset.index = i;
  name.addEventListener("input", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].name = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });



  // PIN + eye (always password by default)

  const pinBox = document.createElement("div"); pinBox.className="pinwrap"; pinBox.style.cssText="grid-column:span 2";

  const pin = document.createElement("input");

  pin.className="wpin pin"; pin.dataset.i=i; pin.type="password"; pin.inputMode="numeric"; pin.pattern="[0-9]*"; pin.autocomplete="off"; pin.maxLength="6"; pin.placeholder="PIN"; pin.value=(w.pin||"");

  const eye = document.createElement("button"); eye.type="button"; eye.className="btn-mini"; eye.textContent="ğŸ‘";

  eye.onclick=()=>{ 
    // Toggle between password (hidden) and text (visible)
    pin.type = (pin.type === "password") ? "text" : "password";
  };
  
  // PIN input will be configured automatically by event delegation
  
  // Update settings.workers directly on input
  pin.dataset.index = i;
  pin.addEventListener("input", (e) => {
    // Enforce numeric-only input
    e.currentTarget.value = e.currentTarget.value.replace(/\D/g, "");
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].pin = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });

  pinBox.append(pin,eye);



  // Colors

  const bg = document.createElement("input"); bg.type="color"; bg.className="wcolor color"; bg.value=w.color||"#111827";
  
  // Update settings.workers directly on change
  bg.dataset.index = i;
  bg.addEventListener("change", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].color = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });

  const font = document.createElement("input"); font.type="color"; font.className="wfont color"; font.value=w.fcolor||"#ffffff";
  
  // Update settings.workers directly on change
  font.dataset.index = i;
  font.addEventListener("change", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].fcolor = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });



  // Quick dots - now use global brandPalette

  const quick = document.createElement("span"); quick.className="quick4";

  const palette = settings.brandPalette || DEFAULTS.brandPalette;

  palette.forEach((hex,idx)=>{

    const d=document.createElement('span'); d.className='dot'; d.style.background=hex; d.title=hex;

    d.dataset.paletteIndex = idx;

    // Clicking a palette dot edits the global palette, not the worker's colors

    d.onclick=()=>{ editPaletteColor(idx); };

    quick.appendChild(d);

  });



  // Delete

  const del = document.createElement("button"); del.type="button"; del.className="btn-mini wdel"; del.dataset.i=i; del.textContent="Delete";

  del.style.marginLeft = "2px";

  del.onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    settings.workers.splice(idx,1); 
    // Remove the row from DOM
    const row = e.target.closest('.worker-row');
    if (row) row.remove();
    // Update indices of remaining rows
    updateWorkerIndices();
    save();
  };



  wrap.append(name, pinBox, bg, font, quick, del);

  return wrap;

}





$("#addManager").onclick=() => {
  appendManagerRow();
};

$("#addWorker").onclick=() => {
  appendWorkerRow();
};



async function saveSettings(e){

  // collect

  settings.adminCode=$("#adminCode").value||"5050";

  // managers

  const mnames=$$(".mname").map(e=>e.value.trim()); const mcodes=$$(".mcode").map(e=>(e.value||"").toString());

  const mans=[]; mnames.forEach((n,i)=>{ if(n){ mans.push({name:n, code:mcodes[i]||""}); } });

  settings.managers=mans;

  // brand

  settings.brand.name=$("#salonInput").value||"";

  if(logoFile.files && logoFile.files[0]) settings.brand.logo=await toDataURL(logoFile.files[0]);

  // workers
  // Workers are already synced to settings.workers via input handlers in workerRow()
  // Here we just clean up: remove empty workers and dedupe by name
  const validWorkers = [];
  const seen = new Set();
  
  settings.workers.forEach((w) => {
    // Skip empty workers (no name)
    if (!w || !w.name || !w.name.trim()) {
      return;
    }
    
    // Skip duplicates (keep first occurrence)
    if (seen.has(w.name)) {
      return;
    }
    
    seen.add(w.name);
    validWorkers.push({
      name: w.name.trim(),
      pin: (w.pin || "").toString() || "0000",
      color: w.color || "#111827",
      fcolor: w.fcolor || "#ffffff"
    });
  });
  
  settings.workers = validWorkers.slice(0, 48);

  // Save brandPalette (it's already updated in memory when edited)

  if(!settings.brandPalette) settings.brandPalette = DEFAULTS.brandPalette.slice();

  save(); 
  renderBrand(); 
  renderSelect(); // Refresh dropdown when settings are saved
  renderQueue(); 
  renderService();
  console.log('[saveSettings] Settings saved, dropdown refreshed');

}

$("#saveSettings").addEventListener("click", e=>{e.preventDefault(); saveSettings(); settingsDlg.close();});



async function openLog(){ 
  if (!window.securePromptOnce) return alert("Admin only");
  const code = await window.securePromptOnce("Enter admin code to view log");
  if (code == null || !isAdminCode(code)) {
    alert("Admin only");
    return;
  }
  openHistoryModal();
}

$("#exportLog").addEventListener("click", e=>{ e.preventDefault(); const blob=new Blob([log.join("\n")],{type:"text/plain"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="fair-flow-log.txt"; a.click(); URL.revokeObjectURL(url); });

$("#clearLog").addEventListener("click", e=>{ e.preventDefault(); if(confirm("Clear history?")){ log=[]; save(); openLog(); } });



// Bind

// Connect JOIN button handler - ensure it runs after DOM is ready
function initializeJoinButton() {
  try {
    const joinBtnEl = document.getElementById("joinBtn");
    if (joinBtnEl) {
      // Remove any existing handlers by cloning
      const parent = joinBtnEl.parentNode;
      if (parent) {
        const newJoinBtn = joinBtnEl.cloneNode(true);
        parent.replaceChild(newJoinBtn, joinBtnEl);
        const freshJoinBtn = document.getElementById("joinBtn");
        
        if (freshJoinBtn) {
          freshJoinBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoin();
          };
          freshJoinBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoin();
          }, { capture: true });
          freshJoinBtn.style.cursor = 'pointer';
          freshJoinBtn.style.pointerEvents = 'auto';
          freshJoinBtn.style.position = 'relative';
          freshJoinBtn.style.zIndex = '100';
          freshJoinBtn.disabled = false;
          freshJoinBtn.removeAttribute('disabled');
          console.log('[Init] JOIN button handler connected successfully');
          return true;
} else {
          console.error('[Init] joinBtn not found after cloning');
        }
      }
    } else {
      console.warn('[Init] joinBtn element not found');
      return false;
    }
  } catch (e) {
    console.error('[Init] Error connecting JOIN button handler:', e);
    return false;
  }
  return false;
}

// Initialize JOIN button when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      if (!initializeJoinButton()) {
        // Retry after delay if first attempt failed
        setTimeout(initializeJoinButton, 500);
      }
    }, 100);
  });
} else {
  // DOM already ready
  setTimeout(() => {
    if (!initializeJoinButton()) {
      // Retry after delay if first attempt failed
      setTimeout(initializeJoinButton, 500);
    }
  }, 100);
}

// Expose initializeJoinButton globally for app.js to call
window.initializeJoinButton = initializeJoinButton;

// Also keep backward compatibility
if (typeof window !== 'undefined') {
  window.join = handleJoin;
  window.handleJoin = handleJoin;
}

// =====================
// Remove Blocking Overlays Function
// =====================
/**
 * Detects and removes any overlays that might be blocking clicks on the header
 * This function should be called on page load and after any modal operations
 */
function removeBlockingOverlays() {
  try {
    console.log('[Overlay Audit] Scanning for blocking overlays...');
    
    // List of known modal/overlay IDs that should be hidden
    const knownOverlayIds = [
      'codePromptOverlay',
      'log-secure-overlay',
      'historyModal',
      'tasksAdminAccessModal',
      'tasksResetModal',
      'tasksFinishModal',
      'tasksSelectModal',
      'tasksEditModal',
      'tasksInstructionsModal',
      'tasksScreen'
    ];
    
    // Check known overlays
    knownOverlayIds.forEach(overlayId => {
      const overlay = document.getElementById(overlayId);
      if (overlay) {
        const computedStyle = window.getComputedStyle(overlay);
        const display = computedStyle.display;
        const zIndex = parseInt(computedStyle.zIndex) || 0;
        const position = computedStyle.position;
        
        // If overlay is visible and has high z-index, ensure it's properly hidden
        if (display !== 'none' && zIndex >= 1000 && (position === 'fixed' || position === 'absolute')) {
          console.warn(`[Overlay Audit] Found visible blocking overlay: ${overlayId} (z-index: ${zIndex}, display: ${display})`);
          overlay.style.display = 'none';
          overlay.style.pointerEvents = 'none';
          overlay.style.visibility = 'hidden';
          overlay.style.opacity = '0';
        } else if (display === 'none') {
          // Even when hidden, ensure pointer-events is none
          overlay.style.pointerEvents = 'none';
        }
      }
    });
    
    // Scan for any fixed/absolute positioned elements with high z-index that might be blocking
    const allElements = document.querySelectorAll('*');
    let blockingCount = 0;
    
    allElements.forEach(el => {
      const computedStyle = window.getComputedStyle(el);
      const zIndex = parseInt(computedStyle.zIndex) || 0;
      const position = computedStyle.position;
      const display = computedStyle.display;
      const pointerEvents = computedStyle.pointerEvents;
      
      // Check if element is a potential blocker
      if (
        (position === 'fixed' || position === 'absolute') &&
        zIndex >= 1000 &&
        zIndex < 100000 && // Don't touch header (z-index: 100000)
        display !== 'none' &&
        pointerEvents !== 'none' &&
        !el.closest('.header') && // Don't touch header elements
        !el.closest('.toolbar') && // Don't touch toolbar elements
        !knownOverlayIds.includes(el.id) // Skip known overlays (already handled)
      ) {
        // Check if element covers the header area (top 100px of viewport)
        const rect = el.getBoundingClientRect();
        if (rect.top <= 100 && rect.bottom >= 0 && rect.left <= window.innerWidth && rect.right >= 0) {
          console.warn(`[Overlay Audit] Found potential blocking element:`, {
            id: el.id,
            className: el.className,
            zIndex: zIndex,
            position: position,
            display: display,
            pointerEvents: pointerEvents,
            rect: { top: rect.top, bottom: rect.bottom, left: rect.left, right: rect.right }
          });
          
          // If it's not a known modal content, set pointer-events to none
          if (!el.closest('dialog') && !el.classList.contains('code-dialog') && !el.closest('.history-modal-dialog')) {
            el.style.pointerEvents = 'none';
            blockingCount++;
          }
        }
      }
    });
    
    if (blockingCount > 0) {
      console.log(`[Overlay Audit] Fixed ${blockingCount} potential blocking elements`);
    } else {
      console.log('[Overlay Audit] No blocking overlays found');
    }
    
    // Ensure header is always on top
    const header = document.querySelector('.header');
    if (header) {
      header.style.zIndex = '100000';
      header.style.pointerEvents = 'auto';
      header.style.position = 'sticky';
    }
    
    // Ensure toolbar buttons are clickable
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => {
      btn.style.zIndex = '100001';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
    });
    
  } catch (e) {
    console.error('[Overlay Audit] Error scanning for blocking overlays:', e);
  }
}

// Run overlay audit on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(removeBlockingOverlays, 100);
  });
} else {
  setTimeout(removeBlockingOverlays, 100);
}

// Expose globally for manual calls
window.removeBlockingOverlays = removeBlockingOverlays;

startFirstBtn.onclick=startFirst;

// adminBtn.onclick handler removed - button no longer exists
// adminBtn.onclick = async () => {
//   const code = window.securePromptOnce ? await window.securePromptOnce("Enter admin code") : prompt("Enter admin code");
//   if(code!==null) alert(isAdminCode(code)?"Admin verified.":"Wrong code");
// };

// resetBtn.onclick is set later with wrapper function to ensure tasksScreen is hidden
// resetBtn.onclick=resetDay; // Removed - now using resetDayWithNav wrapper

// Reorder handler - wrapped in try/catch for safety
async function handleReorderClick() {
  try {
  console.log('Reorder clicked');
  ensureTasksScreenHidden();

  // Secure prompt just for REORDER (no changes elsewhere)

  let ok = false;
  let code = null;

  if (window.securePromptOnce) {

    code = await window.securePromptOnce("Enter admin/manager code to REORDER");

    if (code == null) return;

    ok = (isAdminCode(code) || isManagerCode(code));

  } else {

    // Fallback: native prompt if securePromptOnce not available

    code = prompt("Admin or manager code");

    if (code == null) return;

    ok = (isAdminCode(code) || isManagerCode(code));
    
    // If using prompt, set actor info manually
    if (ok) {
      const actorInfo = getActorInfo(code, '');
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }

  }

  if (ok) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = code;

    reorderMode = !reorderMode; 
    renderQueue(); 
    
    // Update button appearance based on reorder mode
    const btn = document.getElementById('reorderBtn');
    const header = document.getElementById('reorderHeader');
      if (btn) {
    if (reorderMode) {
      btn.textContent = 'Reorder mode';
      btn.classList.remove('btn-pill');
      btn.classList.add('btn-primary');
      if (header) header.style.display = 'block';
      
      // Ensure "+ Add technician" button handler is properly attached when entering reorder mode
      const addTechBtn = document.getElementById('addTechBtn');
      if (addTechBtn) {
        // Reattach handler to ensure it works in reorder mode
        addTechBtn.onclick = openAddTechDialog;
        addTechBtn.style.pointerEvents = 'auto';
        addTechBtn.style.cursor = 'pointer';
        console.log('[Reorder] Add technician button handler reattached');
      }
    } else {
      btn.textContent = 'Reorder';
      btn.classList.remove('btn-primary');
      btn.classList.add('btn-pill');
      if (header) header.style.display = 'none';
    }
      }
  } else {
    alert("Not authorized");
    }
  } catch (e) {
    console.error('[Navigation] Error in handleReorderClick:', e);
    alert('Error in reorder: ' + (e.message || 'Unknown error'));
  }
}

// Expose globally
window.handleReorderClick = handleReorderClick;

// Attach handler safely - will be re-initialized in initializeNavigationButtons
try {
  if (reorderBtn) {
    reorderBtn.onclick = handleReorderClick;
  }
} catch (e) {
  console.error('[Init] Error attaching reorder handler:', e);
}

const historyButton = document.getElementById('logBtn');
const historyModal = document.getElementById('historyModal');
const historyCloseBtn = document.getElementById('historyCloseBtn');
const historyBackdrop = document.querySelector('.history-modal-backdrop');

function openHistoryModal() {
  if (!historyModal) return;
  historyModal.classList.remove('hidden');
  renderHistory();
}

function closeHistoryModal() {
  if (!historyModal) return;
  historyModal.classList.add('hidden');
}

if (historyButton) {
  historyButton.addEventListener('click', () => {
    openLog();
  });
}

if (historyCloseBtn) {
  historyCloseBtn.addEventListener('click', closeHistoryModal);
}

if (historyBackdrop) {
  historyBackdrop.addEventListener('click', closeHistoryModal);
}

const historyExportBtn = document.getElementById('historyExportBtn');
const historyClearBtn = document.getElementById('historyClearBtn');
const historyCloseBtn2 = document.getElementById('historyCloseBtn2');

function exportHistory() {
  const blob = new Blob([history.map(entry => {
    const d = entry.timestamp;
    // Backwards compatibility: handle old structure
    let role = entry.role || entry.actorRole;
    let performedBy = entry.performedBy || entry.actorName;
    let worker = entry.worker || entry.workerName;
    
    // Try to get from old structure if missing
    if (!performedBy) {
      if (entry.actorName) {
        performedBy = entry.actorName;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        performedBy = entry.performedBy.name || '-';
      } else {
        performedBy = '-';
      }
    }
    
    if (!role) {
      if (entry.actorRole) {
        role = entry.actorRole;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        role = entry.performedBy.role || 'Tech';
      } else {
        role = 'Tech';
      }
    }
    
    if (!worker && entry.workerName) {
      worker = entry.workerName;
    }
    
    return `${formatHistoryDate(d)},${formatHistoryTime(d)},${entry.action},${role || '-'},${performedBy || '-'},${worker || ''}`;
  }).join('\n')], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'fair-flow-history.txt';
  a.click();
  URL.revokeObjectURL(url);
}

function clearHistory() {
  if (!confirm("Clear history?")) return;
  history.length = 0;
  renderHistory();
}

if (historyExportBtn) {
  historyExportBtn.addEventListener('click', exportHistory);
}

if (historyClearBtn) {
  historyClearBtn.addEventListener('click', () => {
    clearHistory();
  });
}

if (historyCloseBtn2) {
  historyCloseBtn2.addEventListener('click', closeHistoryModal);
}

// Helper function to hide tasksScreen if visible and restore main view
// Tasks feature removed - this is now a no-op but kept for compatibility
function ensureTasksScreenHidden() {
  try {
    // Tasks feature removed - just ensure main content is visible
    const mainContent = document.querySelector('#owner-view .wrap');
    const joinBar = document.getElementById('joinBar');
    
    if (mainContent && mainContent.style.display === 'none') {
      mainContent.style.display = 'block';
    }
    if (joinBar && joinBar.style.display === 'none') {
      joinBar.style.display = 'flex';
    }
  } catch (e) {
    console.warn('[Navigation] Error in ensureTasksScreenHidden:', e);
  }
}

// Tasks Screen Functions - Header Snapshot/Restore
let __headerSnapshot = null;

function snapshotHeaderLayout() {
  const header = document.querySelector('#owner-view .header');
  if (!header || __headerSnapshot) return;
  __headerSnapshot = {
    el: header,
    className: header.className,
    style: header.style.cssText
  };
  console.log('[Tasks] Header layout snapshotted');
}

function restoreHeaderLayout() {
  if (!__headerSnapshot) return;
  const { el, className, style } = __headerSnapshot;
  el.className = className;
  el.style.cssText = style;
  __headerSnapshot = null;
  console.log('[Tasks] Header layout restored');
  
  // Trigger layout refresh
  requestAnimationFrame(() => {
    window.dispatchEvent(new Event('resize'));
  });
}

function loadTasks() {
  try {
    // If Settings modal is open, load only the current Settings tab
    if (isTasksSettingsOpen) {
      const tab = window.currentTasksTab || 'opening';
      loadTasksForSettingsTab(tab);
      return true;
    }
    
    // Otherwise, load all tabs for main Tasks screen
    const tabs = ['opening', 'closing', 'weekly', 'monthly', 'yearly'];
    
    tabs.forEach(tab => {
      // One-time migration from any legacy active storage into v1 key
      if (typeof migrateLegacyActiveToV1 === 'function') {
        migrateLegacyActiveToV1(tab);
      }
      // Load from tab-specific active storage (single source of truth)
      const activeTasks = getTabTasks(tab, 'active');
      tasksModalDraft[tab] = activeTasks;
    });
    
    console.log('[Tasks] Tasks loaded from storage');
    return true;
  } catch (e) {
    console.error('[Tasks] Error loading tasks:', e);
    return false;
  }
}

function loadTasksForSettingsTab(tab) {
  try {
    // One-time migration for this tab before reading v1 storage
    if (typeof migrateLegacyActiveToV1 === 'function') {
      migrateLegacyActiveToV1(tab);
    }
    // Load catalog tasks (template tasks) for Settings modal editing
    let catalogObj = {};
    try {
      const raw = localStorage.getItem("ff_tasks_catalog_v1");
      if (raw) {
        catalogObj = JSON.parse(raw);
      }
    } catch (e) {
      console.warn('[Tasks] Error parsing catalog from localStorage:', e);
    }
    
    // Fallback to window object
    if (!catalogObj || Object.keys(catalogObj).length === 0) {
      catalogObj = window.ff_tasks_catalog_v1 || {};
    }
    
    // Get catalog tasks for this tab and normalize to include id/taskId
    const catalogTasks = (catalogObj[tab] || []).map(task => {
      if (!task || typeof task !== 'object') return null;
      const keyId = task.taskId || task.id;
      if (!keyId) return null;
      return {
        id: keyId,
        taskId: keyId,
        title: task.title || '',
        instructions: task.instructions || task.info || task.details || ''
      };
    }).filter(Boolean);
    
    tasksModalDraft[tab] = catalogTasks;
    console.log(`[Tasks] Loaded ${catalogTasks.length} catalog tasks for Settings tab: ${tab}`);
  } catch (e) {
    console.error(`[Tasks] Error loading tasks for Settings tab ${tab}:`, e);
    tasksModalDraft[tab] = [];
  }
}

// Render tasks list in Settings modal from draft (all tasks, no filtering by status)
function renderSettingsTaskList(tabKey) {
  try {
    // Normalize tab key to lowercase
    const normalizedTab = (tabKey || 'opening').toLowerCase();
    
    // Ensure tab key is valid
    const validTabs = ['opening', 'closing', 'weekly', 'monthly', 'yearly'];
    const tab = validTabs.includes(normalizedTab) ? normalizedTab : 'opening';
    
    // Get catalog tasks from draft state
    const catalogList = tasksModalDraft[tab] || [];
    
    // Get orphan tasks from ACTIVE list (tasks not in catalog)
    let orphanTasks = [];
    try {
      const activeKey = `ff_tasks_${tab}_active_v1`;
      const activeTasks = JSON.parse(localStorage.getItem(activeKey) || '[]');
      
      // Build set of catalog task IDs for quick lookup (normalized: taskId || id)
      const catalogIds = new Set();
      catalogList.forEach(task => {
        if (!task || typeof task !== 'object') return;
        const resolvedTaskId = task.taskId || task.id;
        if (resolvedTaskId) {
          catalogIds.add(String(resolvedTaskId));
        }
      });
      
      // Find orphans: tasks in ACTIVE that are not in catalog (normalized: taskId || id)
      orphanTasks = activeTasks
        .filter(task => {
          if (!task || typeof task !== 'object') return false;
          const resolvedTaskId = task.taskId || task.id;
          if (!resolvedTaskId) return false;
          return !catalogIds.has(String(resolvedTaskId));
        })
        .map(task => {
          // Normalize orphan task to match catalog format (use resolved ID)
          const resolvedTaskId = task.taskId || task.id;
          return {
            id: resolvedTaskId,
            taskId: resolvedTaskId,
            title: task.title || '',
            instructions: task.instructions || task.info || task.details || '',
            isOrphan: true // Flag to identify orphans
          };
        });
    } catch (e) {
      console.warn('[SETTINGS] Error loading orphan tasks:', e);
    }
    
    // Combine catalog and orphan tasks
    const combinedList = [...catalogList, ...orphanTasks];
    
    // Debug log
    console.log("[SETTINGS] render tab", tab, "catalog:", catalogList.length, "orphans:", orphanTasks.length, "total:", combinedList.length);
    
    // Get the Settings modal container
    const modalListContainer = document.getElementById('tasksModalDraftList');
    if (!modalListContainer) {
      console.warn('[SETTINGS] Modal list container not found');
      return;
    }
    
    // Clear container
    modalListContainer.innerHTML = '';
    
    // Show placeholder if empty, otherwise render tasks
    if (combinedList.length === 0) {
      modalListContainer.innerHTML = '<div style="padding:16px;text-align:center;color:#9ca3af;font-size:12px;">No tasks yet</div>';
    } else {
      // Render in catalog order (catalog first, then orphans at end)
      // Don't reverse - preserve catalog order
      modalListContainer.innerHTML = combinedList.map((task, displayIndex) => {
        const resolvedTaskId = task.taskId || task.id;
        const isEditing = editingTaskId === resolvedTaskId;
        const isOrphan = task.isOrphan === true;
        
        if (isEditing) {
          // Edit mode: show inputs with ID display and action buttons
          // Resolve IDs from task object and catalog
          let displayId = task.id || '';
          let displayTaskId = task.taskId || '';
          
          // Try to get from catalog if not in task object
          if ((!displayId && !displayTaskId) || isOrphan) {
            try {
              const catalogObj = JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
              const catalogList = catalogObj[tab] || [];
              const catalogTask = catalogList.find(t => {
                const tId = t.taskId || t.id;
                return tId && String(tId) === String(resolvedTaskId);
              });
              if (catalogTask) {
                displayId = catalogTask.id || '';
                displayTaskId = catalogTask.taskId || '';
              }
            } catch (e) {
              console.warn('[SETTINGS] Error loading catalog for ID display:', e);
            }
          }
          
        return `
            <div class="tasks-modal-draft-item" style="display:flex;flex-direction:column;padding:10px;margin-bottom:6px;background:#f9fafb;border:1px solid #7b3fe4;border-radius:6px;">
              <div style="flex:1;margin-bottom:6px;">
                <input type="text" class="tasks-edit-title" data-task-id="${resolvedTaskId}" value="${escapeHtmlDraft(task.title || '')}" placeholder="Task title" style="width:100%;padding:6px;margin-bottom:6px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;font-weight:600;font-family:inherit;" />
                <textarea class="tasks-edit-instructions" data-task-id="${resolvedTaskId}" placeholder="Instructions..." rows="3" style="width:100%;padding:6px;border:1px solid #e5e7eb;border-radius:6px;font-size:12px;resize:vertical;font-family:inherit;">${escapeHtmlDraft(task.instructions || '')}</textarea>
                <div style="margin-top:8px;padding:8px;background:#f3f4f6;border-radius:4px;font-size:11px;color:#666;">
                  <div style="margin-bottom:4px;"><strong>ID fields (read-only):</strong></div>
                  <div>task.id: ${escapeHtmlDraft(displayId || '(empty)')}</div>
                  <div>task.taskId: ${escapeHtmlDraft(displayTaskId || '(empty)')}</div>
                </div>
              </div>
              <div style="display:flex;flex-direction:column;gap:6px;">
                <div style="display:flex;gap:6px;justify-content:flex-end;">
                  <button class="tasks-modal-draft-save" data-task-id="${resolvedTaskId}" style="background:#7b3fe4;border:none;color:#fff;cursor:pointer;font-size:12px;padding:5px 10px;border-radius:4px;flex-shrink:0;">Save</button>
                  <button class="tasks-modal-draft-cancel-edit" data-task-id="${resolvedTaskId}" style="background:none;border:1px solid #e5e7eb;color:#666;cursor:pointer;font-size:12px;padding:5px 10px;border-radius:4px;flex-shrink:0;">Cancel</button>
                </div>
                <div style="display:flex;gap:6px;justify-content:flex-end;">
                  <button class="tasks-modal-draft-copy-ids" data-task-id="${resolvedTaskId}" data-task-title="${escapeHtmlDraft(task.title || '')}" data-task-id-value="${escapeHtmlDraft(displayId)}" data-task-taskid-value="${escapeHtmlDraft(displayTaskId)}" data-settings-tab="${tab}" style="background:none;border:none;color:#7b3fe4;cursor:pointer;font-size:11px;padding:3px 6px;text-decoration:underline;">Copy IDs</button>
                  <button class="tasks-modal-draft-force-delete" data-task-id="${resolvedTaskId}" data-task-id-value="${escapeHtmlDraft(displayId)}" data-task-taskid-value="${escapeHtmlDraft(displayTaskId)}" data-settings-tab="${tab}" style="background:none;border:none;color:#dc2626;cursor:pointer;font-size:11px;padding:3px 6px;text-decoration:underline;">Force Delete</button>
                </div>
              </div>
            </div>
          `;
        } else {
          // View mode: show title and instructions with Edit and Delete buttons (draggable)
          return `
            <div class="tasks-modal-draft-item" draggable="true" data-task-key="${String(resolvedTaskId || '').trim()}" data-is-orphan="${isOrphan ? 'true' : 'false'}" style="display:flex;align-items:flex-start;justify-content:space-between;padding:8px 10px;margin-bottom:6px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;cursor:move;">
            <div style="flex:1;">
                <div style="display:flex;align-items:center;gap:6px;margin-bottom:3px;">
                  <div style="font-weight:600;font-size:13px;color:#111;">${escapeHtmlDraft(task.title || '')}</div>
            </div>
                ${task.instructions ? `<div style="font-size:12px;color:#666;margin-top:2px;white-space:pre-wrap;">${escapeHtmlDraft(task.instructions)}</div>` : ''}
              </div>
              <div style="display:flex;gap:6px;align-items:center;margin-left:10px;flex-shrink:0;">
                <button class="tasks-modal-draft-edit" data-task-id="${resolvedTaskId}" style="background:none;border:none;color:#7b3fe4;cursor:pointer;font-size:12px;padding:3px 6px;border-radius:4px;text-decoration:underline;">Edit</button>
                <button class="tasks-modal-draft-remove" data-task-id="${resolvedTaskId}" data-is-orphan="${isOrphan ? 'true' : 'false'}" data-settings-tab="${tab}" style="background:none;border:none;color:#dc2626;cursor:pointer;font-size:12px;padding:3px 8px;border-radius:4px;text-decoration:underline;">DELETE</button>
              </div>
          </div>
        `;
        }
      }).join('');
      
      // Attach event handlers
      // Edit buttons
      modalListContainer.querySelectorAll('.tasks-modal-draft-edit').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const taskId = btn.dataset.taskId;
          startEditTask(taskId);
        });
      });
      
      // Save buttons
      modalListContainer.querySelectorAll('.tasks-modal-draft-save').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const taskId = btn.dataset.taskId;
          saveEditTask(taskId);
        });
      });
      
      // Cancel edit buttons
      modalListContainer.querySelectorAll('.tasks-modal-draft-cancel-edit').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          cancelEditTask();
        });
      });
      
      // Copy IDs buttons
      modalListContainer.querySelectorAll('.tasks-modal-draft-copy-ids').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const title = btn.dataset.taskTitle || '';
          const id = btn.dataset.taskIdValue || '';
          const taskId = btn.dataset.taskTaskidValue || '';
          const settingsTab = btn.dataset.settingsTab || tab;
          const copyText = `title="${title}" id="${id}" taskId="${taskId}" tab="${settingsTab}"`;
          navigator.clipboard.writeText(copyText).then(() => {
            console.log('[SETTINGS] Copied IDs to clipboard:', copyText);
          }).catch(err => {
            console.error('[SETTINGS] Failed to copy:', err);
            // Fallback: select text
            const textarea = document.createElement('textarea');
            textarea.value = copyText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
          });
        });
      });
      
      // Force Delete buttons
      modalListContainer.querySelectorAll('.tasks-modal-draft-force-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const taskIdParam = btn.dataset.taskId;
          const idValue = btn.dataset.taskIdValue || '';
          const taskIdValue = btn.dataset.taskTaskidValue || '';
          const settingsTab = btn.dataset.settingsTab || tab;
          
          // Build idVariants Set
          const idVariants = new Set();
          [idValue, taskIdValue, taskIdParam].forEach(v => {
            const normalized = String(v || "").trim();
            if (normalized) idVariants.add(normalized);
          });
          
          if (idVariants.size === 0) {
            console.warn('[SETTINGS] No ID variants found for Force Delete');
            return;
          }
          
          console.log('[SETTINGS] Force Delete - ID variants:', Array.from(idVariants));
          
          // Remove from catalog
          try {
            const catalogObj = JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
            if (catalogObj[settingsTab]) {
              catalogObj[settingsTab] = catalogObj[settingsTab].filter(t => {
                const tId = t.taskId || t.id;
                return !idVariants.has(String(tId || "").trim());
              });
              localStorage.setItem("ff_tasks_catalog_v1", JSON.stringify(catalogObj));
              if (window.ff_tasks_catalog_v1) {
                window.ff_tasks_catalog_v1[settingsTab] = catalogObj[settingsTab];
              }
            }
          } catch (e) {
            console.error('[SETTINGS] Error removing from catalog:', e);
          }
          
          // Remove from active/pending/done lists
          ['active', 'pending', 'done'].forEach(kind => {
            const key = `ff_tasks_${settingsTab}_${kind}_v1`;
            try {
              const arr = JSON.parse(localStorage.getItem(key) || "[]");
              const filtered = arr.filter(t => {
                const tId = t.taskId || t.id;
                return !idVariants.has(String(tId || "").trim());
              });
              if (typeof writeTasksList === 'function') {
                writeTasksList(settingsTab, kind, filtered);
              } else {
                localStorage.setItem(key, JSON.stringify(filtered));
              }
            } catch (e) {
              console.error(`[SETTINGS] Error removing from ${key}:`, e);
            }
          });
          
          // Add to tombstone
          try {
            const tombstoneKey = "ff_tasks_active_deleted_v1";
            let tombstone = {};
            try {
              const tombstoneRaw = localStorage.getItem(tombstoneKey);
              if (tombstoneRaw) {
                tombstone = JSON.parse(tombstoneRaw);
              }
            } catch (e) {
              console.warn('[SETTINGS] Error parsing tombstone:', e);
            }
            
            if (!tombstone || typeof tombstone !== 'object') {
              tombstone = { opening: [], closing: [], weekly: [], monthly: [], yearly: [] };
            }
            
            if (!Array.isArray(tombstone[settingsTab])) {
              tombstone[settingsTab] = [];
            }
            
            const existingIds = new Set(tombstone[settingsTab].map(id => String(id).trim()));
            idVariants.forEach(id => {
              if (!existingIds.has(id)) {
                tombstone[settingsTab].push(id);
                existingIds.add(id);
              }
            });
            
            localStorage.setItem(tombstoneKey, JSON.stringify(tombstone));
            console.log(`[SETTINGS] Added ID variants to tombstone for ${settingsTab}:`, Array.from(idVariants));
          } catch (e) {
            console.error('[SETTINGS] Error updating tombstone:', e);
          }
          
          // Close edit mode and refresh
          editingTaskId = null;
          renderSettingsTaskList(settingsTab);
          
          console.log('[SETTINGS] Force Delete completed');
        });
      });
      
      // Drag and drop handlers for catalog reordering (only for catalog tasks, not orphans)
      let draggedElement = null;
      let draggedKey = null;
      
      modalListContainer.querySelectorAll('.tasks-modal-draft-item[draggable="true"]').forEach(item => {
        const isOrphan = item.dataset.isOrphan === 'true';
        if (isOrphan) return; // Skip orphans, only allow reordering catalog tasks
        
        item.addEventListener('dragstart', (e) => {
          // Don't start drag if clicking on a button
          if (e.target.closest('button')) {
            e.preventDefault();
            return;
          }
          draggedElement = item;
          draggedKey = item.dataset.taskKey;
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', draggedKey);
          item.style.opacity = '0.5';
        });
        
        item.addEventListener('dragend', (e) => {
          item.style.opacity = '1';
          draggedElement = null;
          draggedKey = null;
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          if (draggedElement && draggedElement !== item) {
            const isOrphanTarget = item.dataset.isOrphan === 'true';
            if (isOrphanTarget) return; // Don't allow dropping on orphans
            
            const rect = item.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const mouseY = e.clientY;
            
            if (mouseY < midpoint) {
              item.parentNode.insertBefore(draggedElement, item);
            } else {
              item.parentNode.insertBefore(draggedElement, item.nextSibling);
            }
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!draggedKey) return;
          
          const isOrphanTarget = item.dataset.isOrphan === 'true';
          if (isOrphanTarget) return; // Don't allow dropping on orphans
          
          // Get current order from DOM
          const items = Array.from(modalListContainer.querySelectorAll('.tasks-modal-draft-item[draggable="true"]'));
          const reorderedKeys = items
            .filter(i => i.dataset.isOrphan !== 'true')
            .map(i => i.dataset.taskKey)
            .filter(Boolean);
          
          // Reorder catalog array based on DOM order
          const catalogArray = tasksModalDraft[tab] || [];
          const reorderedCatalog = [];
          const catalogMap = new Map();
          catalogArray.forEach(task => {
            const key = String(task.taskId || task.id || '').trim();
            if (key) catalogMap.set(key, task);
          });
          
          // Build reordered array following DOM order
          reorderedKeys.forEach(key => {
            const task = catalogMap.get(key);
            if (task) {
              reorderedCatalog.push(task);
              catalogMap.delete(key);
            }
          });
          
          // Add any remaining tasks (shouldn't happen, but safety)
          catalogMap.forEach(task => {
            reorderedCatalog.push(task);
          });
          
          // Update draft
          tasksModalDraft[tab] = reorderedCatalog;
          
          // Persist to localStorage
          try {
            const catalogObj = JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
            catalogObj[tab] = reorderedCatalog;
            localStorage.setItem("ff_tasks_catalog_v1", JSON.stringify(catalogObj));
            
            // Update window cache if it exists
            if (window.ff_tasks_catalog_v1) {
              window.ff_tasks_catalog_v1[tab] = reorderedCatalog;
            }
            
            console.log('[SETTINGS] Catalog reordered and saved for tab:', tab);
          } catch (e) {
            console.error('[SETTINGS] Error saving reordered catalog:', e);
          }
          
          // Re-render to update visual state
          renderSettingsTaskList(tab);
        });
      });
      
      // Remove buttons - now use taskId instead of index
      modalListContainer.querySelectorAll('.tasks-modal-draft-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const taskId = btn.dataset.taskId;
          const isOrphan = btn.dataset.isOrphan === 'true';
          const settingsTab = btn.dataset.settingsTab || tab; // Use Settings tab from button or fallback to current tab
          
          // Find the task object for debug log
          const task = combinedList.find(t => {
            const tId = t.taskId || t.id;
            return tId && String(tId) === String(taskId);
          });
          
          // TEMP debug log
          console.log("âœ… SETTINGS_DELETE_CLICK", { 
            tab: settingsTab, 
            title: task?.title, 
            id: task?.id, 
            taskId: task?.taskId 
          });
          
          // Call deletion logic - use task.id || task.taskId || taskId as the identifier
          const deleteId = task?.id || task?.taskId || taskId;
          removeTaskFromDraftByTaskId(deleteId, isOrphan, settingsTab);
        });
      });
    }
  } catch (e) {
    console.error('[SETTINGS] Error rendering Settings task list:', e);
    const modalListContainer = document.getElementById('tasksModalDraftList');
    if (modalListContainer) {
      modalListContainer.innerHTML = '<div style="padding:20px;text-align:center;color:#9ca3af;font-size:13px;">No tasks yet</div>';
    }
  }
}

// Ensure task storage is initialized for a specific tab
function ensureTaskStorageInitialized(tab) {
    // Initialize ONLY new v1 storage keys; legacy keys are left untouched.
    const keyActive = getTabStorageKey(tab, 'active');    // ff_tasks_${tab}_active_v1
    const keyPending = getTabStorageKey(tab, 'pending');  // ff_tasks_${tab}_pending_v1
    const keyDone = getTabStorageKey(tab, 'done');        // ff_tasks_${tab}_done_v1

    const catalog = window.ff_tasks_catalog_v1?.[tab] || [];

    // Load tombstone (deleted task IDs that should not be re-seeded)
    const tombstoneKey = "ff_tasks_active_deleted_v1";
    let blocked = new Set();
    try {
      const tombstoneRaw = localStorage.getItem(tombstoneKey);
      if (tombstoneRaw) {
        const tombstone = JSON.parse(tombstoneRaw);
        if (tombstone && typeof tombstone === 'object' && Array.isArray(tombstone[tab])) {
          blocked = new Set(tombstone[tab].map(id => String(id).trim()));
        }
      }
    } catch (e) {
      console.warn(`[INIT] Error loading tombstone for ${tab}:`, e);
    }

    // Create active list if missing (use catalog as initial roster)
    if (!localStorage.getItem(keyActive)) {
        console.log(`%c[INIT] Repopulating ACTIVE from catalog (active list missing)`, 'color:cyan;font-weight:bold', {
          tab,
          activeKey: keyActive,
          catalogCount: catalog.length,
          blockedCount: blocked.size
        });
        
        const initialActive = Array.isArray(catalog)
          ? catalog.map(task => {
              if (!task || typeof task !== 'object') return null;
              const keyId = task.taskId || task.id;
              if (!keyId) return null;
              
              // Skip if ANY ID variant of task is in tombstone (was explicitly deleted)
              const taskIds = new Set(
                [task.taskId, task.id].filter(Boolean).map(v => String(v).trim())
              );
              const isBlocked = Array.from(taskIds).some(id => blocked.has(id));
              if (isBlocked) {
                console.log(`[INIT] Skipping blocked task (ID variants: ${Array.from(taskIds).join(', ')}):`, task.title);
                return null;
              }
              
              return {
                id: keyId,
                taskId: keyId,
                title: task.title || '',
                instructions: task.instructions || task.info || task.details || '',
                status: null,
                assignedTo: null,
                completedBy: null,
                completedAt: null
              };
            }).filter(Boolean)
          : [];
        
        const taskIds = initialActive.map(t => t.taskId || t.id);
        console.log(`[INIT] Created initial ACTIVE list from catalog:`, {
          tab,
          activeKey: keyActive,
          activeCount: initialActive.length,
          taskIds: taskIds
        });
        
        writeTasksList(tab, 'active', initialActive);
    } else {
        console.log(`[INIT] ACTIVE list already exists for tab ${tab}, skipping repopulation`);
    }

    // Create empty pending and done if missing
    if (!localStorage.getItem(keyPending)) {
        writeTasksList(tab, 'pending', []);
    }
    if (!localStorage.getItem(keyDone)) {
        writeTasksList(tab, 'done', []);
    }
}

// Cleanup blocked tasks: Remove tasks from active/pending/done that are in tombstone
function cleanupBlockedTasks() {
  try {
    const tombstoneKey = "ff_tasks_active_deleted_v1";
    let tombstone = {};
    try {
      const tombstoneRaw = localStorage.getItem(tombstoneKey);
      if (tombstoneRaw) {
        tombstone = JSON.parse(tombstoneRaw);
      }
    } catch (e) {
      console.warn('[CLEANUP BLOCKED] Error parsing tombstone:', e);
      return;
    }
    
    if (!tombstone || typeof tombstone !== 'object') {
      return; // No tombstone, nothing to clean
    }
    
    const allTabs = ['opening', 'closing', 'weekly', 'monthly', 'yearly'];
    
    allTabs.forEach(tab => {
      const blocked = new Set((tombstone[tab] || []).map(x => String(x).trim()));
      if (blocked.size === 0) return; // No blocked IDs for this tab
      
      // Clean ACTIVE list
      const activeKey = `ff_tasks_${tab}_active_v1`;
      try {
        const arr = JSON.parse(localStorage.getItem(activeKey) || "[]");
        const filtered = arr.filter(t => {
          if (!t || typeof t !== 'object') return false;
          const ids = new Set([t?.taskId, t?.id].filter(Boolean).map(v => String(v).trim()));
          return !Array.from(ids).some(id => blocked.has(id));
        });
        if (filtered.length !== arr.length) {
          writeTasksList(tab, 'active', filtered);
          console.log(`[CLEANUP BLOCKED] Removed ${arr.length - filtered.length} blocked task(s) from ${activeKey}`);
        }
      } catch (e) {
        console.warn(`[CLEANUP BLOCKED] Error cleaning ${activeKey}:`, e);
      }
      
      // Clean PENDING list
      const pendingKey = `ff_tasks_${tab}_pending_v1`;
      try {
        const arr = JSON.parse(localStorage.getItem(pendingKey) || "[]");
        const filtered = arr.filter(t => {
          if (!t || typeof t !== 'object') return false;
          const ids = new Set([t?.taskId, t?.id].filter(Boolean).map(v => String(v).trim()));
          return !Array.from(ids).some(id => blocked.has(id));
        });
        if (filtered.length !== arr.length) {
          writeTasksList(tab, 'pending', filtered);
          console.log(`[CLEANUP BLOCKED] Removed ${arr.length - filtered.length} blocked task(s) from ${pendingKey}`);
        }
      } catch (e) {
        console.warn(`[CLEANUP BLOCKED] Error cleaning ${pendingKey}:`, e);
      }
      
      // Clean DONE list
      const doneKey = `ff_tasks_${tab}_done_v1`;
      try {
        const arr = JSON.parse(localStorage.getItem(doneKey) || "[]");
        const filtered = arr.filter(t => {
          if (!t || typeof t !== 'object') return false;
          const ids = new Set([t?.taskId, t?.id].filter(Boolean).map(v => String(v).trim()));
          return !Array.from(ids).some(id => blocked.has(id));
        });
        if (filtered.length !== arr.length) {
          writeTasksList(tab, 'done', filtered);
          console.log(`[CLEANUP BLOCKED] Removed ${arr.length - filtered.length} blocked task(s) from ${doneKey}`);
        }
      } catch (e) {
        console.warn(`[CLEANUP BLOCKED] Error cleaning ${doneKey}:`, e);
      }
    });
  } catch (e) {
    console.error('[CLEANUP BLOCKED] Error during blocked tasks cleanup:', e);
  }
}

// Cleanup orphan tasks: Remove tasks from active/pending/done that don't exist in catalog (ONE-TIME cleanup)
function cleanupOrphanTasks() {
  try {
    console.log('[CLEANUP] Starting orphan task cleanup...');
    
    // Build Set of valid taskIds from catalog (source of truth)
    const validTaskIds = new Set();
    let catalogObj = {};
    
    try {
      const raw = localStorage.getItem("ff_tasks_catalog_v1");
      if (raw) {
        catalogObj = JSON.parse(raw);
      }
    } catch (e) {
      console.warn('[CLEANUP] Error parsing catalog:', e);
      return; // Cannot cleanup without catalog
    }
    
    if (!catalogObj || Object.keys(catalogObj).length === 0) {
      catalogObj = window.ff_tasks_catalog_v1 || {};
    }
    
    // Collect all valid taskIds from all tabs in catalog (normalized: taskId || id)
    const allTabs = ['opening', 'closing', 'weekly', 'monthly', 'yearly'];
    allTabs.forEach(tab => {
      const catalogList = catalogObj[tab] || [];
      catalogList.forEach(task => {
        if (task && typeof task === 'object') {
          const resolvedTaskId = task.taskId || task.id;
          if (resolvedTaskId) {
            validTaskIds.add(String(resolvedTaskId));
          }
        }
      });
    });
    
    console.log(`[CLEANUP] Found ${validTaskIds.size} valid taskIds in catalog`);
    
    // Clean up active/pending lists for all tabs
    let totalRemoved = 0;
    
    allTabs.forEach(tab => {
      // Clean ACTIVE list
      const activeKey = `ff_tasks_${tab}_active_v1`;
      let activeTasks = [];
      try {
        const activeRaw = localStorage.getItem(activeKey);
        if (activeRaw) {
          activeTasks = JSON.parse(activeRaw) || [];
        }
      } catch (e) {
        console.warn(`[CLEANUP] Error parsing ${activeKey}:`, e);
        activeTasks = [];
      }
      
      const activeBefore = activeTasks.length;
      const activeCleaned = activeTasks.filter(task => {
        if (!task || typeof task !== 'object') return false;
        const resolvedTaskId = task.taskId || task.id;
        if (!resolvedTaskId) return false;
        const exists = validTaskIds.has(String(resolvedTaskId));
        if (!exists) {
          console.log(`[CLEANUP] Removing orphan from ACTIVE: ${tab}, taskId: ${resolvedTaskId}`);
        }
        return exists;
      });
      
      if (activeCleaned.length !== activeBefore) {
        writeTasksList(tab, 'active', activeCleaned);
        totalRemoved += (activeBefore - activeCleaned.length);
        console.log(`[CLEANUP] Cleaned ${activeKey}: ${activeBefore} -> ${activeCleaned.length} (removed ${activeBefore - activeCleaned.length})`);
      }
      
      // Clean PENDING list
      const pendingKey = `ff_tasks_${tab}_pending_v1`;
      let pendingTasks = [];
      try {
        const pendingRaw = localStorage.getItem(pendingKey);
        if (pendingRaw) {
          pendingTasks = JSON.parse(pendingRaw) || [];
        }
      } catch (e) {
        console.warn(`[CLEANUP] Error parsing ${pendingKey}:`, e);
        pendingTasks = [];
      }
      
      const pendingBefore = pendingTasks.length;
      const pendingCleaned = pendingTasks.filter(task => {
        if (!task || typeof task !== 'object') return false;
        const resolvedTaskId = task.taskId || task.id;
        if (!resolvedTaskId) return false;
        const exists = validTaskIds.has(String(resolvedTaskId));
        if (!exists) {
          console.log(`[CLEANUP] Removing orphan from PENDING: ${tab}, taskId: ${resolvedTaskId}`);
        }
        return exists;
      });
      
      if (pendingCleaned.length !== pendingBefore) {
        writeTasksList(tab, 'pending', pendingCleaned);
        totalRemoved += (pendingBefore - pendingCleaned.length);
        console.log(`[CLEANUP] Cleaned ${pendingKey}: ${pendingBefore} -> ${pendingCleaned.length} (removed ${pendingBefore - pendingCleaned.length})`);
      }
      
      // Clean DONE list
      const doneKey = `ff_tasks_${tab}_done_v1`;
      let doneTasks = [];
      try {
        const doneRaw = localStorage.getItem(doneKey);
        if (doneRaw) {
          doneTasks = JSON.parse(doneRaw) || [];
        }
      } catch (e) {
        console.warn(`[CLEANUP] Error parsing ${doneKey}:`, e);
        doneTasks = [];
      }
      
      const doneBefore = doneTasks.length;
      const doneCleaned = doneTasks.filter(task => {
        if (!task || typeof task !== 'object') return false;
        const resolvedTaskId = task.taskId || task.id;
        if (!resolvedTaskId) return false;
        const exists = validTaskIds.has(String(resolvedTaskId));
        if (!exists) {
          console.log(`[CLEANUP] Removing orphan from DONE: ${tab}, taskId: ${resolvedTaskId}`);
        }
        return exists;
      });
      
      if (doneCleaned.length !== doneBefore) {
        writeTasksList(tab, 'done', doneCleaned);
        totalRemoved += (doneBefore - doneCleaned.length);
        console.log(`[CLEANUP] Cleaned ${doneKey}: ${doneBefore} -> ${doneCleaned.length} (removed ${doneBefore - doneCleaned.length})`);
      }
    });
    
    if (totalRemoved > 0) {
      console.log(`[CLEANUP] Complete: Removed ${totalRemoved} orphan task(s) from active/pending/done lists`);
    } else {
      console.log('[CLEANUP] Complete: No orphan tasks found');
    }
  } catch (e) {
    console.error('[CLEANUP] Error during orphan cleanup:', e);
  }
}

// Helper functions for tombstone filtering
function normId(v) {
  return String(v ?? "").trim();
}

function getTaskIdVariants(t) {
  const a = normId(t?.taskId);
  const b = normId(t?.id);
  const out = [];
  if (a) out.push(a);
  if (b && b !== a) out.push(b);
  return out;
}

function getTombstone() {
  try {
    return JSON.parse(localStorage.getItem("ff_tasks_active_deleted_v1") || "{}");
  } catch {
    return {};
  }
}

function filterBlocked(tab, arr) {
  const tomb = getTombstone();
  const blockedArr = Array.isArray(tomb?.[tab]) ? tomb[tab] : [];
  const blocked = new Set(blockedArr.map(normId).filter(Boolean));
  if (!blocked.size) return Array.isArray(arr) ? arr : [];

  return (Array.isArray(arr) ? arr : []).filter(t => {
    const ids = getTaskIdVariants(t);
    return !ids.some(id => blocked.has(id));
  });
}

/**
 * THE ONLY ALLOWED WRITER for task runtime lists
 * tab: opening | closing | weekly | monthly | yearly
 * kind: active | pending | done
 */
function writeTasksList(tab, kind, arr) {
  const key = `ff_tasks_${tab}_${kind}_v1`;
  const filtered = filterBlocked(tab, arr);

  localStorage.setItem(key, JSON.stringify(filtered));

  // keep cache consistent ONLY if it already exists
  if (window[key] && Array.isArray(window[key])) {
    window[key] = filtered;
  }

  return filtered;
}

function openTasks() {
  try {
    // HARD GUARANTEE: Patch localStorage.setItem to filter tombstoned tasks (one-time)
    if (!window.__ffTombstonePatchInstalled) {
      window.__ffTombstonePatchInstalled = true;
      const originalSetItem = localStorage.setItem.bind(localStorage);
      localStorage.setItem = function(key, value) {
        const keyStr = String(key || "");
        // Only intercept task list keys: ff_tasks_${tab}_${kind}_v1
        const match = keyStr.match(/^ff_tasks_(opening|closing|weekly|monthly|yearly)_(active|pending|done)_v1$/);
        if (match) {
          const tab = match[1];
          const kind = match[2];
          try {
            // Parse incoming value as JSON array
            const arr = JSON.parse(value);
            if (!Array.isArray(arr)) {
              // Not an array, fall back to original
              return originalSetItem(key, value);
            }
            
            // Load tombstone DIRECTLY from localStorage every time
            const tomb = JSON.parse(localStorage.getItem("ff_tasks_active_deleted_v1") || "{}");
            const blocked = new Set((tomb[tab] || []).map(x => String(x || "").trim()).filter(Boolean));
            
            if (blocked.size === 0) {
              // No blocked IDs, proceed normally
              return originalSetItem(key, value);
            }
            
            // Filter the array BEFORE saving
            const originalLength = arr.length;
            const filtered = arr.filter(item => {
              if (!item || typeof item !== 'object') return true;
              const itemId = String(item.id || "").trim();
              const itemTaskId = String(item.taskId || "").trim();
              // Remove if EITHER id OR taskId is in blocked
              return !blocked.has(itemId) && !blocked.has(itemTaskId);
            });
            
            const removedCount = originalLength - filtered.length;
            if (removedCount > 0) {
              console.log("ğŸ§¹ tombstone filtered write", { key, removedCount });
            }
            
            // Update window cache if it exists
            if (window[keyStr] && Array.isArray(window[keyStr])) {
              window[keyStr] = filtered;
            }
            
            // Call original setItem with filtered array
            return originalSetItem(key, JSON.stringify(filtered));
          } catch (e) {
            // Parse failed or other error, fall back to original
            return originalSetItem(key, value);
          }
        } else {
          // Not a task list key, proceed normally
          return originalSetItem(key, value);
        }
      };
      console.log('[TASKS] Tombstone filter patch installed');
    }
    
    // Ensure a default tab exists when Tasks screen loads
    window.currentTasksTab = window.currentTasksTab || "opening";
    console.log("INIT TAB â†’", window.currentTasksTab);
    
    const tasksScreen = document.getElementById('tasksScreen');
    const mainContent = document.querySelector('#owner-view .wrap');
    const joinBar = document.getElementById('joinBar');
    const header = document.querySelector('#owner-view .header');
    
    if (!tasksScreen) {
      console.error('[Tasks] tasksScreen element not found');
      return;
    }
    
    // Snapshot header layout before hiding
    snapshotHeaderLayout();
    
    // Hide main content and header
    if (mainContent) mainContent.style.display = 'none';
    if (joinBar) joinBar.style.display = 'none';
    if (header) header.style.display = 'none';
    
    // Show Tasks screen
    tasksScreen.style.display = 'flex';
    tasksScreen.style.pointerEvents = 'auto';
    
    // Initialize storage for all tabs
    ['opening', 'closing', 'weekly', 'monthly', 'yearly'].forEach(ensureTaskStorageInitialized);
    
    // Cleanup orphan tasks (one-time cleanup on load)
    cleanupOrphanTasks();
    
    // Cleanup blocked tasks (remove tasks in tombstone from existing lists)
    cleanupBlockedTasks();
    
    // FINAL ROOT FIX: Cleanup blocked tasks from active list (direct execution, no cache)
    // MUST run for ALL TABS, not only currentTasksTab
    const tombstone = JSON.parse(localStorage.getItem("ff_tasks_active_deleted_v1") || "{}");
    const tabs = ["opening", "closing", "weekly", "monthly", "yearly"];
    
    tabs.forEach(tab => {
      const blocked = new Set((tombstone[tab] || []).map(x => String(x).trim()));
      if (!blocked.size) return;
      
      const key = `ff_tasks_${tab}_active_v1`;
      const arr = JSON.parse(localStorage.getItem(key) || "[]");
      
      const filtered = arr.filter(t => {
        const ids = [t?.taskId, t?.id].filter(Boolean).map(v => String(v).trim());
        return !ids.some(id => blocked.has(id));
      });
      
      if (filtered.length !== arr.length) {
        const m = String(key).match(
          /^ff_tasks_(opening|closing|weekly|monthly|yearly)_(active|pending|done)_v1$/
        );
        if (m) {
          writeTasksList(m[1], m[2], filtered);
        } else {
          localStorage.setItem(key, JSON.stringify(filtered));
        }
      }
    });
    
    // Load tasks from storage (single source of truth)
    loadTasks();
    
    // Ensure event listeners are attached (re-initialize if needed)
    setTimeout(() => {
      if (typeof window.initializeTasksScreenButtons === 'function') {
        window.initializeTasksScreenButtons();
      }
      // Check user role for reset button visibility
      if (typeof window.showResetBtnIfAllowed === 'function') {
        window.showResetBtnIfAllowed();
      }
    }, 50);
    
    // Set default tab to Opening (this will render tasks)
    setTasksTab('opening');
    
    // After DOM rendering is completed and renderTasksList() has run, check reset button visibility
    setTimeout(() => showResetBtnIfAllowed(), 150);
    
    // Initialize RESET button after rendering tasks (one-time only)
    setTimeout(() => {
      initializeResetButton();
    }, 200);
    
    console.log('[Tasks] Tasks screen opened');
  } catch (e) {
    console.error('[Tasks] Error opening Tasks screen:', e);
  }
}

function closeTasks() {
  try {
    const tasksScreen = document.getElementById('tasksScreen');
    const mainContent = document.querySelector('#owner-view .wrap');
    const joinBar = document.getElementById('joinBar');
    const header = document.querySelector('#owner-view .header');
    
    if (!tasksScreen) {
      console.error('[Tasks] tasksScreen element not found');
      return;
    }
    
    // Hide Tasks screen
    tasksScreen.style.display = 'none';
    
    // Restore header layout first (before showing elements)
    restoreHeaderLayout();
    
    // Show main content and header (restoreHeaderLayout already restored header display)
    if (mainContent) mainContent.style.display = 'block';
    if (joinBar) joinBar.style.display = 'flex';
    // Header display is restored by restoreHeaderLayout()
    
    console.log('[Tasks] Tasks screen closed');
  } catch (e) {
    console.error('[Tasks] Error closing Tasks screen:', e);
  }
}

function setTasksTab(tabName) {
  console.log("SET TASK TAB CALLED:", tabName);
  console.log("TAB CLICKED:", tabName);
  try {
    const tabs = document.querySelectorAll('.tasks-tab');
    const contentContainer = document.getElementById('tasksContentContainer');
    
    if (!contentContainer) {
      console.error('[Tasks] tasksContentContainer element not found');
      return;
    }
    
    // Update tab styles
    tabs.forEach(tab => {
      const isActive = tab.dataset.tab === tabName;
      if (isActive) {
        tab.style.color = '#111';
        tab.style.borderBottomColor = '#7b3fe4';
        tab.style.fontWeight = '600';
      } else {
        tab.style.color = '#666';
        tab.style.borderBottomColor = 'transparent';
        tab.style.fontWeight = '500';
      }
    });
    
    // Always update the active tab BEFORE rendering (single source of truth)
    window.currentTasksTab = tabName.toLowerCase();
    window.currentTasksTabOriginal = tabName;
    console.log("ACTIVE TAB SET â†’", window.currentTasksTab);
    
    // Get tab label
    const tabLabels = {
      'opening': 'Opening',
      'closing': 'Closing',
      'weekly': 'Weekly',
      'monthly': 'Monthly',
      'yearly': 'Yearly'
    };
    const label = tabLabels[tabName] || tabName;
    
    // Render two-column layout
    contentContainer.innerHTML = `
      <div class="tasks-col">
        <h2>MY LIST</h2>
        <div class="tasks-list">
          <div style="padding:20px;text-align:center;color:#6b7280;font-size:14px;">No tasks yet</div>
        </div>
      </div>
      <div class="tasks-col">
        <h2>PENDING</h2>
        <div class="tasks-list">
          <div style="padding:20px;text-align:center;color:#6b7280;font-size:14px;">Pending (coming soon)</div>
        </div>
      </div>
    `;
    
    // Render tasks for current tab
    renderTasksList(window.currentTasksTab);
    
    // Setup delegated click handler for info icons (attach once)
    setupTasksInfoIconHandler();
    
    console.log('[Tasks] Tab switched to:', tabName);
  } catch (e) {
    console.error('[Tasks] Error setting tab:', e);
  }
}

// Tasks Settings Modal Functions
let isTasksSettingsOpen = false;
let tasksSettingsModalContainer = null; // Reference to modal container element
// Use window.currentTasksTab as single source of truth for current tab
let tasksModalDraft = {
  opening: [],
  closing: [],
  weekly: [],
  monthly: [],
  yearly: []
}; // In-memory arrays per tab

// Track which task is currently being edited (by taskId)
let editingTaskId = null;

function getCurrentTasksTab() {
  return window.currentTasksTab || 'opening';
}

function setSettingsModalTab(tabName) {
  try {
    const tabs = document.querySelectorAll('.tasks-settings-tab');
    
    // Update tab styles
    tabs.forEach(tab => {
      const isActive = tab.dataset.tab === tabName;
      if (isActive) {
        tab.style.color = '#111';
        tab.style.borderBottomColor = '#7b3fe4';
        tab.style.fontWeight = '600';
      } else {
        tab.style.color = '#666';
        tab.style.borderBottomColor = 'transparent';
        tab.style.fontWeight = '500';
      }
    });
    
    // Update single source of truth for current tab
    window.currentTasksTab = tabName.toLowerCase();
    
    // Clear editing state when switching tabs
    editingTaskId = null;
    
    // Load tasks for this tab
    loadTasksForSettingsTab(tabName);
    
    // Render Settings modal list from catalog
    renderSettingsTaskList(tabName);
    
    console.log('[Tasks] Settings modal tab switched to:', tabName);
  } catch (e) {
    console.error('[Tasks] Error setting Settings modal tab:', e);
  }
}

function saveTasksToStorage() {
  try {
    // Get current tab (Settings modal tab)
    const tab = getCurrentTasksTab();
    const currentTabTasks = tasksModalDraft[tab] || [];
    
    // 1) Update catalog (ff_tasks_catalog_v1) with template-only entries
    let catalogObj = {};
    try {
      const raw = localStorage.getItem("ff_tasks_catalog_v1");
      if (raw) {
        catalogObj = JSON.parse(raw);
      }
    } catch (e) {
      console.warn('[Tasks] Error parsing catalog from localStorage:', e);
    }
    
    // Fallback to window object
    if (!catalogObj || Object.keys(catalogObj).length === 0) {
      catalogObj = window.ff_tasks_catalog_v1 || {};
    }
    
    // Sanitize tasks for catalog: keep only id/title/instructions (no runtime status fields)
    const catalogList = currentTabTasks.map(task => {
      if (!task || typeof task !== 'object') return null;
      const keyId = task.taskId || task.id;
      if (!keyId) return null;
      return {
        id: keyId,
        title: task.title || '',
        instructions: task.instructions || task.info || task.details || ''
      };
    }).filter(Boolean);
    
    // Update catalog for this tab
    catalogObj[tab] = catalogList;
    localStorage.setItem("ff_tasks_catalog_v1", JSON.stringify(catalogObj));
    
    // Update window object to keep it in sync
    if (typeof window.ff_tasks_catalog_v1 === 'undefined' || !window.ff_tasks_catalog_v1) {
      window.ff_tasks_catalog_v1 = {};
    }
    window.ff_tasks_catalog_v1[tab] = catalogList;
    
    // 2) Update active list (ff_tasks_${tab}_active_v1) - append new tasks if not already present
    const activeKey = getTabStorageKey(tab, 'active');
    console.log(`%c[SYNC/SAVE] Repopulating ACTIVE from catalog`, 'color:purple;font-weight:bold', {
      tab,
      activeKey,
      catalogCount: catalogList.length
    });
    
    let activeTasks = [];
    try {
      const activeStored = localStorage.getItem(activeKey);
      if (activeStored) {
        activeTasks = JSON.parse(activeStored) || [];
      }
    } catch (e) {
      console.warn('[Tasks] Error parsing active tasks:', e);
    }
    
    const activeBeforeLength = activeTasks.length;
    console.log(`[SYNC/SAVE] Active tasks count before sync: ${activeBeforeLength}`);
    
    // Normalize existing active tasks: ensure id/taskId and active flag
    activeTasks = (activeTasks || []).map(task => {
      if (!task || typeof task !== 'object') return null;
      const keyId = task.taskId || task.id;
      if (!keyId) return null;
      return {
        ...task,
        id: keyId,
        taskId: keyId,
        active: task.active == null ? true : task.active
      };
    }).filter(Boolean);
    
    // Build set of existing active task IDs (using taskId || id)
    const activeIds = new Set(activeTasks.map(t => t.taskId || t.id).filter(Boolean));
    console.log(`[SYNC/SAVE] Existing active task IDs:`, Array.from(activeIds));
    
    // Load tombstone (deleted task IDs that should not be re-seeded)
    const tombstoneKey = "ff_tasks_active_deleted_v1";
    let blocked = new Set();
    try {
      const tombstoneRaw = localStorage.getItem(tombstoneKey);
      if (tombstoneRaw) {
        const tombstone = JSON.parse(tombstoneRaw);
        if (tombstone && typeof tombstone === 'object' && Array.isArray(tombstone[tab])) {
          blocked = new Set(tombstone[tab].map(id => String(id).trim()));
        }
      }
    } catch (e) {
      console.warn(`[SYNC/SAVE] Error loading tombstone for ${tab}:`, e);
    }
    
    const tasksAdded = [];
    // Append new tasks from catalog that aren't already in active list.
    // Do NOT modify existing active tasks or their statuses.
    catalogList.forEach(task => {
      const keyId = task.id; // catalogList already normalized to use id
      
      // Skip if ANY ID variant of task is in tombstone (was explicitly deleted)
      const taskIds = new Set(
        [task.taskId, task.id].filter(Boolean).map(v => String(v).trim())
      );
      const isBlocked = Array.from(taskIds).some(id => blocked.has(id));
      if (isBlocked) {
        console.log(`[SYNC/SAVE] Skipping blocked task (ID variants: ${Array.from(taskIds).join(', ')}):`, task.title);
        return;
      }
      
      if (keyId && !activeIds.has(keyId)) {
        const newActiveTask = {
          id: keyId,
          taskId: keyId,
          title: task.title,
          instructions: task.instructions,
          active: true,
          status: null,
          assignedTo: null,
          completedBy: null,
          completedAt: null
        };
        activeTasks.push(newActiveTask);
        activeIds.add(keyId); // Prevent duplicates
        tasksAdded.push(keyId);
        console.log(`[SYNC/SAVE] Added new task to ACTIVE from catalog:`, {
          tab,
          taskId: keyId,
          activeKey,
          task: newActiveTask
        });
      } else if (keyId && activeIds.has(keyId)) {
        console.log(`[SYNC/SAVE] Task ${keyId} already exists in ACTIVE, skipping (preserving existing status/state)`);
      }
    });
    
    const activeAfterLength = activeTasks.length;
    console.log(`[SYNC/SAVE] Active tasks count after sync: ${activeAfterLength} (added ${tasksAdded.length} new tasks)`);
    
    // Save updated active list
    saveTabTasks(tab, 'active', activeTasks);
    
    console.log(`%c[SYNC/SAVE] COMPLETE - ACTIVE repopulated from catalog`, 'color:green;font-weight:bold', {
      tab,
      activeKey,
      catalogCount: catalogList.length,
      activeBefore: activeBeforeLength,
      activeAfter: activeAfterLength,
      tasksAdded: tasksAdded.length,
      taskIdsAdded: tasksAdded
    });
    
    // TEMP debug: log v1 active count after save
    try {
      const newKey = getTabStorageKey(tab, 'active');
      const count = JSON.parse(localStorage.getItem(newKey) || "[]").length;
      console.log("ACTIVE v1 count", tab, count);
    } catch (e) {
      console.warn('[Tasks] Error logging ACTIVE v1 count:', e);
    }
    
    console.log(`[Tasks] Saved ${catalogList.length} tasks to catalog and ${activeTasks.length} tasks to active list for tab: ${tab}`);
    return true;
  } catch (e) {
    console.error('[Tasks] Error saving to storage:', e);
    return false;
  }
}

// One-time migration/merge from any legacy active storage into v1 key for a tab.
// After migration, MY LIST reads ONLY from ff_tasks_${tab}_active_v1 via getTabStorageKey(tab, 'active').
function migrateLegacyActiveToV1(tab) {
  try {
    if (!tab) return;
    
    const newKey = getTabStorageKey(tab, 'active'); // ff_tasks_${tab}_active_v1
    const legacyKeys = [
      `ffv24_tasks_${tab}_active`,
      `ffv24_tasks_${tab}_active_v1`,
      `ff_tasks_${tab}_active`
    ];
    
    const mergedById = new Map();
    
    // Helper to merge an array of tasks into the map by stable id (taskId || id)
    function mergeTasks(tasks) {
      if (!Array.isArray(tasks)) return;
      tasks.forEach(t => {
        if (!t || typeof t !== 'object') return;
        const keyId = t.taskId || t.id;
        if (!keyId) return;
        const existing = mergedById.get(keyId) || {};
        // Merge while enforcing id/taskId/active and preserving any runtime fields already present
        const merged = {
          ...existing,
          ...t,
          id: keyId,
          taskId: keyId,
          active: t.active == null ? true : t.active
        };
        mergedById.set(keyId, merged);
      });
    }
    
    // 1) Start with current v1 active as base
    try {
      const rawNew = localStorage.getItem(newKey);
      if (rawNew) {
        const arr = JSON.parse(rawNew) || [];
        mergeTasks(arr);
      }
    } catch (e) {
      console.warn('[Tasks] Error parsing current v1 active for migration:', e);
    }
    
    // 2) Merge in all legacy keys (if present)
    legacyKeys.forEach(k => {
      const raw = localStorage.getItem(k);
      if (!raw) return;
      try {
        const arr = JSON.parse(raw) || [];
        mergeTasks(arr);
      } catch (e) {
        console.warn('[Tasks] Error parsing legacy active key', k, e);
      }
    });
    
    // Save merged result back to v1 key
    const mergedArray = Array.from(mergedById.values());
    localStorage.setItem(newKey, JSON.stringify(mergedArray));
    
    // TEMP debug log for active v1 count after migration
    try {
      const count = JSON.parse(localStorage.getItem(newKey) || "[]").length;
      console.log("ACTIVE v1 count", tab, count);
    } catch (e) {
      console.warn('[Tasks] Error logging ACTIVE v1 count after migration:', e);
    }
  } catch (e) {
    console.error('[Tasks] Error in migrateLegacyActiveToV1 for tab', tab, e);
  }
}

// =====================
// Tab-specific storage helpers
// =====================

// Get storage key for a specific tab and status
function getTabStorageKey(tab, status) {
  const statusMap = {
    'active': 'active',
    'pending': 'pending',
    'done': 'done'
  };
  const statusKey = statusMap[status] || 'active';
  return `ff_tasks_${tab}_${statusKey}_v1`;
}

// Get tasks for a specific tab and status
function getTabTasks(tab, status) {
  try {
    const key = getTabStorageKey(tab, status);
    const stored = localStorage.getItem(key);
    if (stored) {
      return JSON.parse(stored) || [];
    }
  } catch (e) {
    console.error(`[Tasks] Error loading ${tab} ${status} tasks:`, e);
  }
  return [];
}

// Save tasks for a specific tab and status
function saveTabTasks(tab, status, tasks) {
  try {
    const key = getTabStorageKey(tab, status);
    const m = String(key).match(
      /^ff_tasks_(opening|closing|weekly|monthly|yearly)_(active|pending|done)_v1$/
    );
    if (m) {
      writeTasksList(m[1], m[2], tasks);
    } else {
    localStorage.setItem(key, JSON.stringify(tasks));
    }
    return true;
  } catch (e) {
    console.error(`[Tasks] Error saving ${tab} ${status} tasks:`, e);
    return false;
  }
}

// Shared function to render tasks list (used by both modal and main screen)
function renderTasksList(tab, opts) {
  try {
    // Use provided tab or fall back to window.currentTasksTab or default
    const currentTab = tab || window.currentTasksTab || 'opening';
    
    // If force option is set, bypass any caches and rebuild fresh
    const force = opts?.force === true;
    
    // Before any reads, run one-time migration for this tab to ensure v1 active is the source of truth
    if (typeof migrateLegacyActiveToV1 === 'function') {
      migrateLegacyActiveToV1(currentTab);
    }
    
    // Render modal list (Settings modal)
    const modalListContainer = document.getElementById('tasksModalDraftList');
    if (modalListContainer && isTasksSettingsOpen) {
      const settingsTab = window.currentTasksTab || 'opening';
      const tasks = tasksModalDraft[settingsTab] || [];
      
      if (tasks.length === 0) {
        modalListContainer.innerHTML = '<div style="padding:20px;text-align:center;color:#9ca3af;font-size:13px;">No tasks yet</div>';
      } else {
        // Show newest first (reverse array)
        const tasksReversed = [...tasks].reverse();
        
        modalListContainer.innerHTML = tasksReversed.map((task, displayIndex) => {
          const actualIndex = tasks.length - 1 - displayIndex;
          return `
            <div class="tasks-modal-draft-item" style="display:flex;align-items:flex-start;justify-content:space-between;padding:12px;margin-bottom:8px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;">
              <div style="flex:1;">
                <div style="font-weight:600;font-size:14px;color:#111;margin-bottom:4px;">${escapeHtmlDraft(task.title)}</div>
                ${task.instructions ? `<div style="font-size:13px;color:#666;margin-top:4px;white-space:pre-wrap;">${escapeHtmlDraft(task.instructions)}</div>` : ''}
              </div>
              <button class="tasks-modal-draft-remove" data-index="${actualIndex}" style="background:none;border:none;color:#dc2626;cursor:pointer;font-size:18px;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;margin-left:12px;border-radius:4px;flex-shrink:0;">Ã—</button>
            </div>
          `;
        }).join('');
        
        // Attach remove handlers for modal
        modalListContainer.querySelectorAll('.tasks-modal-draft-remove').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const index = parseInt(btn.dataset.index);
            removeTaskFromDraft(index);
          });
        });
      }
    }
    
    // If force option is set, clear any caches for this tab before rendering
    if (force) {
      if (typeof window.tasksCache !== 'undefined' && window.tasksCache && window.tasksCache[currentTab]) {
        delete window.tasksCache[currentTab];
      }
      if (typeof window.myListCache !== 'undefined' && window.myListCache && window.myListCache[currentTab]) {
        delete window.myListCache[currentTab];
      }
    }
    
    // Render main screen MY LIST (active tasks) - only if main screen is visible and Settings modal is NOT open
    const mainListContainer = document.querySelector('#tasksContentContainer .tasks-col:first-child .tasks-list');
    if (mainListContainer && !isTasksSettingsOpen) {
      // Get current tab for main Tasks screen (not Settings modal)
      const mainTab = currentTab;
      
      // Get tasks from tab-specific storage for main screen (getTabTasks reads directly from localStorage, no cache)
      const activeTasks = getTabTasks(mainTab, 'active');
      const doneTasks = getTabTasks(mainTab, 'done');
      const pendingTasks = getTabTasks(mainTab, 'pending');
      
      // Build MY LIST directly from ACTIVE list only
      const myListTasks = activeTasks
        .filter(task => {
          if (!task || typeof task !== 'object') return false;
          const keyId = task.taskId || task.id;
          if (!keyId) return false;
          // Only consider tasks that are marked active (default true)
          const isActiveFlag = task.active == null ? true : !!task.active;
          if (!isActiveFlag) return false;
          // Hide tasks that are pending (status='pending' or assignedTo exists)
          if (task.status === 'pending' || !!task.assignedTo) return false;
          return true;
        });
      
      // Show "No tasks yet" only if ACTIVE list has no displayable tasks
      if (myListTasks.length === 0) {
        mainListContainer.innerHTML = '<div style="padding:20px;text-align:center;color:#6b7280;font-size:14px;">No tasks yet</div>';
      } else {
        // Split tasks into incomplete and completed groups
        const incomplete = [];
        const completed = [];
        
        myListTasks.forEach(task => {
          const isCompleted = task.status === 'done' || !!task.completedAt;
          if (isCompleted) {
            completed.push(task);
          } else {
            incomplete.push(task);
          }
        });
        
        // Apply catalog order to MY LIST (display order only, no state changes)
        let catalogOrder = [];
        try {
          const catalogObj = JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
          catalogOrder = (catalogObj[mainTab] || []).map(t => String(t.taskId || t.id || '').trim()).filter(Boolean);
        } catch (e) {
          console.warn('[MY LIST] Error loading catalog for ordering:', e);
        }
        
        // Sort by catalog order: tasks in catalog appear in catalog order, others at end
        const sortedIncomplete = incomplete.sort((a, b) => {
          const aKey = String(a.taskId || a.id || '').trim();
          const bKey = String(b.taskId || b.id || '').trim();
          const aIndex = catalogOrder.indexOf(aKey);
          const bIndex = catalogOrder.indexOf(bKey);
          
          // Both in catalog: use catalog order
          if (aIndex >= 0 && bIndex >= 0) return aIndex - bIndex;
          // Only a in catalog: a comes first
          if (aIndex >= 0) return -1;
          // Only b in catalog: b comes first
          if (bIndex >= 0) return 1;
          // Neither in catalog: maintain original order
          return 0;
        });
        
        const sortedCompleted = completed.sort((a, b) => {
          const aKey = String(a.taskId || a.id || '').trim();
          const bKey = String(b.taskId || b.id || '').trim();
          const aIndex = catalogOrder.indexOf(aKey);
          const bIndex = catalogOrder.indexOf(bKey);
          
          // Both in catalog: use catalog order
          if (aIndex >= 0 && bIndex >= 0) return aIndex - bIndex;
          // Only a in catalog: a comes first
          if (aIndex >= 0) return -1;
          // Only b in catalog: b comes first
          if (bIndex >= 0) return 1;
          // Neither in catalog: maintain original order
          return 0;
        });
        
        const tasksReversed = [...sortedIncomplete, ...sortedCompleted];
        
        mainListContainer.innerHTML = tasksReversed.map((task, displayIndex) => {
          // Check for instructions in any of the possible fields
          const instructions = task.instructions || task.info || task.details || '';
          const hasInstructions = instructions.trim().length > 0;
          
          // Use consistent keyId: taskId || id
          const keyId = task.taskId || task.id;
          
          // Check if task is completed (status === 'done' or completedAt exists)
          const isCompleted = task.status === 'done' || !!task.completedAt;
          const doneTaskData = isCompleted ? {
            completedBy: task.completedBy || null
          } : null;
          
          let doneClass = "";
          let extraInfo = "";
          let buttonsHtml = "";
          let cardStyle = "display:flex;align-items:flex-start;justify-content:space-between;padding:12px;margin-bottom:8px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;";
          
          if (isCompleted) {
            // Completed task: light green background, disabled button
            doneClass = "task-item-done";
            cardStyle = "display:flex;align-items:flex-start;justify-content:space-between;padding:12px;margin-bottom:8px;background:#d1fae5;border:1px solid #a7f3d0;border-radius:6px;";
            extraInfo = doneTaskData?.completedBy ? `<div class="task-worker" style="color:#065f46;font-size:12px;margin-top:4px;">Completed by: ${escapeHtmlDraft(doneTaskData.completedBy)}</div>` : "";
            
            // Render info button only if instructions exist
            let infoButtonHtml = '';
            if (hasInstructions) {
              const escapedInstructions = escapeHtmlAttr(instructions);
              const taskIdAttr = keyId ? ` data-task-id="${escapeHtmlAttr(keyId)}"` : '';
              infoButtonHtml = `<button type="button" class="tasks-info-icon" data-instructions="${escapedInstructions}"${taskIdAttr} style="background:#7b3fe4;border:none;color:#fff;cursor:pointer;font-size:12px;font-weight:700;padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;margin-left:12px;border-radius:50%;flex-shrink:0;line-height:1;" title="View instructions">i</button>`;
            }
            
            // Disabled COMPLETED button (not clickable)
            buttonsHtml = `
              <div style="display:flex;align-items:center;gap:8px;">
                ${infoButtonHtml}
                <button type="button" class="task-completed-btn" disabled style="padding:6px 12px;font-size:12px;font-weight:600;color:#065f46;background:#a7f3d0;border:1px solid #6ee7b7;border-radius:6px;cursor:not-allowed;flex-shrink:0;opacity:0.7;">COMPLETED</button>
              </div>
            `;
          } else {
            // Available task: normal rendering with SELECT button
            let infoButtonHtml = '';
            if (hasInstructions) {
              const escapedInstructions = escapeHtmlAttr(instructions);
              const taskIdAttr = keyId ? ` data-task-id="${escapeHtmlAttr(keyId)}"` : '';
              infoButtonHtml = `<button type="button" class="tasks-info-icon" data-instructions="${escapedInstructions}"${taskIdAttr} style="background:#7b3fe4;border:none;color:#fff;cursor:pointer;font-size:12px;font-weight:700;padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;margin-left:12px;border-radius:50%;flex-shrink:0;line-height:1;" title="View instructions">i</button>`;
            }
            buttonsHtml = `
              <div style="display:flex;align-items:center;gap:8px;">
                ${infoButtonHtml}
                <button type="button" class="task-select-btn btn-neutral" style="flex-shrink:0;">SELECT</button>
              </div>
            `;
          }
          
          const taskIdAttr = keyId ? ` data-task-id="${escapeHtmlAttr(keyId)}" data-is-completed="${isCompleted ? 'true' : 'false'}"` : '';
          // Add red status dot only for selectable (non-completed) tasks in MY LIST
          const statusDot = !isCompleted ? '<span class="task-status-dot"></span>' : '';
          return `
            <div class="tasks-main-list-item ${doneClass}"${taskIdAttr} style="${cardStyle}">
              <div style="flex:1;">
                <div style="display:flex;align-items:center;font-weight:600;font-size:14px;color:#111;margin-bottom:4px;">${statusDot}${escapeHtmlDraft(task.title)}</div>
                ${extraInfo}
              </div>
              ${buttonsHtml}
            </div>
          `;
        }).join('');
        
        // Attach click handlers for SELECT buttons (only for available tasks)
        mainListContainer.querySelectorAll('.task-select-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const taskItem = btn.closest('.tasks-main-list-item');
            if (taskItem && taskItem.dataset.taskId) {
              // Guard: don't allow selection of completed tasks
              if (taskItem.dataset.isCompleted === 'true') {
                return;
              }
              const taskId = taskItem.dataset.taskId;
              if (typeof window.openPinModal === 'function') {
                window.openPinModal(taskId);
              }
            }
          });
        });
        
        // Prevent clicks on completed task cards
        mainListContainer.querySelectorAll('.task-item-done').forEach(card => {
          if (card.dataset.isCompleted === 'true') {
            card.addEventListener('click', (e) => {
              // Only prevent if clicking on the card itself, not on info icon
              if (e.target === card || e.target.closest('.task-completed-btn')) {
                e.preventDefault();
                e.stopPropagation();
              }
            });
          }
        });
      }
    }
    
    // Render PENDING column (pending tasks) - only if main screen is visible and Settings modal is NOT open
    const pendingListContainer = document.querySelector('#tasksContentContainer .tasks-col:last-child .tasks-list');
    if (pendingListContainer && !isTasksSettingsOpen) {
      // Get current tab for main Tasks screen
      const mainTab = currentTasksTab || 'opening';
      const pendingTasks = getTabTasks(mainTab, 'pending');
      
      if (pendingTasks.length === 0) {
        pendingListContainer.innerHTML = '<div style="padding:20px;text-align:center;color:#6b7280;font-size:14px;">Pending (coming soon)</div>';
      } else {
        // Show newest first (reverse array)
        const pendingReversed = [...pendingTasks].reverse();
        
        pendingListContainer.innerHTML = pendingReversed.map((task, displayIndex) => {
          // Check for instructions in any of the possible fields
          const instructions = task.instructions || task.info || task.details || '';
          const hasInstructions = instructions.trim().length > 0;
          
          // Use consistent keyId: taskId || id (catalog may use either)
          const keyId = task.taskId || task.id;
          
          // Render info button only if instructions exist
          let infoButtonHtml = '';
          if (hasInstructions) {
            const escapedInstructions = escapeHtmlAttr(instructions);
            const taskIdAttr = keyId ? ` data-task-id="${escapeHtmlAttr(keyId)}"` : '';
            infoButtonHtml = `<button type="button" class="tasks-info-icon" data-instructions="${escapedInstructions}"${taskIdAttr} style="background:#7b3fe4;border:none;color:#fff;cursor:pointer;font-size:12px;font-weight:700;padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;margin-left:12px;border-radius:50%;flex-shrink:0;line-height:1;" title="View instructions">i</button>`;
          }
          
          const taskIdAttr = keyId ? ` data-task-id="${escapeHtmlAttr(keyId)}"` : '';
          const assignedToHtml = task.assignedTo ? `<div class="task-worker">Taken by: ${escapeHtmlDraft(task.assignedTo)}</div>` : '';
          return `
            <div class="tasks-main-list-item"${taskIdAttr} style="display:flex;align-items:flex-start;justify-content:space-between;padding:12px;margin-bottom:8px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;">
              <div style="flex:1;">
                <div style="font-weight:600;font-size:14px;color:#111;margin-bottom:4px;">${escapeHtmlDraft(task.title)}</div>
                ${assignedToHtml}
              </div>
              <div style="display:flex;align-items:center;gap:8px;">
                ${infoButtonHtml}
                <button type="button" class="task-done-btn" data-task-id="${keyId || ''}">MARK DONE</button>
              </div>
            </div>
          `;
        }).join('');
        
        // Attach click handlers for info icons in pending list
        pendingListContainer.querySelectorAll('.tasks-info-icon').forEach(btn => {
          // Info icon handler is already set up via delegated handler, but ensure it works
        });
        
        // Rebind MARK DONE buttons after rendering tasks
        document.querySelectorAll(".task-done-btn").forEach(btn => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const taskId = btn.getAttribute("data-task-id");
            if (window.openPinModalForDone) {
              window.openPinModalForDone(taskId);
            } else {
              console.error("openPinModalForDone not found on window");
            }
          });
        });
      }
    }
  } catch (e) {
    console.error('[Tasks] Error rendering tasks list:', e);
  }
}

// Legacy function name for backward compatibility (calls shared render)
function renderTasksDraftList() {
  renderTasksList(window.currentTasksTab);
}

// Delegated click handler for tasks info icons (attach once on document, capture phase)
function setupTasksInfoIconHandler() {
  if (document.__tasksInfoHandlerAttached) return;
  
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('.tasks-info-icon');
    if (!btn) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Read instructions text from attribute
    const text = btn.getAttribute('data-instructions') || '';
    if (!text.trim()) return;
    
    // Open modal showing the instructions text
    openTaskInfoModal(text);
  }, true); // Use capture phase
  
  document.__tasksInfoHandlerAttached = true;
}

// Task Info Modal Functions
function openTaskInfoModal(text) {
  try {
    // Get or create modal root (ensure it's appended to body)
    let modalRoot = document.getElementById('taskInfoModalRoot');
    if (!modalRoot) {
      modalRoot = document.createElement('div');
      modalRoot.id = 'taskInfoModalRoot';
      document.body.appendChild(modalRoot);
    } else if (modalRoot.parentElement !== document.body) {
      // If it exists but is in wrong location, move it to body
      document.body.appendChild(modalRoot);
    }
    
    // Render modal overlay and dialog
    modalRoot.innerHTML = `
      <div class="task-info-overlay">
        <div class="task-info-dialog" onclick="event.stopPropagation()">
          <div class="task-info-header">
            <h3 class="task-info-title">Instructions</h3>
            <button class="task-info-close-x" aria-label="Close">Ã—</button>
          </div>
          <div class="task-info-body"></div>
          <div class="task-info-footer">
            <button class="task-info-close-btn">Close</button>
          </div>
        </div>
      </div>
    `;
    
    // Set instructions text (preserve line breaks)
    const bodyEl = modalRoot.querySelector('.task-info-body');
    if (bodyEl) {
      bodyEl.textContent = text || '';
    }
    
    // Setup close handlers
    const overlay = modalRoot.querySelector('.task-info-overlay');
    const closeX = modalRoot.querySelector('.task-info-close-x');
    const closeBtn = modalRoot.querySelector('.task-info-close-btn');
    const dialog = modalRoot.querySelector('.task-info-dialog');
    
    // Overlay click closes modal
    if (overlay) {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeTaskInfoModal();
        }
      });
    }
    
    // X button closes
    if (closeX) {
      closeX.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeTaskInfoModal();
      });
    }
    
    // Close button closes
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeTaskInfoModal();
      });
    }
    
    // Dialog click stops propagation (prevents closing)
    if (dialog) {
      dialog.addEventListener('click', (e) => {
        e.stopPropagation();
      });
    }
    
    // Disable body scrolling
    document.body.style.overflow = 'hidden';
    
    // Add ESC key listener
    document.addEventListener('keydown', handleTaskInfoEsc);
  } catch (e) {
    // Silent error handling
  }
}

function closeTaskInfoModal() {
  try {
    const modalRoot = document.getElementById('taskInfoModalRoot');
    if (!modalRoot) return;
    
    // Clear modal content
    modalRoot.innerHTML = '';
    
    // Re-enable body scrolling
    document.body.style.overflow = '';
    
    // Remove ESC key listener
    document.removeEventListener('keydown', handleTaskInfoEsc);
  } catch (e) {
    // Silent error handling
  }
}

function handleTaskInfoEsc(e) {
  if (e.key === 'Escape') {
    closeTaskInfoModal();
  }
}

function escapeHtmlDraft(text) {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Escape text for HTML attribute values (handles quotes and special chars)
function escapeHtmlAttr(text) {
  if (!text) return '';
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function addTaskToDraft() {
  try {
    const modal = tasksSettingsModalContainer;
    if (!modal) {
      console.error('[Tasks] Modal container not found');
      return;
    }
    
    const nameEl = modal.querySelector('#taskNameInput, input[name="taskName"], input[placeholder*="Turn on"]');
    const infoEl = modal.querySelector('#taskInfoInput, textarea[name="taskInfo"], textarea, input[name="taskInfo"]');
    const errorEl = modal.querySelector('#taskNameError');
    const name = (nameEl?.value || '').trim();
    const info = (infoEl?.value || '').trim();
    
    // Clear previous error
    if (errorEl) {
      errorEl.style.display = 'none';
      errorEl.textContent = '';
    }
    
    // Validation
    if (!name) {
      if (errorEl) {
        errorEl.textContent = 'Task Name is required';
        errorEl.style.display = 'block';
      }
      nameEl?.focus();
      return;
    }
    
    const tab = getCurrentTasksTab();
    if (!tasksModalDraft[tab]) {
      tasksModalDraft[tab] = [];
    }
    
    // Generate stable ID
    const id = Date.now().toString(36);
    
    // Add to current tab's array - ALWAYS append to END (preserves catalog order)
    tasksModalDraft[tab].push({
      id,
      taskId: id,
      title: name,
      instructions: info
    });
    
    // Clear form
    if (nameEl) nameEl.value = '';
    if (infoEl) infoEl.value = '';
    
    // Re-render Settings modal list to show new task
    renderSettingsTaskList(tab);
    
    // Re-render main screen list
    renderTasksList(window.currentTasksTab);
    
    console.log('[Tasks] Task added to draft for tab:', tab);
  } catch (e) {
    console.error('[Tasks] Error in addTaskToDraft:', e);
  }
}

function cancelTasksModalForm() {
  try {
    const formWrap = document.getElementById('tasksAddFormWrap');
    const nameEl = document.getElementById('taskNameInput');
    const infoEl = document.getElementById('taskInfoInput');
    const errorEl = document.getElementById('taskNameError');
    const toggleBtn = document.getElementById('tasksModalToggleForm');
    
    // Hide form
    if (formWrap) {
      formWrap.style.display = 'none';
    }
    
    // Clear fields
    if (nameEl) nameEl.value = '';
    if (infoEl) infoEl.value = '';
    
    // Clear error
    if (errorEl) {
      errorEl.style.display = 'none';
      errorEl.textContent = '';
    }
    
    // Reset toggle button text
    if (toggleBtn) {
      toggleBtn.textContent = 'Add Task';
    }
  } catch (e) {
    console.error('[Tasks] Error canceling form:', e);
  }
}

function removeTaskFromDraft(index) {
  try {
    const tab = getCurrentTasksTab();
    const tasks = tasksModalDraft[tab] || [];
    if (index >= 0 && index < tasks.length) {
      // Get task data before removing
      const task = tasks[index];
      const resolvedTaskId = task?.taskId || task?.id;
      const taskTitle = (task?.title || '').trim();
      
      // If removing the task that's being edited, cancel edit mode
      if (resolvedTaskId && editingTaskId === resolvedTaskId) {
        editingTaskId = null;
      }
      
      // Check if current user is ADMIN
      let isAdmin = false;
      try {
        const currentSettings = JSON.parse(localStorage.getItem("ffv24_settings") || "{}");
        const role = currentSettings.role?.toLowerCase();
        if (role === 'admin' || role === 'owner') {
          isAdmin = true;
        } else if (!role) {
          // No role set - default to admin for Settings access (Settings is admin-only)
          isAdmin = true;
        }
      } catch (e) {
        console.warn('[Tasks] Error checking admin role, defaulting to admin:', e);
        isAdmin = true; // Default to admin for Settings access
      }
      
      // Helper function to filter out matching items (normalized taskId ONLY)
      const filterTask = (item) => {
        if (!item || typeof item !== 'object') return true;
        const itemResolvedId = item?.taskId || item?.id;
        // Match by normalized taskId ONLY (catalog is source of truth)
        if (resolvedTaskId && itemResolvedId) {
          return String(itemResolvedId) !== String(resolvedTaskId);
        }
        // If no taskId match, keep the item
        return true;
      };
      
      // 1) Remove from catalog (ff_tasks_catalog_v1[tab]) - always
      let catalogObj = {};
      try {
        const raw = localStorage.getItem("ff_tasks_catalog_v1");
        if (raw) {
          catalogObj = JSON.parse(raw);
        }
      } catch (e) {
        console.warn('[Tasks] Error parsing catalog:', e);
      }
      if (!catalogObj || Object.keys(catalogObj).length === 0) {
        catalogObj = window.ff_tasks_catalog_v1 || {};
      }
      if (catalogObj[tab]) {
        catalogObj[tab] = catalogObj[tab].filter(filterTask);
        localStorage.setItem("ff_tasks_catalog_v1", JSON.stringify(catalogObj));
        // Update window object to keep it in sync
        if (typeof window.ff_tasks_catalog_v1 === 'undefined' || !window.ff_tasks_catalog_v1) {
          window.ff_tasks_catalog_v1 = {};
        }
        window.ff_tasks_catalog_v1[tab] = catalogObj[tab];
      }
      
      // Remove from draft (in-memory catalog)
      tasks.splice(index, 1);
      
      // 2) Remove from all runtime lists (ACTIVE, PENDING, DONE) across ALL tabs
      if (resolvedTaskId) {
        const allTabs = ['opening', 'closing', 'weekly', 'monthly', 'yearly'];
        
        allTabs.forEach(t => {
          // Remove from ACTIVE
          const activeKey = `ff_tasks_${t}_active_v1`;
          const activeTasks = JSON.parse(localStorage.getItem(activeKey) || '[]');
          const activeBefore = activeTasks.length;
          const activeFiltered = activeTasks.filter(item => {
            if (!item || typeof item !== 'object') return true;
            const itemResolvedId = item?.taskId || item?.id;
            return !itemResolvedId || String(itemResolvedId) !== String(resolvedTaskId);
          });
          if (activeFiltered.length !== activeBefore) {
            localStorage.setItem(activeKey, JSON.stringify(activeFiltered));
          }
          
          // Remove from PENDING
          const pendingKey = `ff_tasks_${t}_pending_v1`;
          const pendingTasks = JSON.parse(localStorage.getItem(pendingKey) || '[]');
          const pendingBefore = pendingTasks.length;
          const pendingFiltered = pendingTasks.filter(item => {
            if (!item || typeof item !== 'object') return true;
            const itemResolvedId = item?.taskId || item?.id;
            return !itemResolvedId || String(itemResolvedId) !== String(resolvedTaskId);
          });
          if (pendingFiltered.length !== pendingBefore) {
            localStorage.setItem(pendingKey, JSON.stringify(pendingFiltered));
          }
          
          // Remove from DONE
          const doneKey = `ff_tasks_${t}_done_v1`;
          const doneTasks = JSON.parse(localStorage.getItem(doneKey) || '[]');
          const doneBefore = doneTasks.length;
          const doneFiltered = doneTasks.filter(item => {
            if (!item || typeof item !== 'object') return true;
            const itemResolvedId = item?.taskId || item?.id;
            return !itemResolvedId || String(itemResolvedId) !== String(resolvedTaskId);
          });
          if (doneFiltered.length !== doneBefore) {
            localStorage.setItem(doneKey, JSON.stringify(doneFiltered));
          }
        });
        
        console.log('[Tasks] Task removed from catalog and all active/pending/done lists across all tabs');
      }
      
      // 3) Refresh UI immediately
      if (typeof window.loadTasks === 'function') {
        window.loadTasks();
      }
      renderSettingsTaskList(tab);
      if (window.renderTasksList) {
        if (window.renderTasksList.length > 1) {
          window.renderTasksList(tab, { force: true });
        } else {
          window.renderTasksList(tab);
        }
      }
      console.log('[Tasks] Task removed from draft');
    }
  } catch (e) {
    console.error('[Tasks] Error removing task from draft:', e);
  }
}

// Remove task by taskId (handles both catalog tasks and orphan tasks)
function removeTaskFromDraftByTaskId(taskId, isOrphan, settingsTab) {
  try {
    // Use Settings tab if provided (when called from Settings modal), otherwise use current tab
    const tab = settingsTab || getCurrentTasksTab();
    
    if (!taskId) {
      console.warn('[Tasks] Cannot remove task: taskId is missing');
      return;
    }
    
    // If removing the task that's being edited, cancel edit mode
    if (editingTaskId === taskId) {
      editingTaskId = null;
    }
    
    // Normalized ID (exact pattern as specified)
    const rid = String(taskId || "").trim();
    const getId = (t) => String(t?.taskId || t?.id || "").trim();
    if (!rid) {
      console.warn('[Tasks] Cannot remove task: taskId is missing or empty');
      return;
    }
    
    // Collect ALL ID variants from the task being deleted (for tombstone)
    // Try to find the actual task object from multiple sources to get all ID variants
    let taskObj = null;
    
    // First, try to find in ACTIVE list (most complete data)
    try {
      const activeKey = `ff_tasks_${tab}_active_v1`;
      const activeTasks = JSON.parse(localStorage.getItem(activeKey) || '[]');
      taskObj = activeTasks.find(task => {
        const itemResolvedId = task?.taskId || task?.id;
        return itemResolvedId && String(itemResolvedId).trim() === rid;
      });
    } catch (e) {
      console.warn('[Tasks] Error loading from active list:', e);
    }
    
    // If not found, try draft (catalog tasks in Settings)
    if (!taskObj) {
      const tasks = tasksModalDraft[tab] || [];
      taskObj = tasks.find(task => {
        const itemResolvedId = task?.taskId || task?.id;
        return itemResolvedId && String(itemResolvedId).trim() === rid;
      });
    }
    
    // If still not found, try catalog storage
    if (!taskObj) {
      try {
        const catalogObj = JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
        const catalogList = catalogObj[tab] || [];
        taskObj = catalogList.find(task => {
          const itemResolvedId = task?.taskId || task?.id;
          return itemResolvedId && String(itemResolvedId).trim() === rid;
        });
      } catch (e) {
        console.warn('[Tasks] Error loading from catalog:', e);
      }
    }
    
    // Build idVariants Set from task.id, task.taskId, and taskId parameter
    const idVariants = new Set(
      [taskObj?.id, taskObj?.taskId, taskId].filter(Boolean).map(v => String(v).trim())
    );
    
    if (idVariants.size === 0) {
      console.warn('[Tasks] No ID variants found for deletion');
      return;
    }
    
    console.log('[Tasks] DELETE - ID variants:', Array.from(idVariants));
    
    // Helper function to filter out items matching ANY idVariants
    const filterByVariants = (item) => {
      if (!item || typeof item !== 'object') return true;
      const itemId = String(item.id || "").trim();
      const itemTaskId = String(item.taskId || "").trim();
      // Remove if EITHER id OR taskId matches ANY variant
      return !idVariants.has(itemId) && !idVariants.has(itemTaskId);
    };
    
    // 1) Remove from catalog (ff_tasks_catalog_v1[tab]) using variant matching
    let catalogObj = {};
    try {
      const raw = localStorage.getItem("ff_tasks_catalog_v1");
      if (raw) {
        catalogObj = JSON.parse(raw);
      }
    } catch (e) {
      console.warn('[Tasks] Error parsing catalog:', e);
    }
    if (!catalogObj || Object.keys(catalogObj).length === 0) {
      catalogObj = window.ff_tasks_catalog_v1 || {};
    }
    if (catalogObj[tab]) {
      catalogObj[tab] = catalogObj[tab].filter(filterByVariants);
      localStorage.setItem("ff_tasks_catalog_v1", JSON.stringify(catalogObj));
      // Update window object to keep it in sync
      if (typeof window.ff_tasks_catalog_v1 === 'undefined' || !window.ff_tasks_catalog_v1) {
        window.ff_tasks_catalog_v1 = {};
      }
      window.ff_tasks_catalog_v1[tab] = catalogObj[tab];
    }
    
    // Remove from draft (in-memory catalog)
    const tasks = tasksModalDraft[tab] || [];
    tasksModalDraft[tab] = tasks.filter(filterByVariants);
    
    // 2) Remove from ALL three lists for the SAME tab using direct localStorage writes
    const keys = [
      `ff_tasks_${tab}_active_v1`,
      `ff_tasks_${tab}_pending_v1`,
      `ff_tasks_${tab}_done_v1`,
    ];
    
    keys.forEach(key => {
      try {
        const arr = JSON.parse(localStorage.getItem(key) || "[]");
        const filtered = arr.filter(filterByVariants);
        if (filtered.length !== arr.length) {
          localStorage.setItem(key, JSON.stringify(filtered));
          console.log(`[Tasks] Removed from ${key}: ${arr.length} -> ${filtered.length}`);
        }
      } catch (e) {
        console.warn(`[Tasks] Error processing ${key}:`, e);
      }
    });
    
    // 3) Add ALL idVariants to tombstone (prevent re-seeding)
    try {
      const tombstoneKey = "ff_tasks_active_deleted_v1";
      let tombstone = {};
      try {
        const tombstoneRaw = localStorage.getItem(tombstoneKey);
        if (tombstoneRaw) {
          tombstone = JSON.parse(tombstoneRaw);
        }
      } catch (e) {
        console.warn('[Tasks] Error parsing tombstone:', e);
      }
      
      if (!tombstone || typeof tombstone !== 'object') {
        tombstone = { opening: [], closing: [], weekly: [], monthly: [], yearly: [] };
      }
      
      // Ensure tab array exists
      if (!Array.isArray(tombstone[tab])) {
        tombstone[tab] = [];
      }
      
      // Add ALL idVariants to tombstone (avoid duplicates)
      const existingIds = new Set(tombstone[tab].map(id => String(id).trim()));
      idVariants.forEach(id => {
        if (!existingIds.has(id)) {
          tombstone[tab].push(id);
          existingIds.add(id);
        }
      });
      
      localStorage.setItem(tombstoneKey, JSON.stringify(tombstone));
      console.log(`[Tasks] Added ID variants to tombstone for tab ${tab}:`, Array.from(idVariants));
    } catch (e) {
      console.warn('[Tasks] Error updating tombstone:', e);
    }
    
    console.log(`[Tasks] Task ${rid} removed from catalog and runtime lists for tab: ${tab}`);
    
    // 3) Refresh UI immediately
    if (typeof window.loadTasks === 'function') {
      window.loadTasks();
    }
    renderSettingsTaskList(tab);
    if (window.renderTasksList) {
      if (window.renderTasksList.length > 1) {
        window.renderTasksList(tab, { force: true });
      } else {
        window.renderTasksList(tab);
      }
    }
    console.log('[Tasks] Task removed by taskId:', taskId, 'isOrphan:', isOrphan);
  } catch (e) {
    console.error('[Tasks] Error removing task by taskId:', e);
  }
}

function startEditTask(taskId) {
  try {
    // Set editing state
    editingTaskId = taskId;
    
    // Re-render to show edit mode
    const tab = getCurrentTasksTab();
    renderSettingsTaskList(tab);
    
    // Focus on title input after a short delay to ensure DOM is updated
    setTimeout(() => {
      const titleInput = document.querySelector(`.tasks-edit-title[data-task-id="${taskId}"]`);
      if (titleInput) {
        titleInput.focus();
        titleInput.select();
      }
    }, 50);
    
    console.log('[Tasks] Started editing task:', taskId);
  } catch (e) {
    console.error('[Tasks] Error starting edit:', e);
  }
}

function saveEditTask(taskId) {
  try {
    const tab = getCurrentTasksTab();
    const tasks = tasksModalDraft[tab] || [];
    
    // Find the task being edited
    const taskIndex = tasks.findIndex(t => (t.taskId || t.id) === taskId);
    if (taskIndex === -1) {
      console.warn('[Tasks] Task not found for editing:', taskId);
      return;
    }
    
    // Get input values
    const titleInput = document.querySelector(`.tasks-edit-title[data-task-id="${taskId}"]`);
    const instructionsInput = document.querySelector(`.tasks-edit-instructions[data-task-id="${taskId}"]`);
    
    if (!titleInput) {
      console.warn('[Tasks] Title input not found');
      return;
    }
    
    const newTitle = (titleInput.value || '').trim();
    const newInstructions = (instructionsInput?.value || '').trim();
    
    // Validation
    if (!newTitle) {
      alert('Task title is required');
      titleInput.focus();
      return;
    }
    
    // Update task in draft
    const task = tasks[taskIndex];
    task.title = newTitle;
    task.instructions = newInstructions;
    
    // Clear editing state
    editingTaskId = null;
    
    // Re-render to show updated task
    renderSettingsTaskList(tab);
    
    console.log('[Tasks] Task saved in draft:', taskId);
  } catch (e) {
    console.error('[Tasks] Error saving edit:', e);
  }
}

function cancelEditTask() {
  try {
    // Clear editing state
    editingTaskId = null;
    
    // Re-render to show view mode
    const tab = getCurrentTasksTab();
    renderSettingsTaskList(tab);
    
    console.log('[Tasks] Edit cancelled');
  } catch (e) {
    console.error('[Tasks] Error cancelling edit:', e);
  }
}

function toggleTasksModalForm() {
  try {
    const formWrap = document.getElementById('tasksAddFormWrap');
    if (!formWrap) return;
    
    const isVisible = formWrap.style.display !== 'none';
    
    if (isVisible) {
      // Hide form and clear fields
      cancelTasksModalForm();
    } else {
      // Cancel any active edit when showing add form
      if (editingTaskId) {
        cancelEditTask();
      }
      // Show form
      formWrap.style.display = 'block';
      const toggleBtn = document.getElementById('tasksModalToggleForm');
      if (toggleBtn) {
        toggleBtn.textContent = 'Cancel';
      }
      // Focus on task name input
      const nameEl = document.getElementById('taskNameInput');
      if (nameEl) {
        setTimeout(() => nameEl.focus(), 100);
      }
    }
  } catch (e) {
    console.error('[Tasks] Error toggling form:', e);
  }
}

function saveTasksModal() {
  try {
    if (saveTasksToStorage()) {
      // Store the tab that was saved (Settings tab, which should match main Tasks tab)
      const savedTab = getCurrentTasksTab();
      
      // Close Settings modal FIRST so renderTasksList can render MY LIST
      // (renderTasksList checks !isTasksSettingsOpen before rendering MY LIST)
      closeTasksSettings();
      
      // Reload tasks from storage to ensure consistency
      loadTasks();
      
      // Clear any caches for the saved tab to force fresh render
      if (typeof window.tasksCache !== 'undefined' && window.tasksCache && window.tasksCache[savedTab]) {
        delete window.tasksCache[savedTab];
      }
      if (typeof window.myListCache !== 'undefined' && window.myListCache && window.myListCache[savedTab]) {
        delete window.myListCache[savedTab];
      }
      
      // Ensure legacy â†’ v1 migration has run before rendering
      if (typeof migrateLegacyActiveToV1 === 'function') {
        migrateLegacyActiveToV1(savedTab);
      }
      
      // Refresh MY LIST for the saved tab immediately
      if (typeof window.renderTasksList === 'function') {
        window.renderTasksList(savedTab, { force: true });
      }
      
      // Dispatch event as backup notification (listener will also refresh)
      window.dispatchEvent(new CustomEvent('tasks:updated'));
      
      console.log('[Tasks] Tasks saved to localStorage and MY LIST refreshed for tab:', savedTab);
    } else {
      alert('Failed to save tasks. Please try again.');
    }
  } catch (e) {
    console.error('[Tasks] Error saving tasks:', e);
    alert('Error saving tasks. Please try again.');
  }
}

function openTasksSettings() {
  try {
    if (isTasksSettingsOpen) return;
    
    const modal = document.getElementById('tasksSettingsModal');
    if (!modal) {
      console.error('[Tasks] Settings modal not found');
      return;
    }
    
    // Store reference to modal container element
    tasksSettingsModalContainer = modal.querySelector('.tasks-modal-container');
    if (!tasksSettingsModalContainer) {
      console.error('[Tasks] Modal container not found');
      return;
    }
    
    // Initialize Settings modal tab (default to 'opening' or use current main screen tab)
    // Get main screen tab (not using getCurrentTasksTab() since modal isn't open yet)
    const mainScreenTab = window.currentTasksTab || 'opening';
    
    // Set up event listeners for Settings modal tabs first
    const settingsTabs = document.querySelectorAll('.tasks-settings-tab');
    settingsTabs.forEach(tab => {
      // Remove existing listeners by cloning
      const newTab = tab.cloneNode(true);
      tab.parentNode.replaceChild(newTab, tab);
      
      // Add click listener
      newTab.addEventListener('click', () => {
        const tabName = newTab.dataset.tab;
        setSettingsModalTab(tabName);
      });
    });
    
    // Now set up the tab bar visual state (after listeners are set up)
    setSettingsModalTab(mainScreenTab);
    
    // Load tasks for current Settings tab
    loadTasksForSettingsTab(mainScreenTab);
    
    // Hide form initially
    const formWrap = document.getElementById('tasksAddFormWrap');
    if (formWrap) {
      formWrap.style.display = 'none';
    }
    const toggleBtn = document.getElementById('tasksModalToggleForm');
    if (toggleBtn) {
      toggleBtn.textContent = 'Add Task';
    }
    
    // Clear editing state when opening modal
    editingTaskId = null;
    
    modal.style.display = 'flex';
    isTasksSettingsOpen = true;
    
    // Disable body scrolling
    document.body.style.overflow = 'hidden';
    
    // Add ESC key listener
    document.addEventListener('keydown', handleTasksSettingsEsc);
    
    // Render Settings modal list from catalog
    renderSettingsTaskList(mainScreenTab);
    
    console.log('[Tasks] Settings modal opened for tab:', mainScreenTab);
  } catch (e) {
    console.error('[Tasks] Error opening settings modal:', e);
  }
}

function closeTasksSettings() {
  try {
    if (!isTasksSettingsOpen) return;
    
    const modal = document.getElementById('tasksSettingsModal');
    if (modal) {
      modal.style.display = 'none';
    }
    
    isTasksSettingsOpen = false;
    
    // Re-enable body scrolling
    document.body.style.overflow = '';
    
    // Remove ESC key listener
    document.removeEventListener('keydown', handleTasksSettingsEsc);
    
    // Clear form and hide it
    cancelTasksModalForm();
    
    // Clear editing state
    editingTaskId = null;
    
    console.log('[Tasks] Settings modal closed');
  } catch (e) {
    console.error('[Tasks] Error closing settings modal:', e);
  }
}

function handleTasksSettingsEsc(e) {
  if (e.key === 'Escape' && isTasksSettingsOpen) {
    closeTasksSettings();
  }
}

// Listen for tasks:updated event to refresh TASKS screen
window.addEventListener('tasks:updated', () => {
  try {
    // Reload tasks from storage
    loadTasks();
    // Re-render current tab's tasks
    renderTasksList(window.currentTasksTab);
    console.log('[Tasks] Tasks updated via event');
  } catch (e) {
    console.error('[Tasks] Error handling tasks:updated event:', e);
  }
});

// Expose functions to window
window.openTasks = openTasks;
window.closeTasks = closeTasks;
window.setTasksTab = setTasksTab;
window.getCurrentTasksTab = getCurrentTasksTab;
window.openTasksSettings = openTasksSettings;
window.closeTasksSettings = closeTasksSettings;
window.addTaskToDraft = addTaskToDraft;
window.renderTasksList = renderTasksList;
window.renderTasksDraftList = renderTasksDraftList; // Legacy alias
window.toggleTasksModalForm = toggleTasksModalForm;
window.cancelTasksModalForm = cancelTasksModalForm;
window.saveTasksModal = saveTasksModal;
window.openTaskInfoModal = openTaskInfoModal;
window.closeTaskInfoModal = closeTaskInfoModal;
window.loadTasks = loadTasks;

// Tasks Reset Functions
function showResetBtnIfAllowed() {
  try {
    // Read settings from localStorage
    const settings = JSON.parse(localStorage.getItem("ffv24_settings") || "{}");
    
    // Get role: first from current user's worker entry, then from settings.role
    let role = settings.workers?.find(w => w.name === settings.currentUser)?.role?.toLowerCase() 
             || settings.role?.toLowerCase() 
             || "";
    
    // If role is missing, set default to admin and save back to localStorage
    if (!role) {
      settings.role = "admin";
      localStorage.setItem("ffv24_settings", JSON.stringify(settings));
      role = "admin";
    }
    
    // Show button only if role is admin or manager
    const isAuthorized = role === "admin" || role === "manager";
    
    const resetBtn = document.getElementById('tasksResetBtn');
    if (resetBtn) {
      resetBtn.style.display = isAuthorized ? 'block' : 'none';
    }
    
    return isAuthorized;
  } catch (e) {
    console.error('[Tasks] Error checking user role:', e);
    return false;
  }
}

// Validate reset PIN against admin code, manager code, or worker PIN
function validateResetPin(pin, settings, currentUser) {
    pin = String(pin).trim();

    // 1. Admin code
    if (settings.adminCode && pin === String(settings.adminCode)) {
        return true;
    }

    // 2. Managers list (code)
    if (Array.isArray(settings.managers)) {
        const manager = settings.managers.find(m => m.name?.toLowerCase() === currentUser?.toLowerCase());
        if (manager && String(manager.code) === pin) {
            return true;
        }
    }

    // 3. Workers list (pin)
    if (Array.isArray(settings.workers)) {
        const worker = settings.workers.find(w => w.name?.toLowerCase() === currentUser?.toLowerCase());
        if (worker && String(worker.pin) === pin) {
            return true;
        }
    }

    return false;
}

window.validateResetPin = validateResetPin;

// Open PIN modal for RESET verification
function openResetPinModal(callback) {
  const modal = document.getElementById("resetPinModal");
  const pinInput = document.getElementById("resetPinInput");
  const errorMsg = document.getElementById("resetPinError");
  
  if (!modal || !pinInput) {
    console.error("PIN modal elements missing");
    return;
  }
  
  // Clear previous input and error
  pinInput.value = "";
  errorMsg.textContent = "";
  
  // Store callback for later use
  modal._resetCallback = callback;
  
  // Show modal and focus input
  modal.style.display = "flex";
  setTimeout(() => pinInput.focus(), 100);
}

// Close PIN modal
function closeResetPinModal() {
  const modal = document.getElementById("resetPinModal");
  if (modal) {
    modal.style.display = "none";
    const pinInput = document.getElementById("resetPinInput");
    const errorMsg = document.getElementById("resetPinError");
    if (pinInput) pinInput.value = "";
    if (errorMsg) errorMsg.textContent = "";
    delete modal._resetCallback;
  }
}

// Validate PIN and execute reset
async function validateResetPinAndExecute() {
  const modal = document.getElementById("resetPinModal");
  const pinInput = document.getElementById("resetPinInput");
  const errorMsg = document.getElementById("resetPinError");
  
  if (!modal || !pinInput) return;
  
  const pin = pinInput.value.trim();
  
  if (!pin) {
    errorMsg.textContent = "PIN is required.";
    return;
  }
  
  // Clear previous error
  errorMsg.textContent = "";
  
  // Validate PIN using the helper from app.js
  if (typeof window.validateResetPin === "function") {
    try {
      const isValid = await window.validateResetPin(pin);
      if (!isValid) {
        errorMsg.textContent = "Invalid Admin PIN. Reset cancelled.";
        pinInput.value = "";
        setTimeout(() => pinInput.focus(), 100);
        return;
      }
    } catch (e) {
      console.error("[RESET] Error validating PIN:", e);
      errorMsg.textContent = "Invalid Admin PIN. Reset cancelled.";
      pinInput.value = "";
      setTimeout(() => pinInput.focus(), 100);
      return;
    }
  } else {
    errorMsg.textContent = "PIN validation function not available.";
    return;
  }
  
  // PIN is valid - close modal and perform reset
  console.log("[RESET] PIN accepted");
  closeResetPinModal();
  
  // Call doResetCurrentTab to perform the actual reset
  if (typeof window.doResetCurrentTab === "function") {
    window.doResetCurrentTab();
  } else {
    console.error("[RESET] doResetCurrentTab function not found!");
    alert("Reset function not available.");
  }
}

window.openResetPinModal = openResetPinModal;
window.closeResetPinModal = closeResetPinModal;

window.openResetTasksModal = function () {
  const modal = document.getElementById("tasksResetConfirmModal");
  if (!modal) { console.error("RESET modal missing"); return; }

  const tab = window.getCurrentTasksTab();
  const tabNameElement = document.getElementById("tasksResetTabName");
  if (tabNameElement) {
    tabNameElement.innerText = tab.charAt(0).toUpperCase() + tab.slice(1);
  }
  
  modal.style.display = "flex";
};

window.closeResetTasksModal = function () {
  const modal = document.getElementById("tasksResetConfirmModal");
  if (modal) modal.style.display = "none";
};

// Alias for backward compatibility
function closeTasksResetConfirmModal() {
  return window.closeResetTasksModal();
}

// Reload tasks for a specific tab from catalog
function reloadTasksForTab(tab) {
  // Use global catalog if available, otherwise load from localStorage
  const catalog = window.ff_tasks_catalog_v1 || JSON.parse(localStorage.getItem("ff_tasks_catalog_v1") || "{}");
  const fresh = catalog[tab] || [];

  // Save new active list
  localStorage.setItem(`ffv24_tasks_${tab}_active`, JSON.stringify(fresh));
}

function resetTasksForCurrentTab() {
    const tab = window.currentTasksTab;
    console.log("[RESET] Running for tab:", tab);
    console.log("[RESET] Start:", window.currentTasksTab);

    if (!tab) {
        console.error("[RESET] ERROR: currentTasksTab is undefined");
        return;
    }

    const keyActive = `ffv24_tasks_${tab}_active`;
    const keyPending = `ffv24_tasks_${tab}_pending`;
    const keyDone = `ffv24_tasks_${tab}_done`;

    console.log("[RESET] Clearing storage keys:", keyActive, keyPending, keyDone);

    // Clear all three lists
    localStorage.removeItem(keyActive);
    localStorage.removeItem(keyPending);
    localStorage.removeItem(keyDone);

    // Reload catalog data for this tab
    const catalog = window.ff_tasks_catalog_v1?.[tab] || [];
    console.log("[RESET] Catalog data for tab:", tab, "items:", catalog.length);
    
    writeTasksList(tab, 'active', catalog);
    writeTasksList(tab, 'pending', []);
    writeTasksList(tab, 'done', []);

    console.log("[RESET] Storage cleared and reinitialized");

    // Re-render UI for this tab
    console.log("[RESET] Re-rendering tasks list for tab:", window.currentTasksTab);
    renderTasksList(window.currentTasksTab);
    
    console.log("[RESET] Completed");
}

window.resetTasksForCurrentTab = resetTasksForCurrentTab;

// Safe initialization function for RESET button
// Module-level flag to ensure one-time initialization
let __resetInitDone = false;

function initializeResetButton() {
  // Guard: run only once
  if (__resetInitDone) {
    return;
  }

  const resetBtn = document.getElementById("tasksResetBtn") || document.getElementById("reset-btn");
  const modal = document.getElementById("tasksResetConfirmModal");

  // RESET button opens confirmation modal - use addEventListener for one-time binding
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      console.log("RESET CLICKED");
      if (window.resetTasksForCurrentTab) {
        window.resetTasksForCurrentTab();
      }
    });
  }

  // Modal event delegation MUST be set up even if button is missing
  if (!modal) {
    console.warn("RESET confirmation modal missing â€” event delegation skipped");
    return;
  }

  // EVENT DELEGATION: Attach ONE click handler to modal root container
  // This works even if modal HTML is re-rendered/replaced
  modal.addEventListener("click", (e) => {
    const t = e.target;
    const modalContent = document.getElementById("tasksResetConfirmModalContent");
    
    // If click is inside modal-content, stop propagation (don't close on content clicks)
    if (modalContent && modalContent.contains(t) && t !== modal) {
      e.stopPropagation();
    }
    
    // Handle Cancel button click
    if (t.id === "resetConfirmCancel" || t.closest("#resetConfirmCancel")) {
      e.preventDefault();
      e.stopPropagation();
      console.log("[RESET] Cancel clicked");
      modal.style.display = "none";
      return;
    }
    
    // Handle Yes button click
    if (t.id === "resetConfirmYes" || t.closest("#resetConfirmYes")) {
      e.preventDefault();
      e.stopPropagation();
      
      const tab = window.currentTasksTab;
      console.log("[RESET] Confirm YES clicked, tab=", tab);
      
      // Close confirmation modal
      modal.style.display = "none";
      
      // Open PIN modal using the existing function
      if (typeof window.openResetPinModal === "function") {
        window.openResetPinModal();
      } else {
        // Fallback: direct modal opening
        const pinModal = document.getElementById("resetPinModal");
        const pinInput = document.getElementById("resetPinInput");
        const errorMsg = document.getElementById("resetPinError");
        
        if (pinModal) {
          // Clear previous input and error
          if (pinInput) {
            pinInput.value = "";
          }
          if (errorMsg) {
            errorMsg.textContent = "";
          }
          // Show PIN modal
          pinModal.style.display = "flex";
          // Focus input after a short delay
          if (pinInput) {
            setTimeout(() => pinInput.focus(), 100);
          }
        }
      }
      return;
    }
    
    // If click is on backdrop (modal itself, not content), close modal
    if (t === modal) {
      e.preventDefault();
      modal.style.display = "none";
      return;
    }
  });
  
  // PIN modal buttons
  const resetPinOk = document.getElementById("resetPinOk");
  const resetPinCancel = document.getElementById("resetPinCancel");
  
  if (resetPinOk) {
    resetPinOk.addEventListener("click", () => {
      validateResetPinAndExecute();
    });
  }
  
  if (resetPinCancel) {
    resetPinCancel.addEventListener("click", () => {
      const pinModal = document.getElementById("resetPinModal");
      if (pinModal) {
        pinModal.style.display = "none";
        const pinInput = document.getElementById("resetPinInput");
        const errorMsg = document.getElementById("resetPinError");
        if (pinInput) pinInput.value = "";
        if (errorMsg) errorMsg.textContent = "";
      }
    });
  }
  
  // Allow Enter key to submit PIN
  const resetPinInput = document.getElementById("resetPinInput");
  if (resetPinInput) {
    resetPinInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        validateResetPinAndExecute();
      }
    });
  }

  // Mark as initialized - prevent re-running
  __resetInitDone = true;
  console.log("[RESET] Button initialization complete");
}

// Initialize Tasks screen buttons (including reset button)
function initializeTasksScreenButtons() {
  try {
    // Back button
    const backBtn = document.getElementById('btnTasksBack');
    if (backBtn) {
      backBtn.onclick = closeTasks;
    }
    
    // Settings button
    const settingsBtn = document.getElementById('btnTasksSettings');
    if (settingsBtn) {
      settingsBtn.onclick = openTasksSettings;
    }
    
    // Check role and show/hide reset button
    showResetBtnIfAllowed();
    
    console.log('[Tasks] Screen buttons initialized');
  } catch (e) {
    console.error('[Tasks] Error initializing screen buttons:', e);
  }
}

// Expose functions
window.initializeTasksScreenButtons = initializeTasksScreenButtons;
window.showResetBtnIfAllowed = showResetBtnIfAllowed;
window.initializeResetButton = initializeResetButton;
// openResetTasksModal, resetTasksForCurrentTab, and closeResetTasksModal are already defined as window.* functions above

// Initialize navigation on page load
function initializeNavigation() {
  try {
  console.log('[Navigation] Initializing navigation handlers');
  
    // Ensure tasksScreen is hidden on load (Tasks feature removed - safe no-op)
  ensureTasksScreenHidden();
  
  // Ensure header buttons are all properly set up
  const header = document.querySelector('.header');
  if (header) {
    header.style.zIndex = '201';
    header.style.pointerEvents = 'auto';
    
    const headerButtons = header.querySelectorAll('button');
      if (headerButtons) {
    headerButtons.forEach(btn => {
          if (btn) {
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.zIndex = '202';
      btn.style.position = 'relative';
      console.log('[Navigation] Initialized button:', btn.id || btn.textContent);
          }
        });
      }
    } else {
      console.warn('[Navigation] Missing element: .header');
    }
  } catch (e) {
    console.error('[Navigation] initializeNavigation failed', e);
  }
}

// Run initialization when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeNavigation);
} else {
  initializeNavigation();
}

// Wrap navigation handlers to ensure tasksScreen is hidden
// Use window properties to avoid TDZ issues - functions are hoisted but consts are not
if (!window.__originalOpenLog) {
  window.__originalOpenLog = openLog;
}
if (!window.__originalOpenSettingsSecure) {
  window.__originalOpenSettingsSecure = openSettingsSecure;
}
if (!window.__originalResetDay) {
  window.__originalResetDay = resetDay;
}

async function openLogWithNav() {
  try {
  console.log('History clicked');
  ensureTasksScreenHidden();
  return (window.__originalOpenLog || openLog)();
  } catch (e) {
    console.error('[Navigation] Error in openLogWithNav:', e);
  }
}

async function openSettingsSecureWithNav() {
  try {
  console.log('Settings clicked');
  ensureTasksScreenHidden();
  return (window.__originalOpenSettingsSecure || openSettingsSecure)();
  } catch (e) {
    console.error('[Navigation] Error in openSettingsSecureWithNav:', e);
  }
}

async function resetDayWithNav() {
  try {
  console.log('RESET clicked');
  ensureTasksScreenHidden();
  await (window.__originalResetDay || resetDay)();
  } catch (e) {
    console.error('[Navigation] Error in resetDayWithNav:', e);
  }
}

// Safe button initialization function
function initializeNavigationButtons() {
  try {
    // History button
    const logBtnEl = document.getElementById("logBtn") || logBtn;
    if (logBtnEl) {
      logBtnEl.onclick = openLogWithNav;
      logBtnEl.style.cursor = 'pointer';
      logBtnEl.style.pointerEvents = 'auto';
      logBtnEl.disabled = false;
      logBtnEl.removeAttribute('disabled');
      console.log('[Navigation] History button initialized');
    } else {
      console.warn('[Navigation] Missing element: logBtn');
    }

    // Settings button
    const settingsBtnEl = document.getElementById("settingsBtn") || settingsBtn;
    if (settingsBtnEl) {
      settingsBtnEl.onclick = openSettingsSecureWithNav;
      settingsBtnEl.style.cursor = 'pointer';
      settingsBtnEl.style.pointerEvents = 'auto';
      settingsBtnEl.disabled = false;
      settingsBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Settings button initialized');
    } else {
      console.warn('[Navigation] Missing element: settingsBtn');
    }

    // Reset button
    const resetBtnEl = document.getElementById("resetBtn") || resetBtn;
    if (resetBtnEl) {
      resetBtnEl.onclick = resetDayWithNav;
      resetBtnEl.style.cursor = 'pointer';
      resetBtnEl.style.pointerEvents = 'auto';
      resetBtnEl.disabled = false;
      resetBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Reset button initialized');
    } else {
      console.warn('[Navigation] Missing element: resetBtn');
    }

    // Reorder button
    const reorderBtnEl = document.getElementById("reorderBtn") || reorderBtn;
    if (reorderBtnEl) {
      if (typeof window.handleReorderClick === 'function') {
        reorderBtnEl.onclick = window.handleReorderClick;
      } else if (typeof handleReorderClick === 'function') {
        reorderBtnEl.onclick = handleReorderClick;
      }
      reorderBtnEl.style.cursor = 'pointer';
      reorderBtnEl.style.pointerEvents = 'auto';
      reorderBtnEl.disabled = false;
      reorderBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Reorder button initialized');
    } else {
      console.warn('[Navigation] Missing element: reorderBtn');
    }

    // Tasks button
    const tasksBtnEl = document.getElementById("tasksBtn");
    if (tasksBtnEl) {
      tasksBtnEl.onclick = function() {
        if (typeof window.openTasks === 'function') {
          window.openTasks();
        } else {
          console.error('[Navigation] openTasks function not found');
        }
      };
      tasksBtnEl.style.cursor = 'pointer';
      tasksBtnEl.style.pointerEvents = 'auto';
      tasksBtnEl.disabled = false;
      tasksBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Tasks button initialized');
    } else {
      console.warn('[Navigation] Missing element: tasksBtn');
    }
  } catch (e) {
    console.error('[Navigation] Error initializing navigation buttons:', e);
  }
}

// Tasks screen buttons are now initialized in app.js via DOMContentLoaded
// This ensures proper event listener attachment and avoids conflicts

// Initialize buttons when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(initializeNavigationButtons, 100);
  });
} else {
  setTimeout(initializeNavigationButtons, 100);
}

// Expose for re-initialization after login
window.initializeNavigationButtons = initializeNavigationButtons;

// Get currently active staff member name
function getCurrentActiveStaffName() {
  // Check if there's a staff member in service (most recent activity)
  if (service && service.length > 0) {
    return service[0].name;
  }
  // Check if there's a staff member in queue
  if (queue && queue.length > 0) {
    return queue[0].name;
  }
  // Fallback to nameSelect value if set
  const nameSelect = document.getElementById('nameSelect');
  if (nameSelect && nameSelect.value) {
    return nameSelect.value;
  }
  return null;
}

// Tasks feature completely removed - all Tasks-related code has been deleted
// Stub TasksComponent to prevent errors if anything tries to access it
window.TasksComponent = {
  mount: function() { 
    console.warn('[Tasks] Tasks feature removed - mount() is a no-op');
  },
  unmount: function() { 
    console.warn('[Tasks] Tasks feature removed - unmount() is a no-op');
  },
  isMounted: function() { 
    return false; 
  },
  getCurrentCategory: function() { 
    return null; 
  },
  verifyHeaderButtons: function() { 
    return {}; 
  }
};

// Legacy Tasks functions removed - stubs to prevent errors
function showTasksScreen() {
  console.warn('[Tasks] Tasks feature removed - showTasksScreen() is a no-op');
}

function goBackToMainScreen(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.warn('[Tasks] Tasks feature removed - goBackToMainScreen() is a no-op');
}

function initTasksTabs() {
  // No-op - Tasks feature removed
}

function updateTaskNoteDisplay(category) {
  // No-op - Tasks feature removed
}

// Expose stubs globally to prevent errors
window.showTasksScreen = showTasksScreen;
window.goBackToMainScreen = goBackToMainScreen;
window.updateTaskNoteDisplay = updateTaskNoteDisplay;

// Remove all Tasks state and data structures
// Tasks feature removed - no Tasks data to initialize

// All Tasks-related helper functions removed - they referenced undefined variables
// No Tasks code remains in the main application

// Add Technician dialog functions (non-Tasks code starts here)
  /**
   * Track and schedule timeout
   */
  function scheduleTimeout(callback, delay) {
    const timerId = setTimeout(() => {
      callback();
      resources.timers.delete(timerId);
    }, delay);
    resources.timers.add(timerId);
    return timerId;
  }
  
  /**
   * Track and schedule animation frame
   */
  function scheduleAnimationFrame(callback) {
    const rafId = requestAnimationFrame(() => {
      callback();
      resources.animationFrames.delete(rafId);
    });
    resources.animationFrames.add(rafId);
    return rafId;
  }
  
  /**
   * Add tracked event listener
   */
  function addTrackedEventListener(element, event, handler, options) {
    if (!element) return;
    
    element.addEventListener(event, handler, options);
    
    if (!resources.eventListeners.has(element)) {
      resources.eventListeners.set(element, []);
    }
    resources.eventListeners.get(element).push({ event, handler, options });
  }
  
  /**
   * Close all modals that might block clicks
   */
  function closeAllBlockingModals() {
    const modalIds = [
      'tasksAdminAccessModal',
      'tasksResetModal',
      'tasksFinishModal',
      'tasksSelectModal',
      'tasksEditModal',
      'tasksInstructionsModal',
      'codePromptOverlay',
      'log-secure-overlay',
      'historyModal'
    ];
    
    modalIds.forEach(modalId => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = 'none';
        modal.style.pointerEvents = 'none';
        modal.style.visibility = 'hidden';
        modal.style.opacity = '0';
        modal.style.zIndex = '-1';
        if (modal.classList) {
          modal.classList.add('hidden');
        }
      }
    });
    
    // Close any dynamically created overlays with high z-index
    const allOverlays = document.querySelectorAll('[style*="z-index"][style*="position:fixed"]');
    allOverlays.forEach(overlay => {
      const zIndex = parseInt(window.getComputedStyle(overlay).zIndex) || 0;
      const display = window.getComputedStyle(overlay).display;
      if (zIndex >= 1000 && display !== 'none' && overlay.id !== 'tasksScreen') {
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        overlay.style.visibility = 'hidden';
        overlay.style.opacity = '0';
        overlay.style.zIndex = '-1';
      }
    });
  }
  
  /**
   * Apply header styles for Tasks screen (stores originals)
   */
  function applyHeaderStyles() {
    if (!elements.header) return;
    
    storeOriginalStyle(elements.header, ['zIndex', 'pointerEvents', 'position']);
    elements.header.style.zIndex = '400';
    elements.header.style.pointerEvents = 'auto';
    elements.header.style.position = 'sticky';
    
    const headerButtons = elements.header.querySelectorAll('button');
    headerButtons.forEach(btn => {
      storeOriginalStyle(btn, ['zIndex', 'pointerEvents', 'cursor', 'position']);
      btn.style.zIndex = '600';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.position = 'relative';
    });
    
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => {
      storeOriginalStyle(btn, ['zIndex', 'pointerEvents', 'cursor', 'position']);
      btn.style.zIndex = '600';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.position = 'relative';
    });
  }
  
  /**
   * Restore header styles to original values
   */
  function restoreHeaderStyles() {
    if (elements.header) {
      restoreOriginalStyle(elements.header);
      
      const headerButtons = elements.header.querySelectorAll('button');
      headerButtons.forEach(btn => restoreOriginalStyle(btn));
    }
    
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => restoreOriginalStyle(btn));
  }
  
  /**
   * Initialize header buttons (Back, Settings, Reset)
   * Enhanced with comprehensive verification and error handling
   */
  function initializeHeaderButtons() {
    console.log('[Tasks] Initializing header buttons...');
    
    // Helper function to initialize a single button
    function initButton(buttonId, buttonName, handlerFunction) {
      let button = document.getElementById(buttonId);
      
      if (!button) {
        console.error(`[Tasks] ${buttonName} button (${buttonId}) not found in DOM`);
        return false;
      }
      
      console.log(`[Tasks] Found ${buttonName} button, cloning to remove old listeners...`);
      
      // Clone to remove old listeners
      const parent = button.parentNode;
      if (!parent) {
        console.error(`[Tasks] ${buttonName} button has no parent node`);
        return false;
      }
      
      const newBtn = button.cloneNode(true);
      parent.replaceChild(newBtn, button);
      
      // Get fresh reference
      button = document.getElementById(buttonId);
      if (!button) {
        console.error(`[Tasks] ${buttonName} button not found after cloning`);
        return false;
      }
      
      // Create handler with comprehensive logging
      const handler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log(`[Tasks] ${buttonName} button clicked`);
        try {
          handlerFunction(e);
        } catch (error) {
          console.error(`[Tasks] Error in ${buttonName} handler:`, error);
        }
      };
      
      // Attach event listener (tracked for cleanup)
      addTrackedEventListener(button, 'click', handler);
      
      // Also set onclick as fallback (will be overridden by addEventListener, but ensures compatibility)
      button.onclick = handler;
      
      // CRITICAL: Set all interactivity styles explicitly
      button.style.pointerEvents = 'auto';
      button.style.cursor = 'pointer';
      button.style.position = 'relative';
      button.style.zIndex = '501';
      button.style.display = button.style.display || 'flex'; // Preserve display
      
      // Ensure button is not disabled
      button.disabled = false;
      button.removeAttribute('disabled');
      
      // Verify styles were applied
      const computedStyle = window.getComputedStyle(button);
      const pointerEvents = computedStyle.pointerEvents;
      const zIndex = computedStyle.zIndex;
      
      console.log(`[Tasks] ${buttonName} button initialized:`, {
        id: buttonId,
        pointerEvents: pointerEvents,
        zIndex: zIndex,
        cursor: computedStyle.cursor,
        position: computedStyle.position,
        disabled: button.disabled
      });
      
      // Warn if pointer-events is not auto
      if (pointerEvents !== 'auto') {
        console.warn(`[Tasks] WARNING: ${buttonName} button pointer-events is "${pointerEvents}", expected "auto"`);
        // Force it
        button.style.setProperty('pointer-events', 'auto', 'important');
      }
      
      return true;
    }
    
    // Initialize Back button
    const backInitialized = initButton('tasksBackBtn', 'Back', (e) => {
      TasksComponent.unmount();
    });
    
    // Initialize Settings button
    const settingsInitialized = initButton('tasksSettingsBtn', 'Settings', (e) => {
      if (typeof openTasksAdminAccessModal === 'function') {
        openTasksAdminAccessModal(e);
      } else {
        console.error('[Tasks] openTasksAdminAccessModal function not found');
      }
    });
    
    // Initialize Reset button (using openResetTasksModal)
    const resetInitialized = initButton('tasksResetBtn', 'Reset', (e) => {
      if (typeof openResetTasksModal === 'function') {
        openResetTasksModal();
      } else {
        console.error('[Tasks] openResetTasksModal function not found');
      }
    });
    
    // Update element references
    elements.backBtn = document.getElementById('tasksBackBtn');
    elements.settingsBtn = document.getElementById('tasksSettingsBtn');
    elements.resetBtn = document.getElementById('tasksResetBtn');
    
    // Verify all buttons were initialized
    const allInitialized = backInitialized && settingsInitialized && resetInitialized;
    
    if (allInitialized) {
      console.log('[Tasks] All header buttons initialized successfully');
    } else {
      console.warn('[Tasks] Some header buttons failed to initialize:', {
        back: backInitialized,
        settings: settingsInitialized,
        reset: resetInitialized
      });
    }
    
    // Additional verification: Check parent container
    const headerRow = elements.backBtn?.parentElement;
    if (headerRow) {
      const headerRowStyle = window.getComputedStyle(headerRow);
      console.log('[Tasks] Header row styles:', {
        pointerEvents: headerRowStyle.pointerEvents,
        zIndex: headerRowStyle.zIndex,
        position: headerRowStyle.position
      });
      
      // Ensure header row doesn't block clicks
      if (headerRowStyle.pointerEvents === 'none') {
        console.warn('[Tasks] Header row has pointer-events:none, fixing...');
        headerRow.style.pointerEvents = 'auto';
      }
    }
    
    return allInitialized;
  }
  
  /**
   * Initialize category tabs
   */
  function initializeTabs() {
    if (!elements.tabs || elements.tabs.length === 0) {
      console.log('[Tasks] No tabs found');
      return;
    }
    
    const allTabs = Array.from(elements.tabs);
    
    allTabs.forEach(tab => {
      // Remove old onclick
      tab.onclick = null;
      
      // Add new listener
      const handler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const clickedTab = this;
        const clickedCategory = clickedTab.dataset.category || 'Opening';
        console.log("Tasks tab clicked", clickedCategory);
        
        currentCategory = clickedCategory;
        
        // Defer visual updates
        scheduleAnimationFrame(() => {
          // Update tab states
          allTabs.forEach(t => {
            if (t !== clickedTab) {
              t.style.background = 'transparent';
              t.style.borderBottom = '2px solid transparent';
              t.style.color = 'var(--sub)';
              t.style.fontWeight = '500';
              t.classList.remove('active');
            }
          });
          
          clickedTab.style.background = 'rgba(157,104,185,0.08)';
          clickedTab.style.borderBottom = '2px solid var(--brand1)';
          clickedTab.style.color = 'var(--text)';
          clickedTab.style.fontWeight = '600';
          clickedTab.classList.add('active');
          
          if (elements.selectedCategorySpan) {
            elements.selectedCategorySpan.textContent = clickedCategory;
          }
          
          // Update note display
          if (typeof window.updateTaskNoteDisplay === 'function') {
            window.updateTaskNoteDisplay(clickedCategory);
          }
          
          // Re-render tasks
          scheduleAnimationFrame(() => {
            try {
              if (window.renderTasks && typeof window.renderTasks === 'function') {
                window.renderTasks();
              }
              if (window.renderPendingTasks && typeof window.renderPendingTasks === 'function') {
                window.renderPendingTasks();
              }
            } catch (error) {
              console.error('[Tasks] Error rendering tasks:', error);
            }
          });
        });
      };
      
      addTrackedEventListener(tab, 'click', handler, { passive: false });
      
      // Set basic styles
      tab.style.pointerEvents = 'auto';
      tab.style.cursor = 'pointer';
      tab.style.position = 'relative';
      tab.style.zIndex = '501';
    });
    
    // Set initial active tab
    scheduleAnimationFrame(() => {
      allTabs.forEach(tab => {
        if (tab.dataset.category === 'Opening') {
          tab.style.background = 'rgba(157,104,185,0.08)';
          tab.style.borderBottom = '2px solid var(--brand1)';
          tab.style.color = 'var(--text)';
          tab.style.fontWeight = '600';
          tab.classList.add('active');
          if (elements.selectedCategorySpan) {
            elements.selectedCategorySpan.textContent = 'Opening';
          }
        } else {
          tab.style.background = 'transparent';
          tab.style.borderBottom = '2px solid transparent';
          tab.style.color = 'var(--sub)';
          tab.style.fontWeight = '500';
          tab.classList.remove('active');
        }
      });
      
      if (typeof window.updateTaskNoteDisplay === 'function') {
        scheduleTimeout(() => {
          window.updateTaskNoteDisplay('Opening');
        }, 0);
      }
    });
  }
  
  /**
   * Enable interactivity for all Tasks screen elements
   */
  function enableInteractivity() {
    if (!elements.tasksScreen) return;
    
    scheduleAnimationFrame(() => {
      // Enable all buttons
      const buttons = elements.tasksScreen.querySelectorAll('button');
      buttons.forEach(btn => {
        btn.style.pointerEvents = 'auto';
        btn.style.cursor = 'pointer';
        btn.style.position = 'relative';
        btn.style.zIndex = '500';
        if (btn.disabled) {
          btn.style.cursor = 'not-allowed';
        }
      });
      
      // Enable containers
      const containers = elements.tasksScreen.querySelectorAll('#taskListContainer, #pendingTasksContainer');
      containers.forEach(container => {
        container.style.pointerEvents = 'auto';
      });
      
      // Enable interactive elements
      const interactive = elements.tasksScreen.querySelectorAll('a, input, select, [role="button"]');
      interactive.forEach(el => {
        el.style.pointerEvents = 'auto';
        if (el.tagName === 'A' || el.getAttribute('role') === 'button') {
          el.style.cursor = 'pointer';
        }
      });
    });
  }
  
  /**
   * Clean up all resources
   */
  function cleanup() {
    console.log('[Tasks] Starting cleanup...');
    
    // Clear all timers
    resources.timers.forEach(timerId => clearTimeout(timerId));
    resources.timers.clear();
    
    // Cancel all animation frames
    resources.animationFrames.forEach(rafId => cancelAnimationFrame(rafId));
    resources.animationFrames.clear();
    
    // Remove all event listeners
    resources.eventListeners.forEach((listeners, element) => {
      listeners.forEach(({ event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
    });
    resources.eventListeners.clear();
    
    // Restore original styles
    resources.originalStyles.forEach((original, element) => {
      restoreOriginalStyle(element);
    });
    resources.originalStyles.clear();
    
    console.log('[Tasks] Cleanup complete');
  }
  
  // ============================================
  // PUBLIC API - TasksComponent
  // ============================================
  window.TasksComponent = {
    /**
     * Mount the Tasks component (show it)
     */
    mount: function() {
      if (isInitializing || isMounted) {
        console.warn('[Tasks] Already mounted or initializing');
        return;
      }
      
      isInitializing = true;
      console.log('[Tasks] Mounting component...');
      
      // Get DOM elements
      elements.tasksScreen = document.getElementById('tasksScreen');
      elements.mainContent = document.querySelector('#owner-view .wrap');
      elements.joinBar = document.getElementById('joinBar');
      elements.header = document.querySelector('.header');
      elements.backBtn = document.getElementById('tasksBackBtn');
      elements.settingsBtn = document.getElementById('tasksSettingsBtn');
      elements.resetBtn = document.getElementById('tasksResetBtn');
      elements.tabs = document.querySelectorAll('.task-tab');
      elements.selectedCategorySpan = document.getElementById('selectedCategory');
      
      if (!elements.tasksScreen || !elements.mainContent) {
        console.error('[Tasks] Required elements not found');
        isInitializing = false;
        return;
      }
      
      // Close blocking modals
      closeAllBlockingModals();
      
      // Apply header styles (stores originals)
      applyHeaderStyles();
      
      // Show Tasks screen
      elements.tasksScreen.style.pointerEvents = 'auto';
      elements.tasksScreen.style.display = 'flex';
      elements.tasksScreen.style.visibility = 'visible';
      elements.tasksScreen.style.opacity = '1';
      elements.tasksScreen.style.zIndex = '300';
      
      // Hide main content
      elements.mainContent.style.display = 'none';
      if (elements.joinBar) {
        elements.joinBar.style.display = 'none';
      }
      
      // Initialize components (deferred to avoid blocking)
      scheduleTimeout(() => {
        // Initialize header buttons FIRST (most critical for user interaction)
        const headerButtonsOk = initializeHeaderButtons();
        if (!headerButtonsOk) {
          console.error('[Tasks] Header buttons initialization failed, retrying...');
          // Retry once after a short delay
          scheduleTimeout(() => {
            initializeHeaderButtons();
          }, 100);
        }
        
        // Then initialize tabs
        initializeTabs();
        
        // Finally enable general interactivity
        enableInteractivity();
        
        // Re-render tasks
        if (window.renderTasks && typeof window.renderTasks === 'function') {
          window.renderTasks();
        }
        if (window.renderPendingTasks && typeof window.renderPendingTasks === 'function') {
          window.renderPendingTasks();
        }
        
        // Update badges
        if (window.updateAllTabBadges && typeof window.updateAllTabBadges === 'function') {
          window.updateAllTabBadges();
        }
        
        isInitializing = false;
        isMounted = true;
        console.log('[Tasks] Component mounted successfully');
      }, 50);
    },
    
    /**
     * Unmount the Tasks component (hide it and clean up)
     */
    unmount: function() {
      if (!isMounted && !isInitializing) {
        return; // Already unmounted
      }
      
      console.log('[Tasks] Unmounting component...');
      
      // Clean up all resources
      cleanup();
      
      // Restore header styles
      restoreHeaderStyles();
      
      // Hide Tasks screen
      if (elements.tasksScreen) {
        elements.tasksScreen.style.display = 'none';
        elements.tasksScreen.style.pointerEvents = 'none';
      }
      
      // Show main content
      if (elements.mainContent) {
        elements.mainContent.style.display = 'block';
      }
      if (elements.joinBar) {
        elements.joinBar.style.display = 'flex';
      }
      
      // Reset state
      isMounted = false;
      isInitializing = false;
      
      // Clear element references
      Object.keys(elements).forEach(key => {
        elements[key] = null;
      });
      
      console.log('[Tasks] Component unmounted successfully');
    },
    
    /**
     * Get current mounted state
     */
    isMounted: function() {
      return isMounted;
    },
    
    /**
     * Get current category
     */
    getCurrentCategory: function() {
      return currentCategory;
    },
    
    /**
     * Verify header buttons are properly initialized and clickable
     * Useful for debugging - call TasksComponent.verifyHeaderButtons() in console
     */
    verifyHeaderButtons: function() {
      const buttons = {
        back: document.getElementById('tasksBackBtn'),
        settings: document.getElementById('tasksSettingsBtn'),
        reset: document.getElementById('tasksResetBtn')
      };
      
      const results = {};
      
      Object.keys(buttons).forEach(key => {
        const btn = buttons[key];
        if (!btn) {
          results[key] = { found: false, error: 'Button not found in DOM' };
          return;
        }
        
        const computed = window.getComputedStyle(btn);
        const rect = btn.getBoundingClientRect();
        
        results[key] = {
          found: true,
          visible: rect.width > 0 && rect.height > 0,
          pointerEvents: computed.pointerEvents,
          zIndex: computed.zIndex,
          cursor: computed.cursor,
          position: computed.position,
          disabled: btn.disabled,
          hasListener: btn.onclick !== null || btn.getAttribute('onclick') !== null,
          boundingRect: {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height
          }
        };
      });
      
      console.log('[Tasks] Header buttons verification:', results);
      return results;
    }
  };

// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// The following Tasks functions and state have been completely removed:
// - showTasksScreen, goBackToMainScreen
// - initTasksTabs, updateTaskNoteDisplay
// - tasksData, pendingTasks, completedTasks, defaultTasks
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish, Select, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks initialization code
//
// Stub functions to prevent errors if anything tries to call them:
function showTasksScreen() {
  console.warn('[Tasks] Tasks feature removed - showTasksScreen() is a no-op');
}

function goBackToMainScreen(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.warn('[Tasks] Tasks feature removed - goBackToMainScreen() is a no-op');
}

function initTasksTabs() {
  // No-op - Tasks feature removed
}

function updateTaskNoteDisplay(category) {
  // No-op - Tasks feature removed
}

// Expose stubs globally to prevent errors
window.showTasksScreen = showTasksScreen;
window.goBackToMainScreen = goBackToMainScreen;
window.updateTaskNoteDisplay = updateTaskNoteDisplay;

// Tasks functionality - simplified structure (arrays of strings)
let tasksData = {
  Opening: [],
  Closing: [],
  Weekly: [],
  Monthly: [],
  Yearly: []
};

// Helper functions to normalize tasks (backward compatibility)
// Tasks can be stored as strings (old format) or objects with {name, instructions?}
function normalizeTask(task) {
  if (typeof task === 'string') {
    return { name: task, instructions: '' };
  }
  if (task && typeof task === 'object' && task.name) {
    return { name: task.name, instructions: task.instructions || '' };
  }
  return { name: '', instructions: '' };
}

function getTaskName(task) {
  if (typeof task === 'string') return task;
  if (task && typeof task === 'object' && task.name) return task.name;
  return '';
}

function getTaskInstructions(task) {
  if (task && typeof task === 'object' && task.instructions) {
    return task.instructions || '';
  }
  return '';
}

function normalizeTasksArray(tasks) {
  if (!Array.isArray(tasks)) return [];
  return tasks.map(normalizeTask);
}

// Pending tasks for each category
let pendingTasks = {
  Opening: [],
  Closing: [],
  Weekly: [],
  Monthly: [],
  Yearly: []
};

// Completed tasks - structure: { "YYYY-MM-DD": { "Opening": ["task1", "task2"], ... } }
let completedTasks = {};

// Default placeholder tasks
// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// The following Tasks code has been completely removed:
// - defaultTasks constant
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish Task, Select Task, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks state variables (tasksData, pendingTasks, completedTasks, defaultTasks, etc.)
// ============================================

// Add Technician dialog functions (non-Tasks code starts here)

// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// All Tasks functions, state, and initialization code have been completely removed.
// This includes:
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish Task, Select Task, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks-related event handlers and state management
// ============================================
// ORPHANED CODE BLOCK COMMENTED OUT - Contains top-level return statements
// This code was part of a function that was removed during Tasks cleanup
/*
      if (currentDay > reminderDay || (currentDay === reminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    case 'monthly': {
      const [hours, minutes] = (reminder.time || '09:00').split(':').map(Number);
      const reminderTime = hours * 60 + minutes;
      const currentDay = now.getDate();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      
      // Get the last day of current month
      const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
      const reminderDay = Math.min(reminder.day || 1, lastDayOfMonth);
      
      // If we're past the reminder day this month, or on the reminder day and past the time
      if (currentDay > reminderDay || (currentDay === reminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    case 'yearly': {
      const [hours, minutes] = (reminder.time || '09:00').split(':').map(Number);
      const reminderTime = hours * 60 + minutes;
      const currentMonth = now.getMonth() + 1; // 1-12
      const currentDay = now.getDate();
      const reminderMonth = reminder.month || 1;
      const reminderDay = reminder.day || 1;
      
      // Handle day clamping for months with fewer days
      const lastDayOfReminderMonth = new Date(now.getFullYear(), reminderMonth, 0).getDate();
      const actualReminderDay = Math.min(reminderDay, lastDayOfReminderMonth);
      
      // If we're past the reminder date this year, or on the reminder date and past the time
      if (currentMonth > reminderMonth || 
          (currentMonth === reminderMonth && currentDay > actualReminderDay) ||
          (currentMonth === reminderMonth && currentDay === actualReminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    default:
      return false;
  }
}
*/

// Count incomplete tasks for a category
// A task is incomplete if it is NOT in the "done" state
// This includes tasks that are "not_started" (available) or "pending"
// Only tasks marked as "done" (green in UI) are excluded from the count
function countIncompleteTasks(category) {
  const tasks = tasksData[category] || [];
  if (tasks.length === 0) return 0;
  
  let incompleteCount = 0;
  tasks.forEach(task => {
    // Count task if it's NOT completed (not in done state)
    // This includes both "not_started" and "pending" tasks
    const taskName = getTaskName(task);
    if (!isTaskCompletedToday(category, taskName)) {
      incompleteCount++;
    }
  });
  
  return incompleteCount;
}

// Update badge for a specific tab
function updateTabBadge(category) {
  const tab = document.querySelector(`.task-tab[data-category="${category}"]`);
  if (!tab) return;
  
  // Remove existing badge if any
  const existingBadge = tab.querySelector('.task-tab-badge');
  if (existingBadge) {
    existingBadge.remove();
  }
  
  // Check if reminder is active for this category
  if (!isReminderActive(category)) {
    return; // Don't show badge if reminder is not active
  }
  
  // Count incomplete tasks
  const incompleteCount = countIncompleteTasks(category);
  
  // Only show badge if count > 0
  if (incompleteCount > 0) {
    const badge = document.createElement('span');
    badge.className = 'task-tab-badge';
    badge.textContent = incompleteCount.toString();
    badge.style.cssText = 'display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 5px;background:var(--danger);color:#fff;border-radius:999px;font-size:11px;font-weight:700;margin-left:6px;line-height:1;';
    tab.appendChild(badge);
  }
}

// Update all tab badges
function updateAllTabBadges() {
  const categories = ['Opening', 'Closing', 'Weekly', 'Monthly', 'Yearly'];
  categories.forEach(category => {
    updateTabBadge(category);
  });
}

// Make updateAllTabBadges globally available
window.updateAllTabBadges = updateAllTabBadges;

// Get current category
function getCurrentTasksCategory() {
  const activeTab = document.querySelector('.task-tab.active');
  return activeTab ? (activeTab.dataset.category || 'Opening') : 'Opening';
}

// Render tasks for current category (main Task List panel)
function renderTasks() {
  const category = getCurrentTasksCategory();
  const container = document.getElementById('taskListContainer');
  if (!container) {
    console.warn('[Tasks] renderTasks: container not found');
    return;
  }
  
  const tasks = tasksData[category] || [];
  const pending = pendingTasks[category] || [];
  
  console.log('[Tasks] Rendering tasks for category:', category, 'Tasks count:', tasks.length);
  
  if (tasks.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sub);"><p style="font-size:13px;">No tasks available.</p></div>';
    return;
  }
  
  container.innerHTML = '';
  
  tasks.forEach((task, index) => {
    const taskName = getTaskName(task);
    const taskInstructions = getTaskInstructions(task);
    const status = getTaskStatus(category, taskName);
    
    const taskDiv = document.createElement('div');
    // Determine background color and opacity based on status
    let bgColor, opacity;
    if (status === 'done') {
      bgColor = '#f3f4f6';
      opacity = '0.7';
    } else {
      bgColor = 'var(--muted)';
      opacity = '1';
    }
    taskDiv.style.cssText = `display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:${bgColor};border-radius:8px;border:1px solid var(--border);opacity:${opacity};margin-bottom:6px;`;
    
    const leftDiv = document.createElement('div');
    leftDiv.style.cssText = 'display:flex;align-items:center;gap:8px;flex:1;';
    
    // Status dot color based on status
    let dotColor;
    if (status === 'done') {
      dotColor = '#10b981'; // green for done
    } else if (status === 'pending') {
      dotColor = '#6366f1'; // purple for pending
    } else {
      dotColor = '#ef4444'; // red for not done today
    }
    
    const statusDot = document.createElement('div');
    statusDot.style.cssText = `width:8px;height:8px;border-radius:50%;background:${dotColor};flex-shrink:0;`;
    
    // Checkmark icon if done
    if (status === 'done') {
      const checkmark = document.createElement('span');
      checkmark.textContent = 'âœ“';
      checkmark.style.cssText = 'color:#10b981;font-size:13px;font-weight:bold;margin-right:4px;flex-shrink:0;';
      leftDiv.appendChild(checkmark);
    }
    
    const taskSpan = document.createElement('span');
    taskSpan.textContent = taskName;
    taskSpan.style.cssText = 'font-size:13px;color:var(--text);';
    
    leftDiv.appendChild(statusDot);
    leftDiv.appendChild(taskSpan);
    
    const rightDiv = document.createElement('div');
    rightDiv.style.cssText = 'display:flex;align-items:center;gap:6px;';
    
    // Info button (only show if task has instructions)
    if (taskInstructions && taskInstructions.trim() !== '') {
      const infoBtn = document.createElement('button');
      infoBtn.innerHTML = 'â„¹';
      infoBtn.className = 'btn-mini';
      infoBtn.style.cssText = 'width:24px;height:24px;padding:0;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;border-radius:50%;background:var(--brand1);color:#fff;border:none;cursor:pointer;flex-shrink:0;';
      infoBtn.title = 'View instructions';
      infoBtn.addEventListener('click', () => {
        openTaskInstructionsModal(taskName, taskInstructions);
      });
      rightDiv.appendChild(infoBtn);
    }
    
    const selectBtn = document.createElement('button');
    selectBtn.className = 'btn-mini';
    selectBtn.style.fontSize = '11px';
    selectBtn.style.padding = '6px 10px';
    
    // Button state based on status
    if (status === 'done' || status === 'pending') {
      selectBtn.textContent = 'Selected';
      selectBtn.disabled = true;
      selectBtn.style.opacity = '0.6';
      selectBtn.style.cursor = 'not-allowed';
    } else {
      selectBtn.textContent = 'Select';
      selectBtn.disabled = false;
      selectBtn.style.opacity = '1';
      selectBtn.style.cursor = 'pointer';
      // Add click handler to open PIN modal for selecting task
      selectBtn.addEventListener('click', () => {
        openSelectTaskModal(category, taskName);
      });
    }
    
    rightDiv.appendChild(selectBtn);
    
    taskDiv.appendChild(leftDiv);
    taskDiv.appendChild(rightDiv);
    container.appendChild(taskDiv);
  });
  
  // Update tab badges after rendering
  updateAllTabBadges();
}

// Mark task as done (simplified version without PIN requirement)
function markTaskAsDone(category, taskName) {
  if (!category || !taskName) {
    console.warn('[Tasks] markTaskAsDone: Missing category or taskName');
    return;
  }
  
  // Mark task as done in completedTasks
  const today = getTodayDateString();
  if (!completedTasks[today]) {
    completedTasks[today] = {};
  }
  if (!completedTasks[today][category]) {
    completedTasks[today][category] = [];
  }
  
  // Add to completed tasks if not already there
  if (!completedTasks[today][category].includes(taskName)) {
    completedTasks[today][category].push(taskName);
  }
  
  // Remove from pending list (done tasks should not appear in "My Tasks (Pending)")
  const pending = pendingTasks[category] || [];
  const pendingIndex = pending.indexOf(taskName);
  if (pendingIndex !== -1) {
    pending.splice(pendingIndex, 1);
    pendingTasks[category] = pending;
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Re-render both columns immediately
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  if (typeof updateAllTabBadges === 'function') {
    updateAllTabBadges();
  }
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
}

// Add task to pending list
function addTaskToPending(category, taskName, assignedToName) {
  // Prevent adding done tasks to pending list
  if (isTaskCompletedToday(category, taskName)) {
    return; // Task is done, cannot be added to pending
  }
  
  const pending = pendingTasks[category] || [];
  
  // Normalize pending array: convert strings to objects for backward compatibility
  const normalizedPending = pending.map(item => {
    if (typeof item === 'string') {
      // Old format: just task name string
      return { taskName: item, assignedToName: undefined };
    }
    // New format: already an object
    return item;
  });
  
  // Check if already in pending (no duplicates)
  const existingIndex = normalizedPending.findIndex(item => {
    const name = typeof item === 'string' ? item : item.taskName;
    return name === taskName;
  });
  
  if (existingIndex === -1) {
    // Add new task with staff name
    normalizedPending.push({
      taskName: taskName,
      assignedToName: assignedToName || undefined
    });
    pendingTasks[category] = normalizedPending;
    saveTasksData();
    renderTasks(); // Re-render to update button state
    renderPendingTasks(); // Update right column
  } else {
    // Update existing task with staff name if provided
    if (assignedToName) {
      normalizedPending[existingIndex].assignedToName = assignedToName;
      pendingTasks[category] = normalizedPending;
      saveTasksData();
      renderPendingTasks(); // Update right column
    }
  }
}

// Reset tasks for a specific category
function resetTasksForCategory(category) {
  // Clear pending tasks for this category
  if (pendingTasks[category]) {
    pendingTasks[category] = [];
  }
  
  // Clear completed tasks for today for this category
  const today = getTodayDateString();
  if (completedTasks[today] && completedTasks[today][category]) {
    delete completedTasks[today][category];
    // If the day object is now empty, we can optionally clean it up
    if (Object.keys(completedTasks[today]).length === 0) {
      delete completedTasks[today];
    }
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Re-render both columns
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  updateAllTabBadges();
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
}

// Store the category to reset (captured when modal opens)
let currentResetCategory = null;

// Open reset confirmation modal
function openTasksResetModal() {
  // Capture the current category when modal opens (not when confirmed)
  currentResetCategory = getCurrentTasksCategory();
  console.log('[Reset Modal] Opening for category:', currentResetCategory);
  
  const modal = document.getElementById('tasksResetModal');
  const modalContent = document.getElementById('tasksResetModalContent');
  const title = document.getElementById('tasksResetModalTitle');
  const body = document.getElementById('tasksResetModalBody');
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (modal && title && body && input) {
    // Update modal text with current category
    title.textContent = `Reset ${currentResetCategory} tasks?`;
    body.textContent = `This will reset all tasks in the ${currentResetCategory} list back to their initial state (not selected, not done). This does NOT delete history. Are you sure?`;
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
      
      // Use event delegation on modal content - remove old listener first
      const newModalContent = modalContent.cloneNode(true);
      modalContent.parentNode.replaceChild(newModalContent, modalContent);
      const freshModalContent = document.getElementById('tasksResetModalContent');
      
      if (freshModalContent) {
        freshModalContent.addEventListener('click', (e) => {
          if (e.target.id === 'tasksResetConfirm' || e.target.closest('#tasksResetConfirm')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Reset Modal] Confirm clicked via delegation');
            if (typeof confirmTasksReset === 'function') {
              confirmTasksReset();
            } else {
              console.error('[Tasks] confirmTasksReset function not found');
              closeTasksResetModal();
            }
          } else if (e.target.id === 'tasksResetCancel' || e.target.closest('#tasksResetCancel')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Reset Modal] Cancel clicked via delegation');
            closeTasksResetModal();
          }
        }, { capture: true });
      }
    }
    
    // Clear and prepare input
    input.value = '';
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.style.pointerEvents = 'auto';
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Ensure buttons are enabled and clickable (get fresh references after cloning)
    const freshConfirmBtn = document.getElementById('tasksResetConfirm');
    const freshCancelBtn = document.getElementById('tasksResetCancel');
    
    if (freshConfirmBtn) {
      freshConfirmBtn.disabled = false;
      freshConfirmBtn.removeAttribute('disabled');
      freshConfirmBtn.style.pointerEvents = 'auto';
      freshConfirmBtn.style.cursor = 'pointer';
      freshConfirmBtn.style.position = 'relative';
      freshConfirmBtn.style.zIndex = '1102';
      freshConfirmBtn.setAttribute('type', 'button');
    }
    if (freshCancelBtn) {
      freshCancelBtn.disabled = false;
      freshCancelBtn.removeAttribute('disabled');
      freshCancelBtn.style.pointerEvents = 'auto';
      freshCancelBtn.style.cursor = 'pointer';
      freshCancelBtn.style.position = 'relative';
      freshCancelBtn.style.zIndex = '1102';
      freshCancelBtn.setAttribute('type', 'button');
    }
    
    setTimeout(() => {
      const focusInput = document.getElementById('tasksResetPinInput');
      if (focusInput) focusInput.focus();
    }, 100);
  }
}

function closeTasksResetModal() {
  const modal = document.getElementById('tasksResetModal');
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none'; // Disable clicks when modal is closed
  }
  
  // Clear input and error
  if (input) {
    input.value = '';
    input.blur();
  }
  if (error) {
    error.textContent = '';
  }
  
  // Clear the stored category when modal closes
  currentResetCategory = null;
}

// Validate PIN and reset tasks
function confirmTasksReset() {
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (!input) return;
  
  const pin = input.value.trim();
  if (!pin) {
    if (error) error.textContent = 'Please enter manager/admin PIN';
    return;
  }
  
  // Validate PIN - must be admin or manager
  const isAdmin = isAdminCode(pin);
  const isManager = isManagerCode(pin);
  
  if (!isAdmin && !isManager) {
    if (error) error.textContent = 'Only manager or admin can reset this task list.';
    input.value = '';
    setTimeout(() => input.focus(), 100);
    return;
  }
  
  // PIN is valid - reset the category (use the category captured when modal opened)
  const category = currentResetCategory || getCurrentTasksCategory();
  console.log('[Reset Modal] Resetting category:', category);
  if (!category) {
    console.error('[Reset Modal] No category to reset!');
    if (error) error.textContent = 'Error: No category selected. Please try again.';
    return;
  }
  resetTasksForCategory(category);
  
  // Clear the stored category after reset
  currentResetCategory = null;
  
  // Clear input and error
  input.value = '';
  if (error) error.textContent = '';
  
  // Force close modal - ensure it's completely hidden
  const modal = document.getElementById('tasksResetModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
    modal.style.pointerEvents = 'none';
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
  }
  
  // Also call the close function for consistency
  closeTasksResetModal();
}

// Open finish task modal
let currentFinishTask = { category: null, taskName: null };
let currentSelectTask = { category: null, taskName: null };
let taskStaffCode = ''; // State for staff code in Select Task modal

function openSelectTaskModal(category, taskName) {
  currentSelectTask = { category, taskName };
  taskStaffCode = ''; // Initialize state - CRITICAL: must be cleared
  const modal = document.getElementById('tasksSelectModal');
  const input = document.getElementById('tasksSelectPinInput');
  const error = document.getElementById('tasksSelectPinError');
  const confirmBtn = document.getElementById('tasksSelectConfirm');
  const cancelBtn = document.getElementById('tasksSelectCancel');
  
  if (modal && input) {
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure input is fully enabled and ready for typing
    // CRITICAL: Clear both input value and state to ensure they're in sync
    input.value = '';
    taskStaffCode = ''; // Double-check state is cleared
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('inputmode', 'numeric');
    input.setAttribute('maxlength', '4');
    input.style.pointerEvents = 'auto';
    
    // Ensure buttons are enabled and clickable
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.removeAttribute('disabled');
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = 'pointer';
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
    }
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Focus input after a short delay to ensure modal is fully rendered
    setTimeout(() => {
      input.focus();
      // Ensure input is still enabled after focus
      input.readOnly = false;
      input.disabled = false;
    }, 100);
  }
}

function closeSelectTaskModal() {
  try {
    const modal = document.getElementById('tasksSelectModal');
    const input = document.getElementById('tasksSelectPinInput');
    const error = document.getElementById('tasksSelectPinError');
    
    if (modal) {
      // Clear input field
      if (input) {
        input.value = '';
        input.blur();
      }
      
      // Clear error message
      if (error) {
        error.textContent = '';
      }
      
      // Force hide modal using multiple methods and ensure it doesn't block clicks
      modal.style.display = 'none';
      modal.style.visibility = 'hidden';
      modal.style.opacity = '0';
      modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
      modal.classList.remove('active');
      modal.setAttribute('aria-hidden', 'true');
      
      // Clear state
      taskStaffCode = '';
      currentSelectTask = { category: null, taskName: null };
    }
  } catch (err) {
    console.error('[Tasks] Error closing select task modal:', err);
    // Force close even on error
    const modal = document.getElementById('tasksSelectModal');
    if (modal) {
      modal.style.display = 'none';
      modal.style.visibility = 'hidden';
      modal.style.opacity = '0';
      modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  }
}

// Validate PIN and add task to pending
function confirmSelectTask() {
  try {
    const input = document.getElementById('tasksSelectPinInput');
    const error = document.getElementById('tasksSelectPinError');
    
    if (!input || !currentSelectTask.category || !currentSelectTask.taskName) {
      console.warn('[Tasks] confirmSelectTask: Missing required elements or task info');
      // Clear state
      taskStaffCode = '';
      currentSelectTask = { category: null, taskName: null };
      // FORCE CLOSE MODAL - This is the very last line in critical error path
      const taskModal = document.getElementById('tasksSelectModal');
      if (taskModal) {
        taskModal.style.display = 'none';
      }
      return;
    }
    
    // Use state value, with fallback to reading from input directly
    // This ensures we always get the current value even if state is out of sync
    // Use the EXACT same pattern as JOIN function: pin=(pinInput.value||"").toString()
    let code = taskStaffCode || '';
    if (!code && input) {
      // Fallback: read directly from input if state is empty
      code = (input.value || '').toString();
      // Update state with the value we read
      if (code) {
        taskStaffCode = code;
      }
    }
    
    // Convert to string and trim (same as JOIN function does)
    code = (code || '').toString().trim();
    
    // Check if code is empty
    if (!code || code === '') {
      if (error) error.textContent = 'Please enter code (admin, manager, or staff)';
      return; // Don't close modal - user needs to enter code
    }
    
    // Validate code - accept admin, manager, or tech (worker) codes
    // This allows anyone (admin, manager, or tech) to select tasks
    // CRITICAL: Use trimmed code for all comparisons
    const codeStr = code;
    
    let matchedWorker = null;
    let matchedRole = null;
    let matchedName = null;
    
    // Check if code matches admin (check FIRST)
    const adminCheck = isAdminCode(codeStr);
    if (adminCheck) {
      matchedRole = 'Admin';
      matchedName = settings.ownerName || settings.adminName || 'Admin';
      // Create a worker-like object for consistency
      matchedWorker = { name: matchedName, pin: codeStr, role: 'Admin' };
      console.log('[Tasks] Admin code validated:', matchedName);
    }
    // Check if code matches manager (check SECOND)
    else {
      const managerCheck = isManagerCode(codeStr);
      if (managerCheck) {
        const managers = settings.managers || [];
        const manager = managers.find(m => {
          if (!m.code) return false;
          return m.code.toString().trim() === codeStr;
        });
        if (manager) {
          matchedRole = 'Manager';
          matchedName = manager.name || 'Manager';
          matchedWorker = { name: matchedName, pin: codeStr, role: 'Manager' };
          console.log('[Tasks] Manager code validated:', matchedName);
        } else {
          console.warn('[Tasks] isManagerCode returned true but manager not found in list');
        }
      }
      // Check if code matches worker (tech) (check THIRD)
      else {
        const workersList = settings.workers || [];
        for (let i = 0; i < workersList.length; i++) {
          const worker = workersList[i];
          if (!worker.pin) continue;
          // Use exact same comparison as JOIN: w.pin.toString() === code
          const workerPinStr = worker.pin.toString().trim();
          if (workerPinStr === codeStr) {
            matchedWorker = worker;
            matchedRole = 'Tech';
            matchedName = worker.name;
            console.log('[Tasks] Tech code validated:', matchedName);
            break;
          }
        }
      }
    }
    
    if (!matchedWorker) {
      // Debug: log what we're comparing to help troubleshoot
      console.log('[Tasks] Code validation failed - no match found:', {
        enteredCode: codeStr,
        codeType: typeof codeStr,
        codeLength: codeStr.length,
        isAdminCheck: isAdminCode(codeStr),
        isManagerCheck: isManagerCode(codeStr),
        workersCount: (settings.workers || []).length,
        managersCount: (settings.managers || []).length
      });
      if (error) error.textContent = 'Invalid code. Please enter admin, manager, or staff code.';
      // Clear input and state for retry
      taskStaffCode = '';
      if (input) input.value = '';
      setTimeout(() => input.focus(), 100);
      return; // Don't close modal - user needs to correct code
    }
    
    console.log('[Tasks] Code validation SUCCESS:', {
      role: matchedRole,
      name: matchedName,
      code: codeStr
    });
    
    // PIN is valid - add task to pending with staff name
    try {
      if (typeof addTaskToPending === 'function') {
        // Pass the matched staff name to addTaskToPending
        addTaskToPending(currentSelectTask.category, currentSelectTask.taskName, matchedName);
      } else {
        console.warn('[Tasks] addTaskToPending function not found');
      }
      
      // Record in history who selected it
      // Use getActorInfo to properly determine role based on the code
      if (typeof getActorForAction === 'function' && typeof addHistoryEntry === 'function') {
        let actor = null;
        if (matchedRole === 'Admin') {
          actor = getActorForAction({ adminCode: code });
        } else if (matchedRole === 'Manager') {
          actor = getActorForAction({ managerCode: code });
        } else {
          actor = getActorForAction({ workerName: matchedName });
        }
        addHistoryEntry(`Select task: ${currentSelectTask.taskName} (${currentSelectTask.category})`, actor, matchedName);
      }
      
      // Update tab badges
      if (typeof updateAllTabBadges === 'function') {
        updateAllTabBadges();
      }
      
      // Update Tasks button badge (for incomplete tasks count)
      if (typeof updateTasksButtonBadge === 'function') {
        updateTasksButtonBadge();
      }
    } catch (taskErr) {
      console.error('[Tasks] Error processing task selection:', taskErr);
      // Continue to close modal even if task processing fails
    }
    
    // Clear input, error message, and state
    const staffCodeInput = document.getElementById('tasksSelectPinInput');
    const errorMsg = document.getElementById('tasksSelectPinError');
    if (staffCodeInput) {
      staffCodeInput.value = '';
    }
    if (errorMsg) {
      errorMsg.textContent = ''; // Clear error message on success
    }
    taskStaffCode = '';
    currentSelectTask = { category: null, taskName: null };
    
    // FORCE CLOSE MODAL - This is the very last line in success path
    const taskModal = document.getElementById('tasksSelectModal');
    if (taskModal) {
      taskModal.style.display = 'none';
      taskModal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  } catch (err) {
    console.error('[Tasks] Error in confirmSelectTask:', err);
    
    // Clear input, error message, and state
    const staffCodeInput = document.getElementById('tasksSelectPinInput');
    const errorMsg = document.getElementById('tasksSelectPinError');
    if (staffCodeInput) {
      staffCodeInput.value = '';
    }
    if (errorMsg) {
      errorMsg.textContent = ''; // Clear error message
    }
    taskStaffCode = '';
    currentSelectTask = { category: null, taskName: null };
    
    // FORCE CLOSE MODAL - This is the very last line in error path
    const taskModal = document.getElementById('tasksSelectModal');
    if (taskModal) {
      taskModal.style.display = 'none';
      taskModal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  }
}

function openFinishTaskModal(category, taskName) {
  currentFinishTask = { category, taskName };
  const modal = document.getElementById('tasksFinishModal');
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  const confirmBtn = document.getElementById('tasksFinishConfirm');
  const cancelBtn = document.getElementById('tasksFinishCancel');
  
  if (modal && input) {
    const modalContent = document.getElementById('tasksFinishModalContent');
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Clear and prepare input
    input.value = '';
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.style.pointerEvents = 'auto';
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Ensure buttons are enabled and clickable
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.removeAttribute('disabled');
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.position = 'relative';
      confirmBtn.style.zIndex = '1102';
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.position = 'relative';
      cancelBtn.style.zIndex = '1102';
    }
    
    setTimeout(() => input.focus(), 100);
  }
}

function closeFinishTaskModal() {
  const modal = document.getElementById('tasksFinishModal');
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  
  if (modal) {
    // Clear input and error
    if (input) {
      input.value = '';
      input.blur();
    }
    if (error) {
      error.textContent = '';
    }
    
    // Force hide modal and ensure it doesn't block clicks
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    currentFinishTask = { category: null, taskName: null };
  }
}

// Validate PIN and mark task as done
async function confirmFinishTask() {
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  
  if (!input || !currentFinishTask.category || !currentFinishTask.taskName) {
    console.warn('[Tasks] confirmFinishTask: Missing required elements or task info');
    closeFinishTaskModal();
    return;
  }
  
  // Use the EXACT same pattern as JOIN function: pin=(pinInput.value||"").toString()
  let pin = (input.value || '').toString().trim();
  
  if (!pin || pin === '') {
    if (error) error.textContent = 'Please enter code (admin, manager, or staff)';
    return; // Don't close modal - user needs to enter code
  }
  
  // Validate PIN - accept admin, manager, or tech (worker) codes
  // This allows anyone (admin, manager, or tech) to mark tasks as done
  // CRITICAL: Use trimmed PIN for all comparisons
  const pinStr = pin;
  
  let matchedWorker = null;
  let matchedRole = null;
  let matchedName = null;
  
  // Check if PIN matches admin (check FIRST)
  const adminCheck = isAdminCode(pinStr);
  if (adminCheck) {
    matchedRole = 'Admin';
    matchedName = settings.ownerName || settings.adminName || 'Admin';
    // Create a worker-like object for consistency
    matchedWorker = { name: matchedName, pin: pinStr, role: 'Admin' };
    console.log('[Tasks] Admin code validated for finish task:', matchedName);
  }
  // Check if PIN matches manager (check SECOND)
  else {
    const managerCheck = isManagerCode(pinStr);
    if (managerCheck) {
      const managers = settings.managers || [];
      const manager = managers.find(m => {
        if (!m.code) return false;
        return m.code.toString().trim() === pinStr;
      });
      if (manager) {
        matchedRole = 'Manager';
        matchedName = manager.name || 'Manager';
        matchedWorker = { name: matchedName, pin: pinStr, role: 'Manager' };
        console.log('[Tasks] Manager code validated for finish task:', matchedName);
      } else {
        console.warn('[Tasks] isManagerCode returned true but manager not found in list');
      }
    }
    // Check if PIN matches worker (tech) (check THIRD)
    else {
      const workersList = settings.workers || [];
      for (let i = 0; i < workersList.length; i++) {
        const worker = workersList[i];
        if (!worker.pin) continue;
        // Use exact same comparison as JOIN: w.pin.toString() === pin
        const workerPinStr = worker.pin.toString().trim();
        if (workerPinStr === pinStr) {
          matchedWorker = worker;
          matchedRole = 'Tech';
          matchedName = worker.name;
          console.log('[Tasks] Tech code validated for finish task:', matchedName);
          break;
        }
      }
    }
  }
  
  if (!matchedWorker) {
    // Debug: log what we're comparing to help troubleshoot
    console.log('[Tasks] Code validation failed for finish task - no match found:', {
      enteredCode: pinStr,
      codeType: typeof pinStr,
      codeLength: pinStr.length,
      isAdminCheck: isAdminCode(pinStr),
      isManagerCheck: isManagerCode(pinStr),
      workersCount: (settings.workers || []).length,
      managersCount: (settings.managers || []).length
    });
    if (error) error.textContent = 'Invalid code. Please enter admin, manager, or staff code.';
    input.value = '';
    setTimeout(() => input.focus(), 100);
    return; // Don't close modal - user needs to correct code
  }
  
  console.log('[Tasks] Code validation SUCCESS for finish task:', {
    role: matchedRole,
    name: matchedName,
    code: pinStr
  });
  
  const worker = matchedWorker;
  
  // PIN is valid - record in history who completed it
  // Use getActorInfo to properly determine role based on the code
  let actor = null;
  if (matchedRole === 'Admin') {
    actor = getActorForAction({ adminCode: pin });
  } else if (matchedRole === 'Manager') {
    actor = getActorForAction({ managerCode: pin });
  } else {
    actor = getActorForAction({ workerName: matchedName });
  }
  addHistoryEntry(`Complete task: ${currentFinishTask.taskName} (${currentFinishTask.category})`, actor, matchedName);
  
  // PIN is valid - mark task as done
  const today = getTodayDateString();
  if (!completedTasks[today]) {
    completedTasks[today] = {};
  }
  if (!completedTasks[today][currentFinishTask.category]) {
    completedTasks[today][currentFinishTask.category] = [];
  }
  
  // Add to completed tasks if not already there
  if (!completedTasks[today][currentFinishTask.category].includes(currentFinishTask.taskName)) {
    completedTasks[today][currentFinishTask.category].push(currentFinishTask.taskName);
  }
  
  // Remove from pending list (done tasks should not appear in "My Tasks (Pending)")
  const pending = pendingTasks[currentFinishTask.category] || [];
  const pendingIndex = pending.indexOf(currentFinishTask.taskName);
  if (pendingIndex !== -1) {
    pending.splice(pendingIndex, 1);
    pendingTasks[currentFinishTask.category] = pending;
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Close modal immediately
  closeFinishTaskModal();
  
  // Re-render both columns immediately (before async Firestore save)
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  if (typeof updateAllTabBadges === 'function') {
    updateAllTabBadges();
  }
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
  
  // Save to Firestore (async, doesn't block UI update)
  saveTaskCompletionToFirestore(
    currentFinishTask.category,
    currentFinishTask.taskName,
    worker.name,
    pin
  ).catch(err => {
    console.error('[Tasks] Firestore save failed (non-blocking):', err);
  });
}

// Save task completion to Firestore
async function saveTaskCompletionToFirestore(category, taskName, staffName, staffCode) {
  try {
    const today = getTodayDateString();
    const now = new Date();
    
    const completionData = {
      date: today,
      timestamp: now.toISOString(),
      period: category,
      taskLabel: taskName,
      staffName: staffName || '',
      staffCode: staffCode || '',
      status: 'done'
    };
    
    // Use the function exposed by app.js
    if (typeof window.saveTaskCompletion === 'function') {
      await window.saveTaskCompletion(completionData);
    } else {
      console.warn('[Tasks] saveTaskCompletion function not available, task completion saved to localStorage only');
    }
  } catch(e) {
    console.error('[Tasks] Failed to save task completion to Firestore:', e);
    // Don't throw - localStorage save already succeeded
  }
}

// Render pending tasks for current category (right column)
function renderPendingTasks() {
  const category = getCurrentTasksCategory();
  const container = document.getElementById('pendingTasksContainer');
  if (!container) return;
  
  const pending = pendingTasks[category] || [];
  
  // Normalize pending array: convert strings to objects for backward compatibility
  const normalizedPending = pending.map(item => {
    if (typeof item === 'string') {
      // Old format: just task name string
      return { taskName: item, assignedToName: undefined };
    }
    // New format: already an object
    return item;
  });
  
  // Filter out done tasks - they should not appear in "My Tasks (Pending)"
  const activePending = normalizedPending.filter(item => {
    const taskName = typeof item === 'string' ? item : item.taskName;
    const status = getTaskStatus(category, taskName);
    return status !== 'done';
  });
  
  container.innerHTML = '';
  
  if (activePending.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sub);"><p style="font-size:13px;">No pending tasks.</p></div>';
    return;
  }
  
  activePending.forEach((item, index) => {
    // Extract task name and assigned name from item (handles both old string format and new object format)
    const taskName = typeof item === 'string' ? item : item.taskName;
    const assignedToName = typeof item === 'string' ? undefined : item.assignedToName;
    const status = getTaskStatus(category, taskName);
    
    // Find the task object to get instructions
    const tasks = tasksData[category] || [];
    const taskObj = tasks.find(t => getTaskName(t) === taskName);
    const taskInstructions = taskObj ? getTaskInstructions(taskObj) : '';
    
    const taskDiv = document.createElement('div');
    // Determine background color and opacity based on status
    let bgColor, opacity;
    if (status === 'done') {
      bgColor = '#f3f4f6';
      opacity = '0.7';
    } else {
      bgColor = 'var(--muted)';
      opacity = '1';
    }
    taskDiv.style.cssText = `display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:${bgColor};border-radius:8px;border:1px solid var(--border);opacity:${opacity};margin-bottom:6px;`;
    
    const leftDiv = document.createElement('div');
    leftDiv.style.cssText = 'display:flex;align-items:center;gap:8px;flex:1;';
    
    // Status dot color based on status
    let dotColor;
    if (status === 'done') {
      dotColor = '#9ca3af'; // grey
    } else {
      dotColor = '#6366f1'; // purple (pending)
    }
    
    const statusDot = document.createElement('div');
    statusDot.style.cssText = `width:8px;height:8px;border-radius:50%;background:${dotColor};flex-shrink:0;`;
    
    // Checkmark icon if done
    if (status === 'done') {
      const checkmark = document.createElement('span');
      checkmark.textContent = 'âœ“';
      checkmark.style.cssText = 'color:#10b981;font-size:13px;font-weight:bold;margin-right:4px;flex-shrink:0;';
      leftDiv.appendChild(checkmark);
    }
    
    const taskSpan = document.createElement('span');
    taskSpan.textContent = taskName;
    taskSpan.style.cssText = 'font-size:13px;color:var(--text);';
    
    leftDiv.appendChild(statusDot);
    leftDiv.appendChild(taskSpan);
    
    const rightDiv = document.createElement('div');
    rightDiv.style.cssText = 'display:flex;align-items:center;gap:6px;';
    
    // Info button removed from pending tasks - only show in main task list (left column)
    // Pending tasks should only show task name + Mark Done button
    
    // Hide "Mark Done" button if done
    if (status !== 'done') {
      // Show staff name BEFORE Mark Done button if available
      if (assignedToName && assignedToName.trim() !== '') {
        const nameSpan = document.createElement('span');
        nameSpan.textContent = assignedToName;
        // Match the font size and style of the "Mark Done" button
        nameSpan.style.cssText = 'font-size:11px;font-weight:700;color:var(--text);font-family:inherit;';
        rightDiv.appendChild(nameSpan);
      }
      
      const markDoneBtn = document.createElement('button');
      markDoneBtn.className = 'btn-mini';
      markDoneBtn.textContent = 'Mark Done';
      markDoneBtn.style.fontSize = '11px';
      markDoneBtn.style.padding = '6px 10px';
      markDoneBtn.type = 'button';
      markDoneBtn.style.pointerEvents = 'auto';
      markDoneBtn.style.cursor = 'pointer';
      // Add data attributes for event delegation
      markDoneBtn.setAttribute('data-action', 'mark-done');
      markDoneBtn.setAttribute('data-category', category);
      markDoneBtn.setAttribute('data-task-name', taskName);
      // Also add direct click handler as backup (in case event delegation fails)
      markDoneBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[Tasks] Mark Done button clicked directly:', { category, taskName });
        if (typeof openFinishTaskModal === 'function') {
          openFinishTaskModal(category, taskName);
        } else if (typeof markTaskAsDone === 'function') {
          console.log('[Tasks] Fallback: using markTaskAsDone directly');
          markTaskAsDone(category, taskName);
        } else {
          console.error('[Tasks] Neither openFinishTaskModal nor markTaskAsDone function found');
        }
      });
      rightDiv.appendChild(markDoneBtn);
    }
    
    taskDiv.appendChild(leftDiv);
    taskDiv.appendChild(rightDiv);
    container.appendChild(taskDiv);
  });
}

// Admin Access Modal functions
function openTasksAdminAccessModal(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.log("Tasks Settings clicked - opening admin access modal");
  const modal = document.getElementById('tasksAdminAccessModal');
  const modalContent = document.getElementById('tasksAdminAccessModalContent');
  const input = document.getElementById('tasksAdminPinInput');
  const error = document.getElementById('tasksAdminPinError');
  
  if (!modal) {
    console.error('[Tasks] Admin access modal not found in DOM');
    return;
  }
  
  if (!input) {
    console.error('[Tasks] Admin PIN input not found in DOM');
    return;
  }
  
  // Show modal with proper pointer events
  modal.style.display = 'flex';
  modal.style.pointerEvents = 'auto';
  modal.style.visibility = 'visible';
  modal.style.opacity = '1';
  
  // Ensure modal content is interactive
  if (modalContent) {
    modalContent.style.pointerEvents = 'auto';
    modalContent.style.position = 'relative';
    modalContent.style.zIndex = '1101';
  }
  
  // Clear any previous error
  if (error) {
    error.textContent = '';
  }
  
  // Clear input and focus it
  input.value = '';
  input.style.pointerEvents = 'auto';
  
  // Focus the input after a short delay to ensure modal is visible
  setTimeout(() => {
    input.focus();
  }, 50);
  
  console.log('[Tasks] Admin access modal opened');
}

function closeTasksAdminAccessModal() {
  console.log('[Tasks] Closing admin access modal');
  const modal = document.getElementById('tasksAdminAccessModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
  }
}

// Handle "Forgot admin PIN?" click
// This now calls the Cloud Function to send an email reset link instead of opening a modal
async function handleForgotAdminPin(event) {
  if (event) {
    event.preventDefault(); // Stop any default action
  }
  
  // Check if user is signed in
  if (!window.auth || !window.auth.currentUser) {
    alert('Please log in with your owner account to reset the admin PIN.');
    return;
  }
  
  // Show loading message
  alert('Sending PIN reset link. Please wait...');
  
  try {
    // Ensure Firebase Functions SDK is available
    if (!window.generatePinResetLink || typeof window.generatePinResetLink !== 'function') {
      throw new Error('Reset functionality is not available. Please refresh the page and try again.');
    }
    
    // Call the Cloud Function to generate reset link
    const result = await window.generatePinResetLink();
    
    // Success feedback
    const successMessage = result?.data?.message || 'Admin PIN reset link sent successfully to your email.';
    
    // Close any open modals
    closeTasksAdminAccessModal();
    
    // Show success alert
    alert('Success! ' + successMessage);
    
  } catch (error) {
    console.error('[AdminPIN] Error requesting PIN reset:', error);
    
    // Display user-friendly error message
    let errorMessage = 'Could not send reset link. ';
    
    if (error.code === 'unauthenticated') {
      errorMessage = 'Please log in to request a PIN reset.';
    } else if (error.code === 'failed-precondition') {
      errorMessage = 'Your account is not associated with a business. Please contact support.';
    } else if (error.code === 'internal') {
      errorMessage = 'Server error occurred. Please try again later or contact support.';
    } else if (error.message) {
      errorMessage = error.message;
    } else {
      errorMessage += 'Please try again or contact support.';
    }
    
    alert('Error: ' + errorMessage);
  }
}


function verifyTasksAdminPin() {
  const input = document.getElementById('tasksAdminPinInput');
  const error = document.getElementById('tasksAdminPinError');
  
  if (!input) return;
  
  const pin = input.value.trim();
  if (!pin) {
    if (error) error.textContent = 'Please enter admin code';
    return;
  }
  
  // Use existing isAdminCode function if available, otherwise hardcode '1234'
  let isValid = false;
  if (typeof isAdminCode === 'function') {
    isValid = isAdminCode(pin);
  } else {
    // Fallback: hardcoded admin PIN
    const ADMIN_PIN = '1234';
    isValid = pin === ADMIN_PIN;
  }
  
  if (isValid) {
    closeTasksAdminAccessModal();
    openTasksEditModal();
  } else {
    if (error) error.textContent = 'Invalid admin code';
    input.value = '';
    setTimeout(() => input.focus(), 100);
  }
}

// Tasks Edit Modal functions
let editModalTasks = []; // Local editable state for the modal (array of task objects: {name, instructions})

// Task Instructions Modal functions
function openTaskInstructionsModal(taskName, instructions) {
  const modal = document.getElementById('tasksInstructionsModal');
  const modalContent = document.getElementById('tasksInstructionsModalContent');
  const title = document.getElementById('tasksInstructionsModalTitle');
  const body = document.getElementById('tasksInstructionsModalBody');
  const closeBtn = document.getElementById('tasksInstructionsModalClose');
  
  if (modal && title && body) {
    title.textContent = taskName;
    body.textContent = instructions || 'No instructions available.';
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.pointerEvents = 'auto';
    
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Ensure Close button is enabled and clickable - reattach handler every time modal opens
    if (closeBtn) {
      closeBtn.style.pointerEvents = 'auto';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.position = 'relative';
      closeBtn.style.zIndex = '1102';
      closeBtn.disabled = false;
      closeBtn.setAttribute('type', 'button');
      
      // Reattach handler every time modal opens to ensure it works
      if (typeof window.attachInstructionsModalCloseHandler === 'function') {
        window.attachInstructionsModalCloseHandler();
        console.log('[Tasks] Instructions modal Close button handler reattached on open');
      }
    }
  }
}

function closeTaskInstructionsModal() {
  console.log('[Tasks] closeTaskInstructionsModal called');
  const modal = document.getElementById('tasksInstructionsModal');
  if (modal) {
    // Force close with multiple methods
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
    
    console.log('[Tasks] Modal closed successfully');
  } else {
    console.warn('[Tasks] Modal element not found');
  }
  
  // Clear any content
  const title = document.getElementById('tasksInstructionsModalTitle');
  const body = document.getElementById('tasksInstructionsModalBody');
  if (title) title.textContent = 'Task Instructions';
  if (body) body.textContent = '';
}

// Make function globally available
window.closeTaskInstructionsModal = closeTaskInstructionsModal;

function openTasksEditModal() {
  const modal = document.getElementById('tasksEditModal');
  const modalContent = document.getElementById('tasksEditModalContent');
  const title = document.getElementById('tasksEditModalTitle');
  const listContainer = document.getElementById('tasksEditModalList');
  
  if (modal) {
    // Get current category
    const activeTab = document.querySelector('.task-tab.active');
    const category = activeTab ? (activeTab.dataset.category || 'Opening') : 'Opening';
    
    // Update modal title with current category
    if (title) {
      title.textContent = `Edit Tasks â€“ ${category}`;
    }
    
    // Load current tasks for this category into local editable state (normalize to objects)
    const categoryTasks = tasksData[category] || [];
    editModalTasks = categoryTasks.map(task => normalizeTask(task));
    
    // Render editable task rows
    renderEditModalTasks();
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto';
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Ensure Save and Cancel buttons are clickable
    const saveBtn = document.getElementById('tasksEditModalSave');
    const cancelBtn = document.getElementById('tasksEditModalCancel');
    const addBtn = document.getElementById('tasksEditAddTaskBtn');
    
    if (saveBtn) {
      saveBtn.disabled = false;
      saveBtn.removeAttribute('disabled');
      saveBtn.style.pointerEvents = 'auto';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.position = 'relative';
      saveBtn.style.zIndex = '1102';
      saveBtn.setAttribute('type', 'button');
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.position = 'relative';
      cancelBtn.style.zIndex = '1102';
      cancelBtn.setAttribute('type', 'button');
    }
    if (addBtn) {
      addBtn.disabled = false;
      addBtn.removeAttribute('disabled');
      addBtn.style.pointerEvents = 'auto';
      addBtn.style.cursor = 'pointer';
      addBtn.setAttribute('type', 'button');
    }
  }
}

function closeTasksEditModal() {
  const modal = document.getElementById('tasksEditModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    editModalTasks = []; // Clear local state
  }
}

function renderEditModalTasks() {
  const listContainer = document.getElementById('tasksEditModalList');
  if (!listContainer) return;
  
  listContainer.innerHTML = '';
  
  editModalTasks.forEach((task, index) => {
    const row = createEditModalTaskRow(task, index);
    listContainer.appendChild(row);
  });
}

function createEditModalTaskRow(task, index) {
  // Normalize task to object format
  const normalizedTask = normalizeTask(task);
  
  const row = document.createElement('div');
  row.className = 'edit-task-row';
  row.style.cssText = 'display:flex;flex-direction:column;gap:8px;padding:12px;background:var(--muted);border-radius:8px;border:1px solid var(--border);';
  
  // Top row: dot, input, delete button
  const topRow = document.createElement('div');
  topRow.style.cssText = 'display:flex;align-items:center;gap:10px;';
  
  // Status dot
  const dot = document.createElement('div');
  dot.style.cssText = 'width:8px;height:8px;border-radius:50%;background:#10b981;flex-shrink:0;';
  
  // Task name input
  const input = document.createElement('input');
  input.type = 'text';
  input.value = normalizedTask.name;
  input.placeholder = 'Task name';
  input.style.cssText = 'flex:1;border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:14px;outline:none;background:#fff;';
  input.addEventListener('input', (e) => {
    if (!editModalTasks[index] || typeof editModalTasks[index] === 'string') {
      editModalTasks[index] = { name: e.target.value, instructions: '' };
    } else {
      editModalTasks[index].name = e.target.value;
    }
  });
  
  // Delete button
  const deleteBtn = document.createElement('button');
  deleteBtn.innerHTML = 'âœ–';
  deleteBtn.className = 'btn-mini';
  deleteBtn.style.cssText = 'width:28px;height:28px;padding:0;display:flex;align-items:center;justify-content:center;font-size:14px;color:#ef4444;border-color:#fca5a5;flex-shrink:0;';
  deleteBtn.title = 'Delete task';
  deleteBtn.addEventListener('click', () => {
    editModalTasks.splice(index, 1);
    renderEditModalTasks();
  });
  
  topRow.appendChild(dot);
  topRow.appendChild(input);
  topRow.appendChild(deleteBtn);
  
  // Instructions textarea
  const instructionsTextarea = document.createElement('textarea');
  instructionsTextarea.value = normalizedTask.instructions || '';
  instructionsTextarea.placeholder = 'Instructions (optional) â€“ how to do this task';
  instructionsTextarea.rows = 2;
  instructionsTextarea.style.cssText = 'width:100%;border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;outline:none;background:#fff;font-family:inherit;resize:vertical;';
  instructionsTextarea.addEventListener('input', (e) => {
    if (!editModalTasks[index] || typeof editModalTasks[index] === 'string') {
      editModalTasks[index] = { name: normalizedTask.name, instructions: e.target.value };
    } else {
      editModalTasks[index].instructions = e.target.value;
    }
  });
  
  row.appendChild(topRow);
  row.appendChild(instructionsTextarea);
  
  return row;
}

// Guard to prevent double-clicking
let isAddingTask = false;

function addTaskToEditModal() {
  // Prevent double execution
  if (isAddingTask) {
    console.log('[Tasks] Already adding a task, ignoring duplicate call');
    return;
  }
  
  isAddingTask = true;
  console.log('[Tasks] Adding new task to edit modal');
  
  try {
    editModalTasks.push({ name: '', instructions: '' });
    renderEditModalTasks();
    console.log('[Tasks] Task added. Total tasks in modal:', editModalTasks.length);
    
    // Focus the new input
    const listContainer = document.getElementById('tasksEditModalList');
    if (listContainer) {
      const lastRow = listContainer.lastElementChild;
      if (lastRow) {
        const input = lastRow.querySelector('input');
        if (input) {
          setTimeout(() => input.focus(), 50);
        }
      }
    }
  } catch (error) {
    console.error('[Tasks] Error adding task:', error);
  } finally {
    // Reset flag after a short delay to allow for legitimate rapid clicks
    setTimeout(() => {
      isAddingTask = false;
    }, 500);
  }
}

function saveEditModalTasks() {
  const category = getCurrentTasksCategory();
  const listContainer = document.getElementById('tasksEditModalList');
  
  // Read tasks directly from DOM inputs to ensure we get the latest values
  // This is more reliable than relying on state that might be out of sync
  const validTasks = [];
  
  if (listContainer) {
    // Use class selector for more reliable row finding
    const taskRows = listContainer.querySelectorAll('.edit-task-row');
    taskRows.forEach((row) => {
      const nameInput = row.querySelector('input[type="text"]');
      const instructionsTextarea = row.querySelector('textarea');
      
      if (nameInput) {
        const taskName = (nameInput.value || '').trim();
        const instructions = instructionsTextarea ? (instructionsTextarea.value || '').trim() : '';
        
        // Only add if task name is not empty
        if (taskName.length > 0) {
          validTasks.push({
            name: taskName,
            instructions: instructions
          });
        }
      }
    });
  } else {
    // Fallback: use editModalTasks state if DOM reading fails
    console.warn('[Tasks] Could not read from DOM, using state fallback');
    validTasks.push(...editModalTasks
      .map(t => {
        const normalized = normalizeTask(t);
        return {
          name: normalized.name.trim(),
          instructions: (normalized.instructions || '').trim()
        };
      })
      .filter(t => t.name.length > 0));
  }
  
  console.log('[Tasks] Saving tasks for category:', category, 'Tasks:', validTasks);
  
  // Update main tasks state - ensure it's an array
  if (!Array.isArray(validTasks)) {
    console.error('[Tasks] validTasks is not an array:', validTasks);
    return;
  }
  
  tasksData[category] = validTasks;
  
  // Update global reference immediately
  window.tasksData = tasksData;
  
  // Save to localStorage
  saveTasksData();
  
  // Verify the save worked
  const verify = localStorage.getItem('fairflow_tasks_config');
  if (verify) {
    const parsed = JSON.parse(verify);
    console.log('[Tasks] Verification - Saved', category, ':', parsed[category]);
  }
  
  // Re-render main task list - ensure we're rendering the correct category
  // First, make sure the active tab matches the category we just saved
  const categoryTabs = document.querySelectorAll('.task-tab');
  categoryTabs.forEach(tab => {
    if (tab.dataset.category === category) {
      tab.classList.add('active');
    } else {
      tab.classList.remove('active');
    }
  });
  
  // Update selected category span
  const selectedCategorySpan = document.getElementById('selectedCategorySpan');
  if (selectedCategorySpan) {
    selectedCategorySpan.textContent = category;
  }
  
  // Now render tasks
  if (typeof renderTasks === 'function') {
    renderTasks();
  } else {
    console.error('[Tasks] renderTasks function not found');
  }
  
  // Also re-render pending tasks
  if (typeof renderPendingTasks === 'function') {
    renderPendingTasks();
  }
  
  // Close modal first
  closeTasksEditModal();
  
  // Render tasks once after a short delay to ensure DOM is ready
  setTimeout(() => {
    console.log('[Tasks] Re-rendering after save');
    if (typeof renderTasks === 'function') {
      renderTasks();
    } else {
      console.error('[Tasks] renderTasks function not found');
    }
    
    // Also re-render pending tasks
    if (typeof renderPendingTasks === 'function') {
      renderPendingTasks();
    }
    
    // Update badges
    if (typeof updateAllTabBadges === 'function') {
      updateAllTabBadges();
    }
  }, 100);
}

// Initialize tasks functionality
function initTasksFunctionality() {
  initTasksData();
  
  // Modal handlers - initialize once on page load
  // Admin Access Modal handlers
  const adminModal = document.getElementById('tasksAdminAccessModal');
  const adminModalContent = document.getElementById('tasksAdminAccessModalContent');
  const adminPinInput = document.getElementById('tasksAdminPinInput');
  const adminContinueBtn = document.getElementById('tasksAdminAccessContinue');
  const adminCancelBtn = document.getElementById('tasksAdminAccessCancel');
  
  // Close admin modal when clicking outside (on overlay)
  if (adminModal && adminModalContent) {
    adminModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the backdrop (modal itself), not on content
      if (e.target === adminModal && !adminModalContent.contains(e.target)) {
        console.log('[Tasks] Closing admin modal - backdrop clicked');
        closeTasksAdminAccessModal();
      }
    });
    // Ensure modal backdrop is clickable
    adminModal.style.pointerEvents = 'auto';
  }
  
  // Cancel button
  if (adminCancelBtn) {
    adminCancelBtn.addEventListener('click', closeTasksAdminAccessModal);
  }
  
  // Forgot admin PIN button
  const forgotAdminPinBtn = document.getElementById('tasksForgotAdminPin');
  if (forgotAdminPinBtn) {
    forgotAdminPinBtn.addEventListener('click', handleForgotAdminPin);
  }
  
  // Continue button - validates PIN
  if (adminContinueBtn) {
    adminContinueBtn.addEventListener('click', verifyTasksAdminPin);
  }
  
  // Enter key to continue
  if (adminPinInput) {
    adminPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        verifyTasksAdminPin();
      } else if (e.key === 'Escape') {
        closeTasksAdminAccessModal();
      }
    });
  }
  
  // Numeric-only input for PIN fields (these elements may not exist yet, so check)
  const resetPinNewInput = document.getElementById('reset-pin-new');
  const resetPinConfirmInput = document.getElementById('reset-pin-confirm');
  if (resetPinNewInput) {
    resetPinNewInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
  }
  if (resetPinConfirmInput) {
    resetPinConfirmInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
  }
  
  // Tasks Edit Modal handlers
  const editModal = document.getElementById('tasksEditModal');
  const editModalContent = document.getElementById('tasksEditModalContent');
  const editModalCancel = document.getElementById('tasksEditModalCancel');
  const editModalSave = document.getElementById('tasksEditModalSave');
  const editAddTaskBtn = document.getElementById('tasksEditAddTaskBtn');
  
  // Close edit modal when clicking outside (on overlay)
  if (editModal && editModalContent) {
    editModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay background, not on the content
      if (e.target === editModal && !editModalContent.contains(e.target)) {
        closeTasksEditModal();
      }
      // Don't stop propagation for content clicks - let buttons handle their own clicks
    });
  }
  
  // Cancel button - use only addEventListener to prevent double execution
  if (editModalCancel) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[Tasks] Edit modal cancel clicked');
      closeTasksEditModal();
    };
    // Remove old handler and add new one
    const newCancel = editModalCancel.cloneNode(true);
    editModalCancel.parentNode.replaceChild(newCancel, editModalCancel);
    const freshCancel = document.getElementById('tasksEditModalCancel');
    if (freshCancel) {
      freshCancel.addEventListener('click', cancelHandler);
      freshCancel.disabled = false;
      freshCancel.removeAttribute('disabled');
      freshCancel.style.pointerEvents = 'auto';
      freshCancel.style.cursor = 'pointer';
      freshCancel.setAttribute('type', 'button');
    }
  }
  
  // Save button - use only addEventListener to prevent double execution
  if (editModalSave) {
    const saveHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[Tasks] Edit modal save clicked');
      if (typeof saveEditModalTasks === 'function') {
        saveEditModalTasks();
      } else {
        console.error('[Tasks] saveEditModalTasks function not found');
        closeTasksEditModal();
      }
    };
    // Remove old handler and add new one
    const newSave = editModalSave.cloneNode(true);
    editModalSave.parentNode.replaceChild(newSave, editModalSave);
    const freshSave = document.getElementById('tasksEditModalSave');
    if (freshSave) {
      freshSave.addEventListener('click', saveHandler);
      freshSave.disabled = false;
      freshSave.removeAttribute('disabled');
      freshSave.style.pointerEvents = 'auto';
      freshSave.style.cursor = 'pointer';
      freshSave.setAttribute('type', 'button');
    }
  }
  
  // Add task button in edit modal
  if (editAddTaskBtn) {
    const addHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof addTaskToEditModal === 'function') {
        addTaskToEditModal();
      }
    };
    editAddTaskBtn.addEventListener('click', addHandler);
    editAddTaskBtn.onclick = addHandler; // Fallback
    editAddTaskBtn.setAttribute('type', 'button');
    editAddTaskBtn.style.pointerEvents = 'auto';
    editAddTaskBtn.style.cursor = 'pointer';
  }
  
  // Task Instructions Modal handlers
  const instructionsModal = document.getElementById('tasksInstructionsModal');
  const instructionsModalContent = document.getElementById('tasksInstructionsModalContent');
  const instructionsCloseBtn = document.getElementById('tasksInstructionsModalClose');
  
  // Close instructions modal when clicking outside (on overlay)
  if (instructionsModal && instructionsModalContent) {
    instructionsModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay, not on the content
      if (e.target === instructionsModal) {
        console.log('[Tasks] Instructions modal overlay clicked');
        closeTaskInstructionsModal();
      }
    });
  }
  
  // Close button - attach handler directly (will be reattached when modal opens too)
  const attachCloseHandler = () => {
    const closeBtn = document.getElementById('tasksInstructionsModalClose');
    if (closeBtn) {
      // Create a robust close handler
      const closeHandler = (e) => {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
        console.log('[Tasks] Instructions modal Close button clicked');
        closeTaskInstructionsModal();
        return false;
      };
      
      // Remove old listeners by cloning
      const newCloseBtn = closeBtn.cloneNode(true);
      closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
      
      // Attach multiple event handlers for maximum compatibility
      newCloseBtn.addEventListener('click', closeHandler, true); // Use capture phase
      newCloseBtn.onclick = closeHandler; // Direct onclick fallback
      
      // Ensure button is enabled and clickable
      newCloseBtn.disabled = false;
      newCloseBtn.style.pointerEvents = 'auto';
      newCloseBtn.style.cursor = 'pointer';
      newCloseBtn.style.position = 'relative';
      newCloseBtn.style.zIndex = '1102';
      newCloseBtn.setAttribute('type', 'button');
      
      console.log('[Tasks] Instructions modal Close button handler attached');
      return newCloseBtn;
    }
    return null;
  };
  
  // Attach handler on initialization
  attachCloseHandler();
  
  // Also make it available globally so it can be called when modal opens
  window.attachInstructionsModalCloseHandler = attachCloseHandler;
  
  // Event delegation for "Mark Done" buttons in pending tasks container
  // Use a flag to prevent duplicate listeners
  if (!window._tasksMarkDoneHandlerAttached) {
    const pendingTasksContainer = document.getElementById('pendingTasksContainer');
    if (pendingTasksContainer) {
      pendingTasksContainer.addEventListener('click', (e) => {
        // Check if click came from a "Mark Done" button
        const markDoneBtn = e.target.closest('[data-action="mark-done"]');
        if (markDoneBtn) {
          e.preventDefault();
          e.stopPropagation();
          const category = markDoneBtn.getAttribute('data-category');
          const taskName = markDoneBtn.getAttribute('data-task-name');
          
          if (category && taskName) {
            // Open the Finish task modal (requires PIN validation)
            if (typeof openFinishTaskModal === 'function') {
              openFinishTaskModal(category, taskName);
            } else if (typeof markTaskAsDone === 'function') {
              // Fallback: mark as done directly without PIN
              markTaskAsDone(category, taskName);
            } else {
              console.error('[Tasks] Neither openFinishTaskModal nor markTaskAsDone function found');
            }
          }
        }
      });
      window._tasksMarkDoneHandlerAttached = true;
    } else {
      console.warn('[Tasks] pendingTasksContainer not found on init - will retry on render');
    }
  }
  
  // Tasks Select Modal handlers
  const selectModal = document.getElementById('tasksSelectModal');
  const selectModalContent = document.getElementById('tasksSelectModalContent');
  const selectPinInput = document.getElementById('tasksSelectPinInput');
  const selectConfirmBtn = document.getElementById('tasksSelectConfirm');
  const selectCancelBtn = document.getElementById('tasksSelectCancel');
  
  // Close select modal when clicking outside (on overlay)
  if (selectModal && selectModalContent) {
    selectModal.addEventListener('click', (e) => {
      if (e.target === selectModal) {
        closeSelectTaskModal();
      }
    });
  }
  
  // Cancel button - instantly closes the modal and clears input
  if (selectCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Clear input field
      const input = document.getElementById('tasksSelectPinInput');
      if (input) {
        input.value = '';
      }
      // Clear error message
      const error = document.getElementById('tasksSelectPinError');
      if (error) {
        error.textContent = '';
      }
      // Clear state
      taskStaffCode = '';
      // Close modal
      const taskModal = document.getElementById('tasksSelectModal');
      if (taskModal) {
        taskModal.style.display = 'none';
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    selectCancelBtn.addEventListener('click', cancelHandler);
    selectCancelBtn.onclick = cancelHandler; // Fallback direct assignment
    // Ensure button is never disabled
    selectCancelBtn.disabled = false;
    selectCancelBtn.removeAttribute('disabled');
  }
  
  // Confirm button - validates PIN and adds task to pending
  if (selectConfirmBtn) {
    // Verify function exists
    if (typeof confirmSelectTask !== 'function') {
      console.error('[Tasks] confirmSelectTask function not found');
    }
    
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Call the confirmation function
      if (typeof confirmSelectTask === 'function') {
        confirmSelectTask();
      } else {
        console.error('[Tasks] confirmSelectTask function not available');
        // Fallback: close modal
        const taskModal = document.getElementById('tasksSelectModal');
        if (taskModal) {
          taskModal.style.display = 'none';
        }
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    selectConfirmBtn.addEventListener('click', confirmHandler);
    selectConfirmBtn.onclick = confirmHandler; // Fallback direct assignment
    // Ensure button is never disabled
    selectConfirmBtn.disabled = false;
    selectConfirmBtn.removeAttribute('disabled');
  }
  
  // Input handler - updates state with numeric-only, max 4 digits
  if (selectPinInput) {
    // Handle input events - updates state with typed value
    // CRITICAL: Always keep input.value and taskStaffCode state in sync
    selectPinInput.addEventListener('input', (e) => {
      const input = e.target;
      // Keep only digits, limit to 4 characters
      let value = input.value.replace(/\D/g, '').slice(0, 4);
      
      // ALWAYS update both input value and state to keep them perfectly in sync
      input.value = value;
      taskStaffCode = value;
      
      // Clear error message when user types
      const error = document.getElementById('tasksSelectPinError');
      if (error) {
        error.textContent = '';
      }
    });
    
    // Handle paste events
    selectPinInput.addEventListener('paste', (e) => {
      e.preventDefault();
      const pastedText = (e.clipboardData || window.clipboardData).getData('text');
      const numericOnly = pastedText.replace(/\D/g, '').slice(0, 4);
      if (numericOnly) {
        selectPinInput.value = numericOnly;
        taskStaffCode = numericOnly;
        // Clear error message when user pastes
        const error = document.getElementById('tasksSelectPinError');
        if (error && error.textContent) {
          error.textContent = '';
        }
        // Trigger input event to ensure consistency
        selectPinInput.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
    
    // Enter key to confirm, Escape to close
    selectPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmSelectTask();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        closeSelectTaskModal();
      }
      // All other keys are allowed - no preventDefault() to allow normal typing
    });
  }
  
  // Tasks Finish Modal handlers
  const finishModal = document.getElementById('tasksFinishModal');
  const finishModalContent = document.getElementById('tasksFinishModalContent');
  const finishPinInput = document.getElementById('tasksFinishPinInput');
  const finishConfirmBtn = document.getElementById('tasksFinishConfirm');
  const finishCancelBtn = document.getElementById('tasksFinishCancel');
  
  // Close finish modal when clicking outside (on overlay)
  if (finishModal && finishModalContent) {
    finishModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay background, not on the content
      // Check if the click target is the modal itself (overlay) and not the content or any child
      if (e.target === finishModal && !finishModalContent.contains(e.target)) {
        closeFinishTaskModal();
      }
      // Don't stop propagation for content clicks - let buttons handle their own clicks
    });
  }
  
  // Cancel button
  if (finishCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeFinishTaskModal();
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    finishCancelBtn.addEventListener('click', cancelHandler); // Fallback direct assignment
    // Ensure button is never disabled
    finishCancelBtn.disabled = false;
    finishCancelBtn.removeAttribute('disabled');
    finishCancelBtn.style.pointerEvents = 'auto';
    finishCancelBtn.style.cursor = 'pointer';
  }
  
  // Confirm button - validates PIN and marks task as done
  if (finishConfirmBtn) {
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof confirmFinishTask === 'function') {
        confirmFinishTask();
      } else {
        console.error('[Tasks] confirmFinishTask function not found');
        // Fallback: close modal
        closeFinishTaskModal();
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    finishConfirmBtn.addEventListener('click', confirmHandler);
    // Ensure button is never disabled
    finishConfirmBtn.disabled = false;
    finishConfirmBtn.removeAttribute('disabled');
    finishConfirmBtn.style.pointerEvents = 'auto';
    finishConfirmBtn.style.cursor = 'pointer';
  }
  
  // Enter key to confirm
  if (finishPinInput) {
    finishPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        confirmFinishTask();
      } else if (e.key === 'Escape') {
        closeFinishTaskModal();
      }
    });
  }
  
  // Tasks Reset Modal handlers
  const resetModal = document.getElementById('tasksResetModal');
  const resetModalContent = document.getElementById('tasksResetModalContent');
  const resetPinInput = document.getElementById('tasksResetPinInput');
  const resetConfirmBtn = document.getElementById('tasksResetConfirm');
  const resetCancelBtn = document.getElementById('tasksResetCancel');
  
  // Close reset modal when clicking outside (on overlay)
  if (resetModal && resetModalContent) {
    // Remove any existing listeners first
    const newResetModal = resetModal.cloneNode(true);
    resetModal.parentNode.replaceChild(newResetModal, resetModal);
    const freshResetModal = document.getElementById('tasksResetModal');
    const freshResetModalContent = document.getElementById('tasksResetModalContent');
    
    if (freshResetModal && freshResetModalContent) {
      freshResetModal.addEventListener('click', (e) => {
        // Only close if clicking directly on the overlay background, not on the content
        // Check if the click target is the modal itself (overlay) and not the content or any child
        if (e.target === freshResetModal && !freshResetModalContent.contains(e.target)) {
          closeTasksResetModal();
        }
        // Don't stop propagation for content clicks - let buttons handle their own clicks
      });
    }
  }
  
  // Cancel button
  if (resetCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeTasksResetModal();
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    resetCancelBtn.addEventListener('click', cancelHandler); // Fallback direct assignment
    // Ensure button is never disabled
    resetCancelBtn.disabled = false;
    resetCancelBtn.removeAttribute('disabled');
    resetCancelBtn.style.pointerEvents = 'auto';
    resetCancelBtn.style.cursor = 'pointer';
  }
  
  // Confirm button - validates PIN and resets tasks
  if (resetConfirmBtn) {
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof confirmTasksReset === 'function') {
        confirmTasksReset();
      } else {
        console.error('[Tasks] confirmTasksReset function not found');
        // Fallback: close modal
        closeTasksResetModal();
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    resetConfirmBtn.addEventListener('click', confirmHandler);
    // Ensure button is never disabled
    resetConfirmBtn.disabled = false;
    resetConfirmBtn.removeAttribute('disabled');
    resetConfirmBtn.style.pointerEvents = 'auto';
    resetConfirmBtn.style.cursor = 'pointer';
  }
  
  // Enter key to confirm
  if (resetPinInput) {
    resetPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        confirmTasksReset();
      } else if (e.key === 'Escape') {
        closeTasksResetModal();
      }
    });
  }
  
  // Make renderTasks and renderPendingTasks globally available
  window.renderTasks = renderTasks;
  window.renderPendingTasks = renderPendingTasks;
  // Make task functions globally available
  window.openFinishTaskModal = openFinishTaskModal;
  window.markTaskAsDone = markTaskAsDone;
  window.confirmFinishTask = confirmFinishTask;
  
  // Render initial tasks and pending tasks
  renderTasks();
  renderPendingTasks();
}

// Add Technician dialog functions

function openAddTechDialog(){
  if (reorderMode) {
    console.log("Add technician clicked in reorder mode");
  } else {
    console.log("Add technician clicked");
  }
  
  const addTechDlg = document.getElementById('addTechDlg');

  const addTechSelect = document.getElementById('addTechSelect');

  const addTechConfirm = document.getElementById('addTechConfirm');

  if (!addTechDlg || !addTechSelect) return;

  

  // Clear and populate select with technicians not already in queue

  addTechSelect.innerHTML = '<option value="">-- Select technician --</option>';

  

  const availableNames = new Set(queue.map(q => q.name).concat(service.map(s => s.name)));

  const options = [];

  settings.workers.forEach(w => {

    if (!availableNames.has(w.name)) {

      const opt = document.createElement('option');

      opt.value = w.name;

      opt.textContent = w.name;

      addTechSelect.appendChild(opt);
      options.push(w.name);

    }

  });

  // Log technician options for debugging
  console.log("technician options", options);

  

  // CRITICAL: Ensure select dropdown is fully interactive
  // Remove any disabled state
  addTechSelect.disabled = false;
  addTechSelect.removeAttribute('disabled');
  
  // Ensure pointer events are enabled
  addTechSelect.style.pointerEvents = 'auto';
  addTechSelect.style.cursor = 'pointer';
  addTechSelect.style.zIndex = '1001'; // Above dialog backdrop
  addTechSelect.style.position = 'relative';
  
  // Ensure the select is not blocked by any overlay
  const selectParent = addTechSelect.closest('dialog, .code-dialog');
  if (selectParent) {
    selectParent.style.zIndex = '1000';
    selectParent.style.pointerEvents = 'auto';
  }

  // Disable Add button initially

  if (addTechConfirm) addTechConfirm.disabled = true;

  

  // Enable/disable Add button based on selection

  addTechSelect.onchange = () => {

    if (addTechConfirm) addTechConfirm.disabled = !addTechSelect.value;

  };

  

  addTechDlg.showModal();
  
  // After modal is shown, ensure select and buttons are interactive
  setTimeout(() => {
    if (addTechSelect) {
      addTechSelect.style.pointerEvents = 'auto';
      addTechSelect.style.cursor = 'pointer';
      addTechSelect.disabled = false;
      addTechSelect.removeAttribute('disabled');
      console.log('[AddTech] Select dropdown enabled and ready');
    }
    
    // Re-setup button handlers after modal opens to ensure they work
    setupAddTechnicianButtons();
    
    // Ensure buttons are interactive
    const cancelBtn = document.getElementById('addTechCancel');
    const confirmBtn = document.getElementById('addTechConfirm');
    if (cancelBtn) {
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
    }
    if (confirmBtn) {
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = confirmBtn.disabled ? 'not-allowed' : 'pointer';
      // Don't override disabled state, but ensure pointer events if enabled
      if (!confirmBtn.disabled) {
        confirmBtn.style.pointerEvents = 'auto';
      }
    }
    console.log('[AddTech] Buttons enabled and ready');
  }, 50);

}

function addTechnicianToQueue(){
  const addTechSelect = document.getElementById('addTechSelect');
  const addTechDlg = document.getElementById('addTechDlg');
  const name = addTechSelect ? addTechSelect.value : '';

  console.log("Add technician clicked", name || 'none');
  
  if (!name) {
    console.log("Add technician: No technician selected");
    return;
  }

  

  // Check if already in queue (shouldn't happen due to filtering, but safety check)

  if (queue.some(x => x.name === name) || service.some(x => x.name === name)) {

    alert('This technician is already active');

    return;

  }

  

  // Add to end of queue

  queue.push({name, held: false});

  log.unshift(stamp() + ` REORDER: ADD ${name} BY MANAGER`);

  save();

  renderQueue();

  addTechDlg.close();

  // Add technician is done in reorder mode which requires manager/admin code
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const actorName = window.__ff_actorName || 'Manager';
    actor = { role, name: actorName };
  }
  addHistoryEntry('Add technician to queue', actor, name);

}

// Bind Add Technician button and dialog buttons
function setupAddTechnicianButtons() {
  const addTechBtn = document.getElementById('addTechBtn');
  const addTechCancel = document.getElementById('addTechCancel');
  const addTechConfirm = document.getElementById('addTechConfirm');

  if (addTechBtn) addTechBtn.onclick = openAddTechDialog;

  // Cancel button handler with logging
  if (addTechCancel) {
    addTechCancel.onclick = (e) => {
      console.log("Cancel add technician clicked");
      e.preventDefault();
      e.stopPropagation();
      const dlg = document.getElementById('addTechDlg');
      if (dlg) {
        dlg.close();
      }
    };
    // Ensure button is interactive
    addTechCancel.style.pointerEvents = 'auto';
    addTechCancel.style.cursor = 'pointer';
  }

  // Add button handler with logging
  if (addTechConfirm) {
    addTechConfirm.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      addTechnicianToQueue();
    };
    // Ensure button is interactive
    addTechConfirm.style.pointerEvents = 'auto';
    addTechConfirm.style.cursor = 'pointer';
  }
}

// Initialize buttons on page load
const addTechBtn = document.getElementById('addTechBtn');
const addTechCancel = document.getElementById('addTechCancel');
const addTechConfirm = document.getElementById('addTechConfirm');

if (addTechBtn) addTechBtn.onclick = openAddTechDialog;
setupAddTechnicianButtons();

const eye=$("#togglePin");

eye.addEventListener("mousedown",()=>{ pinInput.type="text"; });

eye.addEventListener("touchstart",()=>{ pinInput.type="text"; },{passive:true});

const hide=()=>{ pinInput.type="password"; };

eye.addEventListener("mouseup",hide); eye.addEventListener("mouseleave",hide); eye.addEventListener("touchend",hide);



// Save

function save(){ ls("ffv24_settings",settings); ls("ffv24_queue",queue); ls("ffv24_service",service); ls("ffv24_log",log); syncWorkersToUsers(); }

// Sync workers to both ffv24_users and ff_users_v1 storage keys
function syncWorkersToUsers() {
  try {
    // Get all valid workers (with name and pin)
    const validWorkers = (settings.workers || []).filter(w => w && w.name && w.name.trim() && w.pin);
    
    // Initialize ff_users_v1 if it doesn't exist
    let ffUsers = JSON.parse(localStorage.getItem('ff_users_v1') || '[]');
    if (!Array.isArray(ffUsers)) {
      ffUsers = [];
    }
    
    // Initialize ffv24_users if it doesn't exist
    let ffv24Users = JSON.parse(localStorage.getItem('ffv24_users') || '[]');
    if (!Array.isArray(ffv24Users)) {
      ffv24Users = [];
    }
    
    // Process each worker
    validWorkers.forEach(worker => {
      const workerName = worker.name.trim();
      const workerPin = (worker.pin || '').toString();
      
      // Generate userId (use name as userId, or create unique ID)
      const userId = workerName.toLowerCase().replace(/\s+/g, '_');
      
      // Create user object in the format expected by Tasks screen
      const userObj = {
        userId: userId,
        displayName: workerName,
        pin: workerPin,
        pinHash: workerPin // For now, use PIN as hash (can be enhanced later)
      };
      
      // Check if user already exists in ff_users_v1 (by userId or displayName)
      const existingIndex = ffUsers.findIndex(u => 
        (u.userId && u.userId === userId) || 
        (u.displayName && u.displayName === workerName)
      );
      
      if (existingIndex >= 0) {
        // Update existing user
        ffUsers[existingIndex] = userObj;
      } else {
        // Add new user
        ffUsers.push(userObj);
      }
      
      // Same for ffv24_users
      const existingIndex24 = ffv24Users.findIndex(u => 
        (u.userId && u.userId === userId) || 
        (u.displayName && u.displayName === workerName)
      );
      
      if (existingIndex24 >= 0) {
        // Update existing user
        ffv24Users[existingIndex24] = userObj;
      } else {
        // Add new user
        ffv24Users.push(userObj);
      }
    });
    
    // Remove users that no longer exist in settings.workers
    const validNames = new Set(validWorkers.map(w => w.name.trim()));
    ffUsers = ffUsers.filter(u => validNames.has(u.displayName));
    ffv24Users = ffv24Users.filter(u => validNames.has(u.displayName));
    
    // Save to both storage keys
    localStorage.setItem('ff_users_v1', JSON.stringify(ffUsers));
    localStorage.setItem('ffv24_users', JSON.stringify(ffv24Users));
    
    console.log('[syncWorkersToUsers] Synced', validWorkers.length, 'workers to ff_users_v1 and ffv24_users');
  } catch (e) {
    console.error('[syncWorkersToUsers] Error syncing workers:', e);
  }
}



// Init

function seedOnce(){

  if(!ls("ffv24_seeded")){

    queue.push({name:"Daniel",held:false});

    ls("ffv24_seeded",true); save();

  }

}

function init(){ 
  console.log('[init] Starting initialization...');
  
  // Get elements fresh
  const pinEl = document.getElementById("pinInput") || pinInput;
  const nameSelectEl = document.getElementById("nameSelect") || nameSelect;
  
  if (!pinEl) {
    console.error('[init] pinInput not found, DOM may not be ready');
    return;
  }
  
  if (!nameSelectEl) {
    console.error('[init] nameSelect not found, DOM may not be ready');
    // Try again after delay
    setTimeout(init, 200);
    return;
  }
  
  console.log('[init] Elements found, proceeding...');
  
  pinEl.type="password";

  // Ensure settings.workers is populated
  if (!settings.workers || !Array.isArray(settings.workers) || settings.workers.length === 0) {
    console.warn('[init] settings.workers is missing or empty, initializing from defaults');
    if (DEFAULTS.workers && Array.isArray(DEFAULTS.workers) && DEFAULTS.workers.length > 0) {
      settings.workers = DEFAULTS.workers.map(w => ({...w})); // Deep copy
      save();
      console.log('[init] Initialized', settings.workers.length, 'workers from defaults');
    }
  } else {
    console.log('[init] Found', settings.workers.length, 'workers in settings');
  }

  try {
    renderBrand(); 
    renderSelect(); 
    renderQueue(); 
    renderService(); 
    seedOnce();
    console.log('[init] Initialization complete');
  } catch (error) {
    console.error('[init] Error during initialization:', error);
  }
}

// Expose functions globally for app.js to call
window.renderSelect = renderSelect;
window.init = init;

// Ensure DOM is ready before calling init
if (document.readyState === 'loading') {
  console.log('[init] DOM is loading, waiting for DOMContentLoaded');
  document.addEventListener('DOMContentLoaded', () => {
    console.log('[init] DOMContentLoaded fired');
    setTimeout(init, 100); // Small delay to ensure all scripts are loaded
  });
} else {
  // DOM is already ready
  console.log('[init] DOM already ready, calling init');
  setTimeout(init, 100); // Small delay to ensure all scripts are loaded
}

// Also try to render when owner-view becomes visible (observer pattern)
if (!window.__uiObserver) {
  window.__uiObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
        const ownerView = document.getElementById("owner-view");
        if (ownerView && ownerView.style.display === 'block') {
          console.log('[Observer] owner-view became visible, calling renderSelect');
          setTimeout(() => {
            if (typeof renderSelect === 'function') {
              renderSelect();
            }
          }, 200);
        }
      }
    });
  });
}

// Start observing when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const ownerView = document.getElementById("owner-view");
    if (ownerView && window.__uiObserver) {
      window.__uiObserver.observe(ownerView, { attributes: true, attributeFilter: ['style'] });
    }
  });
} else {
  const ownerView = document.getElementById("owner-view");
  if (ownerView && window.__uiObserver) {
    window.__uiObserver.observe(ownerView, { attributes: true, attributeFilter: ['style'] });
  }
}



async function openSettings_DISABLED(){

  const code = await securePrompt("Enter admin code","password");

  if(!code) return;

  const saved = getState().adminCode || "";

  if(saved && code !== saved) { alert("Wrong admin code"); return; }

  document.getElementById("settingsModal").style.display="block";

}





const DEFAULT_SWATCHES = ['#FFF833','#FF7566','#66AFEA','#70F090']; // blue, red, green, yellow

function renderQuickColors(container, onPick){

  const wrap = document.createElement("div"); wrap.className="quick-colors";

  DEFAULT_SWATCHES.forEach(c=>{

    const b = document.createElement("button"); b.style.background=c;

    b.onclick=()=> onPick(c);

    wrap.appendChild(b);

  });

  container.parentNode.insertBefore(wrap, container);

}



function globalEscapeClose(e){

  if(e.key!=="Escape") return;

  const sp = document.getElementById("securePromptOverlay");

  if(sp && sp.style.display!=="none"){ sp.style.display="none"; sp.style.pointerEvents="none"; }

  const sm = document.getElementById("settingsModal");

  if(sm && sm.style.display!=="none"){ sm.style.display="none"; }

}

document.addEventListener("keydown", globalEscapeClose);



function hookSettingsGuard_DISABLED(){

  // Try common selectors

  const btns = Array.from(document.querySelectorAll('button, a')).filter(b => /\bSettings\b/i.test(b.textContent || ''));

  if(!btns.length) return;

  btns.forEach(btn => {

    const orig = btn.onclick;

    btn.onclick = async (ev)=>{

      ev?.preventDefault?.();

      const code = await window.securePromptOnce('Enter admin code');

      if(code==null) return;

      // Existing admin check logic uses native prompt in code; we replicate minimal acceptance here:

      try{

        // Try to call original (if it uses internal checks it will still run)

        if(orig) return orig.call(btn, ev);

        // Fallback: open settings modal if exists

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }catch(e){

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }

    };

  });

}

/* disabled hookSettingsGuard */

</script>





<!-- Lightweight password prompt (no layout changes elsewhere) -->

<div id="codePromptOverlay" class="code-dialog" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1100;align-items:center;justify-content:center;">

  <div style="background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:20px;min-width:280px;max-width:90%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">

    <div id="codePromptMsg" style="font-weight:600;margin-bottom:10px">Enter code</div>

    <div style="display:flex;gap:8px;align-items:center">

      <input id="codePromptInput" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" style="flex:1;padding:10px 12px;border:1px solid #ddd;border-radius:8px;font-size:16px" />

      <button id="codePromptEye" aria-label="Show" style="border:1px solid #ddd;background:#fff;border-radius:8px;padding:8px 10px;cursor:pointer">ğŸ‘ï¸</button>

    </div>

    <div style="text-align:center;margin-top:8px;margin-bottom:4px;">
      <button id="codePromptForgotPin" type="button" style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;font-size:12px;padding:4px 8px;">Forgot Admin PIN?</button>
    </div>

    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">

      <button id="codePromptCancel" style="padding:8px 14px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Cancel</button>

      <button id="codePromptOk" style="padding:8px 14px;border-radius:8px;border:0;background:#111;color:#fff;cursor:pointer">OK</button>

    </div>

  </div>

</div>

<!-- RESET Confirmation Modal (Step 1) -->
<div id="resetConfirmOverlay" class="code-dialog" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1100;align-items:center;justify-content:center;">

  <div style="background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:20px;min-width:280px;max-width:90%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">

    <div id="resetConfirmMsg" style="font-weight:600;margin-bottom:16px;font-size:16px;text-align:center;">Are you sure you want to RESET THE DAY?</div>

    <div style="font-size:14px;color:#666;margin-bottom:20px;text-align:center;">This will clear all queues. History will NOT be deleted.</div>

    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">

      <button id="resetConfirmCancel" style="padding:8px 14px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Cancel</button>

      <button id="resetConfirmContinue" style="padding:8px 14px;border-radius:8px;border:0;background:#111;color:#fff;cursor:pointer">Continue</button>

    </div>

  </div>

</div>

<script>

(function(){

  const ov = document.getElementById("codePromptOverlay");

  const msg = document.getElementById("codePromptMsg");

  const input = document.getElementById("codePromptInput");

  const btnOk = document.getElementById("codePromptOk");

  const btnCancel = document.getElementById("codePromptCancel");

  const eye = document.getElementById("codePromptEye");

  let resolver = null;

  function show(m){

    msg.textContent = m || "Enter code";

    input.value = "";

    input.type = "password";

    ov.style.display = "flex";
    ov.style.pointerEvents = "auto";
    ov.style.visibility = "visible";
    ov.style.pointerEvents = "auto";
    ov.style.visibility = "visible";

    setTimeout(()=>input.focus(), 50);

    return new Promise((res)=>{ resolver = res; });

  }

  function hide(){ 
    ov.style.display = "none"; 
    ov.style.pointerEvents = "none";
    ov.style.visibility = "hidden";
  }

  btnOk.onclick = ()=>{ const v = input.value; hide(); resolver && resolver(v); };

  btnCancel.onclick = ()=>{ hide(); resolver && resolver(null); };

  eye.onmousedown = ()=>{ 
    // Toggle between password (hidden) and text (visible)
    input.type = (input.type === "password") ? "text" : "password";
  };

  eye.onmouseup = eye.onmouseleave = ()=>{ input.type="password"; };

  // Helper function to show toast messages
  function showToast(message, duration = 3000) {
    // Create toast element if it doesn't exist
    let toast = document.getElementById('admin-pin-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.id = 'admin-pin-toast';
      toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:12px 20px;border-radius:8px;font-size:14px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
      document.body.appendChild(toast);
    }
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => {
      toast.style.display = 'none';
    }, duration);
  }

  // Forgot Admin PIN button - generates PIN reset link
  // This replaces any previous Firebase password reset mechanism
  const forgotPinBtn = document.getElementById("codePromptForgotPin");
  if (forgotPinBtn) {
    forgotPinBtn.onclick = async (event) => {
      event.preventDefault(); // Stop any default action
      
      // Clear any previous error message
      const existingError = document.getElementById('codePromptError');
      if (existingError) {
        existingError.remove();
      }
      
      // Disable button to prevent multiple clicks
      forgotPinBtn.disabled = true;
      const originalText = forgotPinBtn.textContent;
      forgotPinBtn.textContent = 'Sending...';
      
      // Optional: Hide the PIN entry modal temporarily and show a loading message
      // Show non-blocking loading message
      const loadingMsg = document.createElement('div');
      loadingMsg.id = 'codePromptLoading';
      loadingMsg.style.cssText = 'color:#666;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;font-style:italic;';
      loadingMsg.textContent = 'Sending PIN reset link. Please wait...';
      
      // Insert loading message after the button
      const forgotPinContainer = forgotPinBtn.parentElement;
      if (forgotPinContainer && forgotPinContainer.parentElement) {
        forgotPinContainer.parentElement.insertBefore(loadingMsg, forgotPinContainer.nextSibling);
      }
      
      try {
        // Ensure Firebase Functions SDK is available
        if (!window.generatePinResetLink || typeof window.generatePinResetLink !== 'function') {
          throw new Error('Reset functionality is not available. Please refresh the page and try again.');
        }
        
        // Call the Cloud Function to generate reset link
        // Note: salonId is retrieved from the authenticated user's document by the Cloud Function
        const result = await window.generatePinResetLink();
        
        // Remove loading message
        const loadingMsg = document.getElementById('codePromptLoading');
        if (loadingMsg) {
          loadingMsg.remove();
        }
        
        // Success feedback - The function returns a message like "reset link sent successfully"
        const successMessage = result?.data?.message || 'Admin PIN reset link sent successfully to your email.';
        
        // Close the modal to prevent confusion
        hide();
        
        // Show success alert
        alert('Success! ' + successMessage);
        
        // Optionally show success modal (if you want a more polished UI)
        // showPinResetSuccessDialog();
        
      } catch (error) {
        console.error('[AdminPIN] Error requesting PIN reset:', error);
        
        // Remove loading message
        const loadingMsg = document.getElementById('codePromptLoading');
        if (loadingMsg) {
          loadingMsg.remove();
        }
        
        // Re-enable button
        forgotPinBtn.disabled = false;
        forgotPinBtn.textContent = originalText;
        
        // Display user-friendly error message based on the Cloud Function error type
        let errorMessage = 'Could not send reset link. ';
        
        if (error.code === 'unauthenticated') {
          errorMessage = 'Please log in to request a PIN reset.';
        } else if (error.code === 'failed-precondition') {
          errorMessage = 'Your account is not associated with a business. Please contact support.';
        } else if (error.code === 'internal') {
          errorMessage = 'Server error occurred. Please try again later or contact support.';
        } else if (error.message) {
          errorMessage = error.message;
        } else {
          errorMessage += 'Please try again or contact support.';
        }
        
        // Show error alert
        alert('Error: ' + errorMessage);
        
        // Also show error message in the dialog (if modal is still open)
        const errorMsg = document.createElement('div');
        errorMsg.id = 'codePromptError';
        errorMsg.style.cssText = 'color:#dc2626;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;';
        errorMsg.textContent = errorMessage;
        
        // Insert error message after the "Forgot Admin PIN?" button container
        const forgotPinContainer = forgotPinBtn.parentElement;
        if (forgotPinContainer && forgotPinContainer.parentElement) {
          forgotPinContainer.parentElement.insertBefore(errorMsg, forgotPinContainer.nextSibling);
        }
      }
    };
  }
  
  // Show PIN reset success dialog
  function showPinResetSuccessDialog() {
    const modal = document.getElementById('pinResetSuccessModal');
    if (modal) {
      modal.style.display = 'flex';
    }
  }

  window.securePromptOnce = show; // expose

})();

// PIN Reset Success Modal handler
(function() {
  const modal = document.getElementById('pinResetSuccessModal');
  const closeBtn = document.getElementById('pinResetSuccessClose');
  
  if (closeBtn) {
    closeBtn.onclick = () => {
      if (modal) modal.style.display = 'none';
    };
  }
  
  // Close on overlay click
  if (modal) {
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
      }
    };
  }
})();

// =====================
// Reset Admin PIN Page Handler
// =====================
(function() {
  // Check URL for reset token on page load
  function checkResetToken() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (token) {
      // Show reset page
      const resetSection = document.getElementById('reset-admin-pin-section');
      const loginSection = document.getElementById('login-section');
      const signupSection = document.getElementById('signup-section');
      const mainApp = document.getElementById('main-app-content');
      
      if (resetSection) {
        // Hide other sections
        if (loginSection) loginSection.style.display = 'none';
        if (signupSection) signupSection.style.display = 'none';
        if (mainApp) mainApp.style.display = 'none';
        resetSection.style.display = 'block';
        
        // Verify token
        verifyResetToken(token);
      }
    }
  }
  
  // Verify reset token
  async function verifyResetToken(token) {
    const statusEl = document.getElementById('reset-pin-status');
    const formEl = document.getElementById('reset-pin-form');
    const errorStateEl = document.getElementById('reset-pin-error-state');
    const errorMsgEl = document.getElementById('reset-pin-error-message');
    
    try {
      if (window.verifyAdminPinResetToken && typeof window.verifyAdminPinResetToken === 'function') {
        const result = await window.verifyAdminPinResetToken(token);
        if (result.success) {
          // Token is valid, show form
          if (statusEl) statusEl.textContent = 'Enter your new admin PIN below.';
          if (formEl) formEl.style.display = 'block';
          if (errorStateEl) errorStateEl.style.display = 'none';
          
          // Store token for later use
          window.__resetToken = token;
        } else {
          throw new Error('Invalid token');
        }
      } else {
        throw new Error('Reset functionality not available');
      }
    } catch (error) {
      console.error('[AdminPIN] Error verifying token:', error);
      if (statusEl) statusEl.style.display = 'none';
      if (formEl) formEl.style.display = 'none';
      if (errorStateEl) errorStateEl.style.display = 'block';
      if (errorMsgEl) {
        errorMsgEl.textContent = 'This reset link is invalid or has expired. Please click "Forgot Admin PIN?" again to receive a new link.';
      }
    }
  }
  
  // Handle form submission
  function setupResetForm() {
    const submitBtn = document.getElementById('reset-pin-submit');
    const cancelBtn = document.getElementById('reset-pin-cancel');
    const closeBtn = document.getElementById('reset-pin-close');
    const tryAgainBtn = document.getElementById('reset-pin-try-again');
    const newPinInput = document.getElementById('reset-pin-new');
    const confirmPinInput = document.getElementById('reset-pin-confirm');
    const errorEl = document.getElementById('reset-pin-error');
    const formEl = document.getElementById('reset-pin-form');
    const successEl = document.getElementById('reset-pin-success');
    const errorStateEl = document.getElementById('reset-pin-error-state');
    
    if (submitBtn) {
      submitBtn.onclick = async () => {
        const newPin = newPinInput ? newPinInput.value.trim() : '';
        const confirmPin = confirmPinInput ? confirmPinInput.value.trim() : '';
        
        // Clear previous errors
        if (errorEl) errorEl.textContent = '';
        
        // Validation
        if (!newPin || !confirmPin) {
          if (errorEl) errorEl.textContent = 'Please enter both PIN fields.';
          return;
        }
        
        if (newPin.length < 4 || newPin.length > 6) {
          if (errorEl) errorEl.textContent = 'PIN must be 4-6 digits.';
          return;
        }
        
        if (!/^\d+$/.test(newPin) || !/^\d+$/.test(confirmPin)) {
          if (errorEl) errorEl.textContent = 'PIN must contain only numbers.';
          return;
        }
        
        if (newPin !== confirmPin) {
          if (errorEl) errorEl.textContent = 'PINs do not match.';
          return;
        }
        
        // Submit
        const token = window.__resetToken;
        if (!token) {
          if (errorEl) errorEl.textContent = 'Reset token is missing. Please request a new link.';
          return;
        }
        
        try {
          if (window.confirmPinReset && typeof window.confirmPinReset === 'function') {
            await window.confirmPinReset(token, newPin);
            
            // Success - show success message
            if (formEl) formEl.style.display = 'none';
            if (errorStateEl) errorStateEl.style.display = 'none';
            if (successEl) successEl.style.display = 'block';
            
            // Clear admin PIN cache
            if (window.clearAdminPinCache && typeof window.clearAdminPinCache === 'function') {
              window.clearAdminPinCache();
            }
          } else {
            throw new Error('Reset functionality not available');
          }
        } catch (error) {
          console.error('[AdminPIN] Error confirming reset:', error);
          if (errorEl) {
            errorEl.textContent = error.message || 'Failed to reset PIN. Please try again.';
          }
        }
      };
    }
    
    if (cancelBtn) {
      cancelBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
    
    if (closeBtn) {
      closeBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
    
    if (tryAgainBtn) {
      tryAgainBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      checkResetToken();
      setupResetForm();
    });
  } else {
    checkResetToken();
    setupResetForm();
  }
})();



function hookSettingsGuard_DISABLED(){

  // Try common selectors

  const btns = Array.from(document.querySelectorAll('button, a')).filter(b => /\bSettings\b/i.test(b.textContent || ''));

  if(!btns.length) return;

  btns.forEach(btn => {

    const orig = btn.onclick;

    btn.onclick = async (ev)=>{

      ev?.preventDefault?.();

      const code = await window.securePromptOnce('Enter admin code');

      if(code==null) return;

      // Existing admin check logic uses native prompt in code; we replicate minimal acceptance here:

      try{

        // Try to call original (if it uses internal checks it will still run)

        if(orig) return orig.call(btn, ev);

        // Fallback: open settings modal if exists

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }catch(e){

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }

    };

  });

}

/* disabled hookSettingsGuard */

</script>









<script id="ensure-eyes">

(function(){

  function isInsideSecurePrompt(el){

    if(!el || !el.closest) return false;
    
    // Skip if inside any code dialog (secure prompt, history modal, etc.)
    return !!(el.closest('#codePromptOverlay') || el.closest('.code-dialog'));

  }

  function hasAnyEye(el){

    if(!el || !el.parentElement) return false;

    // existing sibling button with eye text OR data-eye attr

    const sibs = el.parentElement.querySelectorAll('button, .eye, [data-eye]');

    for(const b of sibs){

      const t = (b.textContent||'').trim();

      if(t==='ğŸ‘' || b.dataset.eye!==undefined || b.classList.contains('eye')) return true;

    }

    return false;

  }

  function bind(btn, input){

    if(!btn || !input || btn.dataset.bound==='1') return;

    btn.addEventListener('click', ()=>{

      input.type = (input.type==='password') ? 'text' : 'password';

    });

    btn.dataset.bound='1';

  }

  function addEye(input){

    if(!input) return;

    if(input.id==='pinInput') return;              // JOIN bar has its own eye

    if(isInsideSecurePrompt(input)) return;        // skip secure prompt modal entirely

    if(input.dataset.hasEye==='1') return;

    if(hasAnyEye(input)){                          // if an eye already exists nearby, just bind it

      const found = input.parentElement.querySelector('button, .eye, [data-eye]');

      if(found) bind(found, input);

      input.dataset.hasEye='1';

      return;

    }

    // create a new minimal eye button

    const btn = document.createElement('button');

    btn.type='button'; btn.className='btn-mini ai-eye-button'; btn.textContent='ğŸ‘';

    btn.style.marginLeft='6px';

    bind(btn, input);

    input.insertAdjacentElement('afterend', btn);

    input.dataset.hasEye='1';

  }

  function sweep(root){

    (root||document).querySelectorAll('input[type="password"]').forEach(addEye);

  }

  document.addEventListener('DOMContentLoaded', ()=>sweep(document));

  document.addEventListener('ff:settings-rendered', ()=>{

    const dlg=document.getElementById('settingsDlg'); if(dlg) sweep(dlg);

  });

})();

</script>





<!-- Show Log: secure code input (hidden + single eye) wrapper only -->

<script>

(function(){

  if (typeof window.openLog !== 'function') return; // keep everything if not found

  const __origOpenLog = window.openLog;

  window.openLog = async function(){

    // Prefer existing securePromptOnce if available (hidden field + eye)

    if (window.securePromptOnce) {

      const code = await window.securePromptOnce("Enter admin code to view log");

      if (code == null) return;

      try {

        if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert("Admin only"); return; }

      } catch(e) { /* if check not available, don't block original */ }

      return __origOpenLog();

    }

    // Fallback tiny modal (hidden password + single eye)

    const ov = document.createElement('div');

    ov.style.cssText="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:99999";

    ov.innerHTML = `<div style="background:#fff;border-radius:14px;box-shadow:0 20px 70px rgba(0,0,0,.2);width:min(460px,92vw);padding:18px;font-family:inherit">
      <div style="font:600 18px/1.3 inherit;margin-bottom:10px">Enter admin code</div>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">
        <input id="__log_code" type="password" autocomplete="off" style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font:16px inherit"/>
        <button id="__log_eye" type="button" aria-label="toggle" style="border:0;border-radius:10px;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer">ğŸ‘ï¸</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="__log_cancel" style="border:0;border-radius:10px;padding:9px 14px;background:#eee;font:600 14px inherit">Cancel</button>
        <button id="__log_ok" style="border:0;border-radius:10px;padding:9px 14px;background:#111;color:#fff;font:600 14px inherit">OK</button>
      </div></div>`;

    document.body.appendChild(ov);

    const inp = ov.querySelector('#__log_code');

    ov.querySelector('#__log_eye').onclick = ()=>{ inp.type = (inp.type==='password')?'text':'password'; };

    ov.querySelector('#__log_cancel').onclick = ()=>{ document.body.removeChild(ov); };

    ov.querySelector('#__log_ok').onclick = ()=>{

      const code = (inp.value||"").toString();

      try {

        if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert("Admin only"); return; }

      } catch(e) { /* ignore */ }

      document.body.removeChild(ov);

      __origOpenLog();

    };

    inp.focus();

  };

})();

</script>



<script>

// --- injected: secure show log ---

(function(){

  if (window.__logSecurePatched) return;

  window.__logSecurePatched = true;



  // inject styles

  const style = document.createElement('style');

  style.id = 'log-secure-style';

  style.textContent = ` /* --- Show Log secure modal (injected) --- */ #log-secure-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:99999} #log-secure{background:#fff;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:22px;min-width:360px;font-family:inherit} #log-secure h3{margin:0 0 12px;font-size:18px;font-weight:600} #log-secure .row{display:flex;gap:8px;align-items:center;margin:10px 0 18px} #log-secure input[type="password"],#log-secure input[type="text"]{flex:1;border:2px solid #111;border-radius:10px;padding:12px 40px 12px 12px;font-size:16px;outline:none} #log-secure .eye{width:38px;height:38px;border:1px solid #ddd;border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer} #log-secure .actions{display:flex;gap:10px;justify-content:flex-end} #log-secure button{border:none;border-radius:10px;padding:10px 16px;font-size:16px;cursor:pointer} #log-secure .ok{background:#111;color:#fff} #log-secure .cancel{background:#eee} `;

  document.head.appendChild(style);



  // inject html

  const wrap = document.createElement('div');

  wrap.innerHTML = ` <div id=\"log-secure-overlay\" class=\"code-dialog\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"log-secure-title\">   <div id=\"log-secure\">     <h3 id=\"log-secure-title\">Enter admin/manager code to view log</h3>     <div class=\"row\">       <input id=\"log-secure-input\" type=\"password\" autocomplete=\"off\" inputmode=\"numeric\" />       <div id=\"log-secure-eye\" class=\"eye\" title=\"Show/Hide\">ğŸ‘ï¸</div>     </div>     <div class=\"actions\">       <button class=\"cancel\" id=\"log-secure-cancel\">Cancel</button>       <button class=\"ok\" id=\"log-secure-ok\">OK</button>     </div>   </div> </div> `;

  document.body.appendChild(wrap.firstElementChild);



  function openSecurePrompt(){ 

    return new Promise((resolve,reject)=>{

      const ov = document.getElementById('log-secure-overlay');

      const inp = document.getElementById('log-secure-input');

      const eye = document.getElementById('log-secure-eye');

      const ok = document.getElementById('log-secure-ok');

      const cancel = document.getElementById('log-secure-cancel');

      ov.style.display = 'flex';
      ov.style.pointerEvents = 'auto';
      ov.style.visibility = 'visible';

      inp.value='';

      inp.type='password';

      setTimeout(()=>inp.focus(), 0);

      const close = () => { 
        ov.style.display='none'; 
        ov.style.pointerEvents='none';
        ov.style.visibility='hidden';
        handlers(false); 
      };

      const handlers = (on)=>{

        if(on){

          eye.addEventListener('click', toggle);

          cancel.addEventListener('click', onCancel);

          ok.addEventListener('click', onOk);

          inp.addEventListener('keydown', onKey);

        } else {

          eye.removeEventListener('click', toggle);

          cancel.removeEventListener('click', onCancel);

          ok.removeEventListener('click', onOk);

          inp.removeEventListener('keydown', onKey);

        }

      };

      function toggle(){

        inp.type = (inp.type==='password') ? 'text' : 'password';

      }

      function onCancel(){ close(); reject(new Error('cancel')); }

      function onOk(){ const v=inp.value.trim(); close(); resolve(v); }

      function onKey(e){ if(e.key==='Enter'){ onOk(); } if(e.key==='Escape'){ onCancel(); } }

      handlers(true);

    });

  }



  // patch openLog to use secure prompt

  const orig = window.openLog;

  window.openLog = async function(){

    try{

      const code = await openSecurePrompt();

      if(typeof orig === 'function'){ orig.call(this, code); } // let original continue if it supports param

      else {

        // If original openLog expected to call prompt itself, we replicate a minimal flow:

        if (window.showLogWithCode) { window.showLogWithCode(code); }

        else {

          // fallback: store to global expected variable

          window.__lastLogCode = code;

        }

      }

    }catch(e){ /* cancelled */ }

  };

})();

</script>

<!-- Show Log: secure hidden-code modal (single eye) â€” wrapper only -->

<script>

(function(){

  if (typeof window.openLog !== 'function' || window.__showlog_secure_wrapped) return;

  window.__showlog_secure_wrapped = true;

  const __origOpenLog = window.openLog;



  function showSecureCodePrompt(title){

    return new Promise(resolve => {

      const ov = document.createElement('div');

      ov.className = 'code-dialog';
      ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:99999';

      const box = document.createElement('div');

      box.style.cssText = 'background:#fff;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:18px;min-width:360px;font:16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial';

      box.innerHTML = ''

        + '<div style="font-weight:600;margin-bottom:10px">'+ (title||'Enter admin code') +'</div>'

        + '<div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">'

        +   '<input id="__sl_code" type="password" autocomplete="off" inputmode="numeric" '

        +   'style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font-size:16px" />'

        +   '<button id="__sl_eye" type="button" aria-label="toggle" '

        +   'style="width:40px;height:40px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer">ğŸ‘ï¸</button>'

        + '</div>'

        + '<div style="display:flex;gap:8px;justify-content:flex-end">'

        +   '<button id="__sl_cancel" type="button" style="border:1px solid #ddd;border-radius:10px;padding:8px 14px;background:#eee">Cancel</button>'

        +   '<button id="__sl_ok" type="button" style="border:0;border-radius:10px;padding:8px 16px;background:#111;color:#fff">OK</button>'

        + '</div>';

      ov.appendChild(box); document.body.appendChild(ov);

      const inp = box.querySelector('#__sl_code');

      const eye = box.querySelector('#__sl_eye');

      const ok  = box.querySelector('#__sl_ok');

      const cancel = box.querySelector('#__sl_cancel');

      function close(v){ document.body.removeChild(ov); resolve(v); }

      eye.onclick = ()=>{ inp.type = (inp.type==='password') ? 'text' : 'password'; };

      ok.onclick = ()=> close(inp.value.trim());

      cancel.onclick = ()=> close(null);

      inp.addEventListener('keydown', e=>{ if(e.key==='Enter') ok.click(); if(e.key==='Escape') cancel.click(); });

      setTimeout(()=>inp.focus(), 50);

    });

  }



  window.openLog = async function(){

    try{

      const code = await showSecureCodePrompt('Enter admin code to view log');

      if (!code) return;

      try { if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert('Admin only'); return; } } catch(e){}

      openHistoryModal();

    }catch(e){ /* cancelled */ }

  };

})();

</script>





<script>

// SHOW LOG â€” secure code input only (hidden + single eye), no other changes

window.openLog = async function(){

  if (!window.securePromptOnce) { alert("Admin only"); return; }

  const code = await window.securePromptOnce("Enter admin code to view log");

  try {

    if (code == null || !isAdminCode(code)) { alert("Admin only"); return; }

  } catch(e) { alert("Admin only"); return; }

  openHistoryModal();

};

</script>





<script>

/* SHOW LOG â€” safe wrapper ONLY. Does not delete or modify any existing functions. */

(function () {

  if (window.__sl_secure_wrapped) return; window.__sl_secure_wrapped = true;



  // Try to locate Show Log trigger robustly

  var showBtn = document.getElementById('logBtn') ||

    Array.from(document.querySelectorAll('button, a')).find(function (el) {

      return /show\s*log/i.test((el.textContent||'').trim());

    });

  if (!showBtn) return;



  var origClick = showBtn.onclick;



  showBtn.onclick = async function (ev) {

    try {

      if (ev) { ev.preventDefault(); ev.stopPropagation(); }



      // Use existing securePromptOnce if present; otherwise build a tiny modal

      async function askCode(title) {

        if (window.securePromptOnce) return await window.securePromptOnce(title||'Enter admin code to view log');

        return await new Promise(function(resolve){

          const ov = document.createElement('div');

          ov.className = 'code-dialog';
          ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:99999';

          const box = document.createElement('div');

          box.style.cssText='background:#fff;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:18px;min-width:360px;font:16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial';

          box.innerHTML = ''

            + '<div style="font-weight:600;margin-bottom:10px">'+(title||'Enter admin code')+'</div>'

            + '<div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">'

            + '  <input id="sl_codeX" type="password" autocomplete="off" inputmode="numeric" style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font-size:16px" />'

            + '  <button id="sl_eyeX" type="button" aria-label="toggle" style="width:40px;height:40px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer">ğŸ‘ï¸</button>'

            + '</div>'

            + '<div style="display:flex;gap:8px;justify-content:flex-end">'

            + '  <button id="sl_cancelX" type="button" style="border:1px solid #ddd;border-radius:10px;padding:8px 14px;background:#eee">Cancel</button>'

            + '  <button id="sl_okX" type="button" style="border:0;border-radius:10px;padding:8px 16px;background:#111;color:#fff">OK</button>'

            + '</div>';

          ov.appendChild(box); document.body.appendChild(ov);

          const inp=box.querySelector('#sl_codeX'), eye=box.querySelector('#sl_eyeX');

          const ok=box.querySelector('#sl_okX'), cancel=box.querySelector('#sl_cancelX');

          function close(v){ document.body.removeChild(ov); resolve(v); }

          eye.onclick=()=>{ inp.type=(inp.type==='password')?'text':'password'; };

          ok.onclick=()=>close(inp.value.trim()); cancel.onclick=()=>close(null);

          inp.addEventListener('keydown', e=>{ if(e.key==='Enter') ok.click(); if(e.key==='Escape') cancel.click(); });

          setTimeout(()=>inp.focus(),50);

        });

      }



      const code = await askCode('Enter admin code to view log');

      if (!code || (typeof isAdminCode === 'function' && !isAdminCode(code))) {

        alert('Admin only'); return false;

      }



      // Open the History modal after successful admin code validation

      openHistoryModal();

      return false;

    } catch (e) {

      // On cancel or error, do nothing

      return false;

    }

  };

})();

</script>





<!-- RESET: secure hidden-code modal (single eye) â€” wrapper only -->

<script>

(function(){

  if (window.__reset_secure_wrapped) return; 

  window.__reset_secure_wrapped = true;

  try{

    var resetBtn = document.getElementById('resetBtn');

    if (!resetBtn) return;

    var originalReset = window.resetDay;



    resetBtn.onclick = async function(ev){
      console.log('RESET clicked (secure wrapper)');
      ensureTasksScreenHidden();
      
      try{

        if (ev) { ev.preventDefault(); ev.stopPropagation(); }

        // Ask for admin or manager code with hidden password + single eye

        if (!window.securePromptOnce) { alert('Admin or manager only'); return false; }

        const code = await window.securePromptOnce('Enter admin or manager code to RESET DAY');

        if (code == null) {

          return false;

        }

        const isAdmin = (typeof isAdminCode === 'function' && isAdminCode(code));

        const isManager = (typeof isManagerCode === 'function' && isManagerCode(code));

        if (!isAdmin && !isManager) {

          alert('Admin or manager only'); 

          return false;

        }

        // Confirm reset

        if (!confirm('Reset the day? This clears queues and history.')) return false;



        // Perform the original reset logic (without any visible prompts)

        try {

          // If original function exists and just does the clearing, call it

          if (typeof originalReset === 'function') {

            // Temporarily bypass gate functions if they exist inside originalReset (we already validated)

            const _gateAdmin = window.gateAdmin, _gateManager = window.gateManager;

            try {

              window.gateAdmin = function(){ return true; };

              window.gateManager = function(){ return true; };

              originalReset.call(this);

            } finally {

              window.gateAdmin = _gateAdmin;

              window.gateManager = _gateManager;

            }

          } else {

            // Fallback: manual clear

            window.queue = [];

            window.service = [];

            window.log = [];

            if (typeof save === 'function') save();

            if (typeof renderQueue === 'function') renderQueue();

            if (typeof renderService === 'function') renderService();

          }

        } catch(e){

          console.error('Reset error', e);

        }

        return false;

      }catch(e){

        return false;

      }

    };

  }catch(e){ /* ignore */ }

})();

</script>





<!-- === FAIR FLOW â€” Audit log (drop-in, zero behavior change) === -->

<script>

(function () {

  const LS_KEY = 'FF_AUDIT_LOG';



  const now = () => {

    const d = new Date();

    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'local';

    return d.toLocaleString([], {

      year:'numeric',month:'2-digit',day:'2-digit',

      hour:'2-digit',minute:'2-digit',second:'2-digit'

    }) + ` (${tz})`;

  };



  const load = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch { return []; } };

  const save = (arr) => localStorage.setItem(LS_KEY, JSON.stringify(arr));

  const actor = (type, name) => type==='worker'&&name ? `worker ${name}` : (type||'manager');



  function addLog({action, whoType, whoName, target}) {

    const arr = load();

    arr.unshift({ ts: now(), action, actor: actor(whoType, whoName), target: target||'' });

    save(arr);

    renderLog();

  }

  // Optional external call

  window.FF_AUDIT = { addLog };



  function rowName(el){

    const row = el.closest('[data-row], .queue-item, .row, li, .flex, .grid') || el.closest('*');

    if (!row) return '';

    const nameEl = row.querySelector('[data-name], .name, .worker, .tech, .badge, .chip, .pill, b, strong, span');

    if (nameEl && nameEl.textContent) return nameEl.textContent.trim();

    return ((row.textContent||'').trim().split(/\s+/)[0]||'').trim();

  }



  function renderLog(){

    const modal = document.querySelector('.history, .history-modal, [data-history], .modal-history, .modal:has(.history), .modal:has(#historyList)');

    if (!modal) return;

    let box =

      modal.querySelector('[data-history-list], #historyList, textarea, .list, ul') ||

      modal.querySelector('textarea, .list, ul');

    if (!box) return;



    const entries = load();

    const lines = entries.map(e => `[${e.ts}] ${e.actor} â†’ ${e.action}${e.target ? ` [${e.target}]` : ''}`);



    if (box.tagName === 'TEXTAREA' || box.tagName === 'INPUT') {

      box.value = lines.length ? lines.join('\n') : 'No activity';

    } else {

      const ul = box.tagName === 'UL' ? box : (box.querySelector('ul') || box.appendChild(document.createElement('ul')));

      ul.innerHTML = lines.length ? lines.map(l => `<li>${l}</li>`).join('') : '<li>No activity</li>';

    }

  }



  const mo = new MutationObserver(() => renderLog());

  mo.observe(document.documentElement, {subtree:true, childList:true});



  document.addEventListener('click', (ev) => {

    const btn = ev.target.closest('button, [role="button"]');

    if (!btn) return;

    const label = (btn.getAttribute('aria-label') || btn.textContent || '').trim().toUpperCase();



    // JOIN

    if (label === 'JOIN') {

      const sel = document.querySelector('select, [data-join-select]');

      const name = sel && sel.value ? sel.value : rowName(btn) || '';

      addLog({ action:'JOIN', whoType:'worker', whoName:name, target:name });

    }

    // Queue actions

    if (label === 'START' || label === 'START TOP') addLog({ action:'START', whoType:'manager', target:rowName(btn) });

    if (label === 'HOLD') addLog({ action:'HOLD', whoType:'manager', target:rowName(btn) });

    if (label === 'RELEASE' || label === 'RELEASE HOLD') addLog({ action:'RELEASE', whoType:'manager', target:rowName(btn) });

    if (label === 'FINISH') addLog({ action:'FINISH', whoType:'manager', target:rowName(btn) });

    if (label === 'LEAVE') addLog({ action:'LEAVE', whoType:'worker', target:rowName(btn) });

    // Reorder / move up/down

    if (label.includes('REORDER')) addLog({ action:'REORDER_TOGGLE', whoType:'manager' });

    if (label === 'UP' || label.includes('MOVE UP') || btn.textContent.trim() === 'â–²') addLog({ action:'MOVE_UP', whoType:'manager', target:rowName(btn) });

    if (label === 'DOWN' || label.includes('MOVE DOWN') || btn.textContent.trim() === 'â–¼') addLog({ action:'MOVE_DOWN', whoType:'manager', target:rowName(btn) });

    // Admin/Settings/Reset

    if (label === 'ADMIN') addLog({ action:'ADMIN_OPEN', whoType:'admin' });

    if (label === 'SETTINGS') addLog({ action:'SETTINGS_OPEN', whoType:'manager' });

    if (label === 'RESET' || label === 'RESET DAY') addLog({ action:'RESET', whoType:'admin' });

    // Show log lifecycle

    if (label === 'SHOW LOG' || label === 'HISTORY' || label === 'LOG') setTimeout(renderLog, 50);

    if (label === 'CLEAR') { save([]); renderLog(); }

    if (label === 'EXPORT') {

      const blob = new Blob([JSON.stringify(load(), null, 2)], {type:'application/json'});

      const url = URL.createObjectURL(blob), a = Object.assign(document.createElement('a'), {href:url, download:`fairflow-log-${Date.now()}.json`});

      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();

    }

  }, true);



  window.addEventListener('load', renderLog);

})();

</script>





<!-- Mini audit logger: pushes extra actions (REORDER/MOVE/Admin/Settings) into built-in `log` array -->

<script>

(function(){

  if (window.__ff_audit_wired) return; window.__ff_audit_wired = true;



  function stamp(){

    try { return (new Date()).toLocaleString(); } catch(e){ return String(new Date()); }

  }

  function rowName(el){

    try{

      var row = el.closest('li, .item, .row, tr, [data-row]');

      if(!row) return '';

      var pill = row.querySelector('.name-pill, .pill, b, strong, span');

      var txt = pill && (pill.textContent||'').trim();

      if(txt) return txt;

    }catch(e){}

    return '';

  }

  function add(msg){

    try{

      if(!window.log) window.log = [];

      if(typeof window.save === 'function'){

        window.log.unshift(stamp() + ' ' + msg);

        window.save();

      } else {

        window.log.unshift(stamp() + ' ' + msg);

      }

    }catch(e){}

  }



  document.addEventListener('click', function(ev){

    var btn = ev.target.closest('button, [role="button"]'); if(!btn) return;

    var raw = (btn.textContent || btn.value || '').trim();

    var t = raw.toUpperCase();



    // Only add entries the core app does NOT already record

    if (t === 'REORDER') { add('REORDER toggle'); return; }

    if (t === 'UP' || btn.textContent.trim() === 'â†‘' || btn.textContent.trim() === 'â–²') { add('MOVE UP: ' + rowName(btn)); return; }

    if (t === 'DOWN' || btn.textContent.trim() === 'â†“' || btn.textContent.trim() === 'â–¼') { add('MOVE DOWN: ' + rowName(btn)); return; }

    if (t === 'ADMIN') { add('ADMIN open'); return; }

    if (t === 'SETTINGS') { add('SETTINGS open'); return; }

  }, true);



  // Also patch reset to ensure an entry is kept before clearing

  try{

    var _reset = window.resetDay;

    window.resetDay = function(){

      try{ add('RESET day (confirmed)'); }catch(e){}

      return _reset ? _reset.apply(this, arguments) : undefined;

    }

  }catch(e){}

})();

</script>





<script>

// --- Guaranteed activity logger (adds entries to built-in `log` array) ---

(function(){

  if (window.__ff_force_logger) return; window.__ff_force_logger = true;

  function stamp(){ try { return (new Date()).toLocaleString(); } catch(e){ return String(new Date()); } }

  function saveLog(){ try{ if (typeof save === 'function') save(); }catch(e){} }

  function add(msg){

    try {

      if (!window.log) window.log = [];

      window.log.unshift(stamp() + " " + msg);

      saveLog();

    } catch(e){}

  }

  function rowName(el){

    try{

      var row = el.closest('li, .item, .row, tr, [data-row]') || el.parentElement;

      if (!row) return "";

      var pill = row.querySelector('.name-pill, .pill, b, strong, span');

      if (pill && pill.textContent) return pill.textContent.trim();

      return (row.textContent||"").trim().split(/\s+/)[0]||"";

    }catch(e){ return ""; }

  }

  // Wrap core functions if they exist to guarantee log lines

  try{

    if (typeof join === "function"){

      const _join = join;

      window.join = function(){ const before = (nameSelect && nameSelect.value)||""; const r = _join.apply(this, arguments); add("join: " + (nameSelect && nameSelect.value || before)); return r; }

    }

    if (typeof startSpecific === "function"){

      const _s = startSpecific;

      window.startSpecific = function(i){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add("START -> IN SERVICE: " + q.name); }catch(e){}; return _s.apply(this, arguments); }

    }

    if (typeof toggleHold === "function"){

      const _h = toggleHold;

      window.toggleHold = function(i){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add(((q.held?"RELEASE":"HOLD") + ": " + q.name)); }catch(e){}; return _h.apply(this, arguments); }

    }

    if (typeof finish === "function"){

      const _f = finish;

      window.finish = function(i){ try{ var s = (window.service||[])[i]; if(s&&s.name) add("FINISH -> Back to end: " + s.name); }catch(e){}; return _f.apply(this, arguments); }

    }

    if (typeof move === "function"){

      const _m = move;

      window.move = function(i,d){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add((d<0?"MOVE UP: ":"MOVE DOWN: ") + q.name); }catch(e){}; return _m.apply(this, arguments); }

    }

    if (typeof resetDay === "function"){

      const _r = resetDay;

      window.resetDay = function(){ add("RESET day (confirmed)"); return _r.apply(this, arguments); }

    }

  }catch(e){}



  // Global click safety net (in case some actions bypass wrappers)

  document.addEventListener("click", function(ev){

    var btn = ev.target.closest("button, [role='button']"); if(!btn) return;

    var t = (btn.textContent||btn.value||"").trim().toUpperCase();

    if (t === "START" || t === "FINISH" || t === "HOLD" || t === "RELEASE" || t === "START TOP" ||

        t === "UP" || t === "DOWN" || t === "ADMIN" || t === "SETTINGS" || t === "REORDER" || t === "RESET"){

      var nm = rowName(btn);

      add(t + (nm?(" " + nm):""));

    }

    if (t === "JOIN"){

      var nm = (window.nameSelect && nameSelect.value) || rowName(btn);

      add("join: " + (nm||""));

    }

  }, true);

})();

</script>



<script>

// --- Merge any auxiliary audit entries into the Show log view (non-destructive) ---

(function(){

  if (window.__ff_merge_log) return; window.__ff_merge_log = true;

  var originalOpen = window.openLog;

  window.openLog = async function(){

    try{

      // Preserve any secure prompt already injected

      if (window.securePromptOnce){

        const code = await window.securePromptOnce("Enter admin code to view log");

        if (!code || (typeof isAdminCode === "function" && !isAdminCode(code))) { alert("Admin only"); return; }

        openHistoryModal();

      }

    }catch(e){}

  };

})();

</script>







<!-- AUDIT LOG PATCH -->

<script>

(function(){

  try{

    function setActor(role, name){

      try {

        window.__ff_actorRole = role || '';

        window.__ff_actorName = name || '';

        sessionStorage.setItem('ff_actor_role', window.__ff_actorRole);

        sessionStorage.setItem('ff_actor_name', window.__ff_actorName);

      } catch(e){}

    }

    function getActorSuffix(targetName){

      try{

        var role = window.__ff_actorRole || sessionStorage.getItem('ff_actor_role') || '';

        var nm   = window.__ff_actorName || sessionStorage.getItem('ff_actor_name') || '';

        if (role){ return ' â€¢ BY ' + role + (nm ? (' ' + nm) : ''); }

        if (targetName){ return ' â€¢ BY Worker ' + targetName; }

      }catch(e){}

      return '';

    }

    if (typeof window.securePromptOnce === 'function'){

      const _sec = window.securePromptOnce;

      window.securePromptOnce = async function(msg){

        const code = await _sec.call(this, msg);

        try{

          if (code != null){

            if (typeof isAdminCode === 'function' && isAdminCode(code)){

              var adminName = (window.settings && (settings.ownerName || settings.adminName || (settings.owner && settings.owner.name))) || '';

              setActor('Admin', adminName || '');

            } else if (typeof isManagerCode === 'function' && isManagerCode(code)){

              var mgrName = '';

              try{

                if (window.settings && Array.isArray(settings.managers)){

                  var m = settings.managers.find(m => String(m.code) === String(code));

                  if (m && m.name) mgrName = m.name;

                }

              }catch(e){}

              setActor('Manager', mgrName || '');

            }

          }

        }catch(e){}

        return code;

      };

    }

    if (typeof window.gateAdmin === 'function'){

      const _ga = window.gateAdmin;

      window.gateAdmin = function(){

        const ok = _ga.apply(this, arguments);

        if (ok){ setActor('Admin', (window.settings && (settings.ownerName || settings.adminName)) || ''); }

        return ok;

      };

    }

    if (typeof window.gateManager === 'function'){

      const _gm = window.gateManager;

      window.gateManager = function(){

        const ok = _gm.apply(this, arguments);

        if (ok){ if (!window.__ff_actorRole) setActor('Manager',''); }

        return ok;

      };

    }

  }catch(e){}



  function stamp(){ try{ return new Date().toLocaleString(); }catch(e){ return String(Date.now()); } }

  function sanitize(s){ return String(s).replace(/[&<>]/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;'}[m]; }); }

  function extractTargetName(line){

    var m = String(line).match(/\b(?:START|FINISH|HOLD|RELEASE|JOIN)\s+(.+)$/i);

    return m ? m[1].trim() : '';

  }

  window.log = Array.isArray(window.log) ? window.log : [];

  function addLine(base){

    try{

      var tgt = extractTargetName(base);

      var full = base + getActorSuffix(tgt);

      window.log.unshift(stamp() + ' Â· ' + full);

      if (typeof window.save === 'function'){ window.save(); }

      if (window.logBox){

        const list = window.log;

        window.logBox.innerHTML = list.length

          ? list.map(function(l){ return '<div>'+sanitize(l)+'</div>'; }).join('')

          : "<i>No activity</i>";

      }

    }catch(e){}

  }



  try{

    if (window.__ff_click_handler && document.removeEventListener){

      document.removeEventListener('click', window.__ff_click_handler, true);

    }

  }catch(e){}



  window.__ff_click_handler = function(ev){

    var t = ev.target.closest('button, [role=\"button\"]'); if(!t) return;

    var txt = (t.textContent||'').trim().toUpperCase();

    var wrap = t.closest('[data-worker], .row, .svc, .queue, .inservice');

    var nm = '';

    try{

      nm = (wrap && (wrap.getAttribute('data-worker') || wrap.querySelector('[data-name], .name, .worker-name, .badge')?.textContent?.trim())) || '';

    }catch(e){}



    if (txt === 'HOLD')        addLine('HOLD ' + nm);

    else if (txt === 'START')  addLine('START ' + nm);

    else if (txt === 'FINISH') addLine('FINISH ' + nm);

    else if (txt === 'JOIN')   addLine('JOIN ' + nm);

    else if (txt === 'RESET' || txt === 'RESET DAY') addLine('RESET');

    else if (txt === 'START TOP') addLine('START TOP');

    else if (/^(UP|DOWN)$/.test(txt) || t.classList.contains('reorder') || (t.dataset && t.dataset.action==='reorder')){

      addLine('REORDER');

    }

  };

  document.addEventListener('click', window.__ff_click_handler, true);

})();

</script>

  <!-- Tasks Screen -->
  <style>
    /* Scoped styles for Tasks screen only - does not affect home screen */
    
    /* Ensure clickability for info icon and parent containers */
    #tasksScreen .tasks-info-icon {
      pointer-events: auto !important;
      z-index: 5;
      position: relative;
    }
    
    #tasksScreen .tasks-main-list-item,
    #tasksScreen .tasks-list,
    #tasksScreen .tasks-col,
    #tasksScreen #tasksContentContainer {
      pointer-events: auto !important;
    }
    
    #tasksScreen .tasks-title-wrapper {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    
    #tasksScreen .tasks-title-wrapper h2 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
    }
    
    #tasksScreen .tasks-gear-btn {
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #fff;
      padding: 8px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
    }
    
    #tasksScreen .tasks-gear-btn:hover {
      transform: translateY(-1px);
      background: #f9fafb;
    }
    
    .tasks-reset-btn {
      background-color: #fff;
      color: #e74c3c;
      border: 2px solid #e74c3c;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      pointer-events: auto;
      z-index: 301;
    }
    
    .tasks-reset-btn:hover {
      transform: translateY(-1px);
    }
    
    /* Tasks Settings Modal */
    #tasksScreen .tasks-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      overflow: hidden;
    }
    
    /* Task Info Modal (appended to body) */
    #taskInfoModalRoot {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 99999;
      pointer-events: none;
    }
    
    .task-info-overlay {
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.5);
    }
    
    .task-info-dialog {
      pointer-events: auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 560px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    
    .task-info-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid #e5e7eb;
    }
    
    .task-info-title {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #111;
    }
    
    .task-info-close-x {
      background: none;
      border: none;
      font-size: 24px;
      color: #666;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      line-height: 1;
    }
    
    .task-info-close-x:hover {
      background: #f3f4f6;
    }
    
    .task-info-body {
      padding: 20px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 14px;
      color: #333;
      line-height: 1.6;
      white-space: pre-wrap;
    }
    
    .task-info-footer {
      padding: 16px 20px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: flex-end;
    }
    
    .task-info-close-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      color: #fff;
      background: #7b3fe4;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    
    .task-info-close-btn:hover {
      background: #6b2fd4;
    }
    
    .task-worker {
      font-size: 12px;
      color: #7b3fe4;
      margin-top: 4px;
    }
    
    .task-done-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #e5e7eb;
      color: #111827;
      padding: 6px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 800;
      font-size: 13.3333px;
      line-height: normal;
      min-width: auto;
      box-shadow: none;
      outline: none;
    }
    
    .task-item-done {
      background: #d8f8d8 !important;
      opacity: 0.85;
    }
    
    #tasksScreen .tasks-modal-container {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 650px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }
    
    #tasksScreen .tasks-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      border-bottom: 1px solid #e5e7eb;
    }
    
    #tasksScreen .tasks-modal-title {
      margin: 0;
      font-size: 16px;
      font-weight: 500;
      color: #111;
    }
    
    #tasksScreen .tasks-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: #666;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      line-height: 1;
    }
    
    #tasksScreen .tasks-modal-close:hover {
      background: #f3f4f6;
    }
    
    #tasksScreen .tasks-modal-content {
      padding: 16px 20px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    
    #tasksScreen .tasks-modal-footer {
      position: sticky;
      bottom: 0;
      z-index: 10;
    }
    
    #tasksScreen .tasks-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      max-width: 1140px;
      margin: 0 auto;
    }
    
    #tasksScreen .tasks-col {
      background: #f7f7f8;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      padding: 14px;
      min-height: 240px;
    }
    
    #tasksScreen .tasks-col h2 {
      margin: 2px 0 10px;
      font-size: 15px;
      color: #6b7280;
      letter-spacing: 0.4px;
    }
    
    #tasksScreen .tasks-list {
      max-height: 58vh;
      overflow: auto;
    }
    
    /* Mobile: stack columns vertically */
    @media (max-width: 768px) {
      #tasksScreen .tasks-grid {
        grid-template-columns: 1fr;
      }
    }
    
    /* Fullscreen modal overlay */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      pointer-events: auto;
    }
    
    .modal-content {
      background: white;
      padding: 24px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      pointer-events: auto;
      position: relative;
      z-index: 10000;
    }
    
    /* Ensure buttons inside modals are always clickable */
    .modal-content button,
    #tasksResetConfirmModal button,
    #resetPinModal button {
      pointer-events: auto;
      cursor: pointer;
    }
    
    .modal-footer {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
    }
    
    .danger {
      background: #e53935;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
    }
  </style>
  <div id="tasksScreen" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:#fff;z-index:300;flex-direction:column;pointer-events:auto;">
    <!-- Top bar with BACK button, TASKS title, and RESET button -->
    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #e5e7eb;background:#fff;">
      <button id="btnTasksBack" class="btn-pill" style="pointer-events:auto;z-index:301;">BACK</button>
      <div style="flex:1;display:flex;justify-content:center;">
        <div class="tasks-title-wrapper">
          <h2>TASKS</h2>
          <button id="btnTasksSettings" class="tasks-gear-btn" aria-label="Task settings" style="pointer-events:auto;z-index:301;">âš™ï¸</button>
        </div>
      </div>
      <button id="reset-btn" class="tasks-reset-btn" style="margin-left:auto;" onclick="resetTasksForCurrentTab()">RESET</button>
    </div>
    
    <!-- Tab row -->
    <div style="display:flex;border-bottom:1px solid #e5e7eb;background:#f9fafb;pointer-events:auto;z-index:301;">
      <button class="tasks-tab" data-tab="opening" onclick="console.log('TAB CLICKED:', 'opening'); setTasksTab('opening')" style="flex:1;padding:12px 16px;border:none;background:transparent;cursor:pointer;font-size:14px;font-weight:500;color:#666;border-bottom:2px solid transparent;pointer-events:auto;z-index:302;">Opening</button>
      <button class="tasks-tab" data-tab="closing" onclick="console.log('TAB CLICKED:', 'closing'); setTasksTab('closing')" style="flex:1;padding:12px 16px;border:none;background:transparent;cursor:pointer;font-size:14px;font-weight:500;color:#666;border-bottom:2px solid transparent;pointer-events:auto;z-index:302;">Closing</button>
      <button class="tasks-tab" data-tab="weekly" onclick="console.log('TAB CLICKED:', 'weekly'); setTasksTab('weekly')" style="flex:1;padding:12px 16px;border:none;background:transparent;cursor:pointer;font-size:14px;font-weight:500;color:#666;border-bottom:2px solid transparent;pointer-events:auto;z-index:302;">Weekly</button>
      <button class="tasks-tab" data-tab="monthly" onclick="console.log('TAB CLICKED:', 'monthly'); setTasksTab('monthly')" style="flex:1;padding:12px 16px;border:none;background:transparent;cursor:pointer;font-size:14px;font-weight:500;color:#666;border-bottom:2px solid transparent;pointer-events:auto;z-index:302;">Monthly</button>
      <button class="tasks-tab" data-tab="yearly" onclick="console.log('TAB CLICKED:', 'yearly'); setTasksTab('yearly')" style="flex:1;padding:12px 16px;border:none;background:transparent;cursor:pointer;font-size:14px;font-weight:500;color:#666;border-bottom:2px solid transparent;pointer-events:auto;z-index:302;">Yearly</button>
    </div>
    
    <!-- Content area -->
    <div id="tasksContent" style="flex:1;padding:24px;overflow-y:auto;">
      <div id="tasksContentContainer" class="tasks-grid">
        <!-- Two-column layout will be rendered here by setTasksTab -->
      </div>
    </div>
    
    <!-- Tasks Reset Confirmation Modal -->
    <div id="tasksResetConfirmModal" class="modal-overlay" style="display:none;pointer-events:auto;z-index:10000;">
      <div id="tasksResetConfirmModalContent" class="modal-content" style="pointer-events:auto;position:relative;z-index:10001;">
        <h2>Reset tasks?</h2>
        <p>Are you sure you want to reset the tasks for: <span id="resetConfirmTabLabel"></span>?</p>
        <p id="resetConfirmError" style="color:#e53935;font-size:14px;margin:5px 0;min-height:20px;display:none;"></p>

        <div class="modal-footer">
          <button id="resetConfirmCancel" style="pointer-events:auto;">Cancel</button>
          <button id="resetConfirmYes" class="danger" style="pointer-events:auto;">Yes</button>
        </div>
      </div>
    </div>

    <div id="resetPinModal" class="modal-overlay" style="display:none;" onclick="if(event.target === this) { this.style.display='none'; }">
      <div class="modal-content" onclick="event.stopPropagation()">
        <h2>Admin PIN Required</h2>
        <p style="margin-bottom:12px;">Please enter Admin PIN to confirm reset:</p>
        <input id="resetPinInput" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="off" maxlength="6" style="width:100%;padding:10px;margin:10px 0;border:1px solid #ddd;border-radius:6px;font-size:16px;text-align:center;">
        <p id="resetPinError" style="color:#e53935;font-size:14px;margin:5px 0;min-height:20px;"></p>
        <div class="modal-footer">
          <button id="resetPinCancel">Cancel</button>
          <button id="resetPinOk" class="danger">Confirm</button>
        </div>
      </div>
    </div>
    
    <!-- Tasks Settings Modal -->
    <div id="tasksSettingsModal" class="tasks-modal-overlay" style="display:none;">
      <div class="tasks-modal-container" onclick="event.stopPropagation()">
        <div class="tasks-modal-header">
          <h3 class="tasks-modal-title">Settings</h3>
          <button id="tasksSettingsClose" class="tasks-modal-close" aria-label="Close">Ã—</button>
        </div>
        <div class="tasks-modal-content">
          <!-- Tab bar inside Settings modal -->
          <div id="tasksSettingsTabs" style="display:flex;border-bottom:1px solid #e5e7eb;background:#f9fafb;margin:-16px -20px 12px -20px;padding:0 20px;">
            <button class="tasks-settings-tab" data-tab="opening" style="flex:1;padding:10px 16px;border:none;background:transparent;cursor:pointer;font-size:13px;font-weight:500;color:#666;border-bottom:2px solid transparent;">Opening</button>
            <button class="tasks-settings-tab" data-tab="closing" style="flex:1;padding:10px 16px;border:none;background:transparent;cursor:pointer;font-size:13px;font-weight:500;color:#666;border-bottom:2px solid transparent;">Closing</button>
            <button class="tasks-settings-tab" data-tab="weekly" style="flex:1;padding:10px 16px;border:none;background:transparent;cursor:pointer;font-size:13px;font-weight:500;color:#666;border-bottom:2px solid transparent;">Weekly</button>
            <button class="tasks-settings-tab" data-tab="monthly" style="flex:1;padding:10px 16px;border:none;background:transparent;cursor:pointer;font-size:13px;font-weight:500;color:#666;border-bottom:2px solid transparent;">Monthly</button>
            <button class="tasks-settings-tab" data-tab="yearly" style="flex:1;padding:10px 16px;border:none;background:transparent;cursor:pointer;font-size:13px;font-weight:500;color:#666;border-bottom:2px solid transparent;">Yearly</button>
          </div>
          
          <!-- Add Task section (always visible, fixed position above catalog) -->
          <div style="flex-shrink:0;margin-bottom:12px;">
            <button id="tasksModalToggleForm" type="button" class="btn-pill" style="margin-bottom:8px;font-size:13px;">Add Task</button>
          
          <!-- Collapsible form section -->
            <div id="tasksAddFormWrap" style="display:none;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb;margin-bottom:0;">
              <label style="display:block;font-size:12px;font-weight:500;color:#111;margin-bottom:4px;">Task Name</label>
              <input type="text" id="taskNameInput" class="taskNameInput" placeholder="e.g., Turn on lights" style="width:100%;padding:8px;margin-bottom:4px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;font-family:inherit;">
              <div id="taskNameError" style="color:#dc2626;font-size:11px;margin-bottom:8px;min-height:14px;display:none;"></div>
              
              <label style="display:block;font-size:12px;font-weight:500;color:#111;margin-bottom:4px;">Info / Instructions</label>
              <textarea id="taskInfoInput" class="taskInfoInput" placeholder="Write the instructions..." rows="3" style="width:100%;padding:8px;margin-bottom:8px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;resize:vertical;font-family:inherit;"></textarea>
            
            <div style="display:flex;gap:8px;">
                <button id="taskAddBtn" type="button" class="btn-primary" style="padding:6px 14px;font-size:12px;">Add</button>
                <button id="taskCancelBtn" type="button" class="btn-pill" style="padding:6px 14px;font-size:12px;">Cancel</button>
              </div>
            </div>
          </div>
          
          <!-- Task Catalog section (no internal scroll, flows naturally) -->
          <div style="flex:1;display:flex;flex-direction:column;min-height:0;border-top:1px solid #e5e7eb;padding-top:12px;">
            <h4 style="margin:0 0 8px;font-size:13px;font-weight:600;color:#111;">Task Catalog</h4>
            <div id="tasksModalDraftList" style="height:auto;max-height:none;overflow:visible;"></div>
          </div>
        </div>
        
        <!-- Sticky Save button -->
        <div class="tasks-modal-footer" style="padding:10px 20px;border-top:1px solid #e5e7eb;background:#fff;border-radius:0 0 12px 12px;">
          <div style="font-size:11px;color:#666;margin-bottom:4px;text-align:center;">Save all changes to Task Catalog</div>
          <button id="tasksModalSaveBtn" class="btn-primary" style="width:100%;padding:8px;font-size:13px;">Save</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Task Instructions Modal -->
  <div id="taskInstructionsModal" class="tasks-modal-overlay" style="display:none;z-index:9999;">
    <div class="tasks-modal-container" onclick="event.stopPropagation()" style="max-width:500px;">
      <div class="tasks-modal-header">
        <h3 class="tasks-modal-title" id="taskInstructionsTitle">Instructions</h3>
        <button id="taskInstructionsClose" class="tasks-modal-close" aria-label="Close">Ã—</button>
      </div>
      <div class="tasks-modal-content" style="padding:20px;max-height:70vh;overflow-y:auto;">
        <div id="taskInstructionsText" style="font-size:14px;color:#333;line-height:1.6;white-space:pre-wrap;"></div>
      </div>
    </div>
  </div>

  </div> <!-- End owner-view -->

  <!-- Reception View -->
  <div id="reception-view" style="display:none;">
    <h2>Reception view</h2>
    <button id="logout-button-reception">Log out</button>
  </div>

  <!-- Staff View -->
  <div id="staff-view" style="display:none;">
    <h2>Staff view</h2>
    <button id="logout-button-staff">Log out</button>
  </div>

  </div> <!-- End main-app-content -->

  <script type="module" src="app.js"></script>

  <!-- PIN Modal -->
  <div id="pinModal" class="pin-modal" style="display:none;">
    <div class="pin-modal-backdrop"></div>
    <div class="pin-modal-dialog">
      <h3>Enter PIN to take this task</h3>
      <input id="pinModalTaskInput" type="password" maxlength="6" placeholder="Enter 4â€“6 digit PIN" />
      <div class="pin-actions">
        <button id="pinCancelBtn">Cancel</button>
        <button id="pinSubmitBtn">OK</button>
      </div>
      <p id="pinError" style="color:red; display:none;">Incorrect PIN</p>
    </div>
  </div>

  <style>
    .pin-modal {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pin-modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.35);
    }
    .pin-modal-dialog {
      position: relative;
      background: white;
      padding: 20px;
      border-radius: 10px;
      width: 280px;
      text-align: center;
      z-index: 10000;
    }
    .pin-actions {
      margin-top: 12px;
      display: flex;
      justify-content: space-between;
    }
  </style>

</body>

</html>
