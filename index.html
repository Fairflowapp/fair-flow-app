<!DOCTYPE html>

<html lang="en">

<head>

<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">

<meta charset="utf-8"/>

<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>FIRST FLOW ALMOST READY</title>

<style>

:root{

  --brand1:#9d68b9; --brand2:#ff9580;

  --bg:#ffffff; --muted:#f7f7f8; --text:#111827; --sub:#6b7280; --border:#e5e7eb;

  --held:#f7e096; --danger:#ef4444;

  --badge:#e5e7eb;

}

*{box-sizing:border-box}

body{margin:0;background:var(--bg);color:var(--text);font-family:'Avenir Next', 'Open Sans', Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}

/* Sticky header with left-aligned brand + toolbar */

.header{position:sticky;top:0;z-index:100000;background:rgba(255,255,255,.96);

  border-bottom:1px solid var(--border);backdrop-filter:saturate(1.2) blur(6px);pointer-events:auto}
  
/* Ensure toolbar buttons are always clickable */
.toolbar button{position:relative;z-index:100001;pointer-events:auto;cursor:pointer}


.header-inner{max-width:1140px;margin:0 auto;padding:10px 24px;display:grid;grid-template-columns:auto 1fr;gap:16px;align-items:center}

.brandbox{display:flex;align-items:center;gap:12px}

.logo{height:70px;width:auto;margin-right:12px;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.15));background:none;border:none;box-shadow:none;padding:0;border-radius:10px;object-fit:cover}

.title{display:flex;flex-direction:column}

.appname{font-size:14px;font-weight:900;letter-spacing:.3px}

header .brand{display:flex;align-items:center;gap:1rem}

.owner{font-size:12px;color:var(--sub)}
.owner-row{display:none}
.settings-row-brand{display:none}

.toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

.btn-pill{border-radius:999px;border:1px solid var(--border);background:#fff;padding:8px 14px;font-weight:700;cursor:pointer}

.btn-pill:hover{transform:translateY(-1px)}

.btn-danger{border-color:#fca5a5;color:#b91c1c}

/* Join row under header */

.joinbar{max-width:1140px;margin:6px auto 0;display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:0 24px 10px}

.grow{flex:1 1 260px}

select,input[type="password"],input[type="text"]{height:42px;padding:0 16px;border:1px solid var(--border);border-radius:22px;background:#fff;font-size:16px;width:100%}

.pinwrap{position:relative}

.eye{position:absolute;right:12px;top:10px;cursor:pointer;color:#6b7280}

/* 1. ×‘×¨×™×¨×ª ××—×“×œ â€“ ×œ×”×¡×ª×™×¨ ××ª ×›×¤×ª×•×¨ ×”×¢×™×Ÿ-×”×¨×•×‘×•×˜ ×‘×›×œ ××§×•× */
.ai-eye-button {
  display: none;
}

/* 2. ×œ×”×¦×™×’ ××ª ×›×¤×ª×•×¨ ×”×¢×™×Ÿ-×”×¨×•×‘×•×˜ ×¨×§ ×‘×©×•×¨×ª ×”-JOIN ×”×¢×œ×™×•× ×” */
.joinbar .ai-eye-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.btn-primary{border:0;background-image:linear-gradient(90deg,var(--brand1),var(--brand2));color:#fff;border-radius:999px;padding:10px 18px;font-weight:800;cursor:pointer;box-shadow:0 4px 10px rgba(0,0,0,.08)}

.btn-ghost{border:1px solid var(--border);background:#fff;border-radius:999px;padding:10px 18px;font-weight:800;cursor:pointer}

/* Main area */

.wrap{max-width:1140px;margin:0 auto;padding:10px 24px 28px}

.grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}

.col{background:var(--muted);border:1px solid var(--border);border-radius:14px;padding:14px;min-height:240px}

.col h2{margin:2px 0 10px;font-size:15px;color:var(--sub);letter-spacing:.4px}

.list{max-height:58vh;overflow:auto}

.available-list, .inservice-list {
    max-height: 90vh;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 6px;
}

ul{list-style:none;padding:0;margin:0}

.item{display:grid;grid-template-columns:50px 1fr auto;align-items:center;gap:10px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px;margin:8px 0}

.badge{min-width:32px;height:32px;border-radius:999px;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:13px;color:#374151;background:var(--badge)}

.name-pill{white-space:nowrap;font-size:18px;display:inline-block;padding:7px 12px;border-radius:999px;color:#fff;font-weight:900;letter-spacing:.2px}

.controls{display:flex;gap:8px;align-items:center;justify-content:flex-end}

/* Buttons in rows */

.start-btn,.finish-btn{padding:6px 12px;border-radius:8px;background:#e5e7eb;border:0;cursor:pointer;font-weight:800}

.hold-btn{padding:6px 12px;border-radius:8px;border:1px solid #e8d27a;background:var(--held);font-weight:800;cursor:pointer}

.item[held="true"]{background:#fff9e6;border-color:#ffcc00;opacity:.95}

/* Dialogs */

dialog{border:0;border-radius:14px;padding:0;width:min(980px,96vw)}
/* Ensure select dropdowns in dialogs are fully interactive */
dialog select, .code-dialog select {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1001;
  position: relative;
}
dialog select:not(:disabled), .code-dialog select:not(:disabled) {
  pointer-events: auto !important;
  cursor: pointer !important;
}
/* Ensure buttons in dialogs are fully interactive */
dialog button:not(:disabled), .code-dialog button:not(:disabled) {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1002;
  position: relative;
}
dialog footer button, .code-dialog footer button {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 1002;
  position: relative;
}

.dlg{padding:18px}

.dlg h3{margin:0 0 8px}

.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}

.row{display:flex;gap:10px;align-items:center;margin:8px 0;flex-wrap:wrap}

.row input[type="color"]{height:32px;width:48px;padding:0;border:1px solid var(--border);border-radius:8px;background:#fff}

.workers-table{display:block}

.workers-header,.worker-row{display:grid;grid-template-columns:2fr 120px 40px 48px 48px 1fr 60px;gap:10px;align-items:center;margin-bottom:8px;padding-bottom:6px}

.workers-header{border-bottom:1px solid var(--border);font-size:12px;font-weight:600;color:var(--sub)}

.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:13px}

.small{font-size:12px;color:#777}

.dlg footer{display:flex;justify-content:flex-end;gap:8px;padding:12px 18px;background:#fafafa;border-top:1px solid var(--border);border-radius:0 0 14px 14px}

.palette{display:flex;gap:8px;flex-wrap:wrap}

.sw{width:26px;height:26px;border-radius:50%;border:1px solid var(--border);cursor:pointer}

.logo-thumb{width:56px;height:56px;border-radius:12px;border:1px solid var(--border);object-fit:cover;background:#fff}

.brand-logo-upload {

  display: none !important;

}

.pop{position:absolute;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px;box-shadow:0 10px 24px rgba(0,0,0,.08);z-index:100}

.wrow{position:relative}

.btn-mini{border:1px solid var(--border);background:#fff;border-radius:999px;padding:6px 10px;font-weight:700;cursor:pointer;font-size:12px}

.manager-grid{display:grid;grid-template-columns:1fr 200px auto;gap:10px;align-items:center}



.quick-colors{display:flex;gap:8px;margin-bottom:6px}

.quick-colors button{width:22px;height:22px;border-radius:999px;border:1px solid #ddd;cursor:pointer}

.name-pill{white-space:nowrap;font-size:18px;min-width:120px;display:inline-flex;justify-content:center}



/* Ensure all prompts/modals inherit the app font */

#codePromptOverlay *, dialog, .dlg, .btn-pill, .btn-primary, .btn-ghost, .btn-mini,

.header, .joinbar, .wrap, .col, .small, .pill, input, select, button {

  font-family: inherit !important;

}

.history-modal {

  position: fixed;

  inset: 0;

  display: flex;

  align-items: center;

  justify-content: center;

  z-index: 1000;

}

.history-modal-footer {

  display: flex;

  gap: 10px;

  justify-content: flex-end;

  margin-top: 16px;

  padding-top: 16px;

  border-top: 1px solid #eee;

}

.history-modal-footer button {

  padding: 8px 16px;

  border-radius: 8px;

  border: 1px solid #ddd;

  background: #fff;

  cursor: pointer;

  font-weight: 600;

}

.history-modal-footer button:hover {

  background: #f5f5f5;

}

#historyClearBtn {

  border-color: #fca5a5;

  color: #b91c1c;

}

.history-modal.hidden {

  display: none;

}

.history-modal-backdrop {

  position: absolute;

  inset: 0;

  background: rgba(0, 0, 0, 0.25);

}

.history-modal-dialog {

  position: relative;

  background: #ffffff;

  border-radius: 12px;

  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);

  padding: 16px 20px;

  width: min(1000px, 90vw);

  max-height: 80vh;

  display: flex;

  flex-direction: column;

  z-index: 1000;

}

.history-modal-header {

  display: flex;

  align-items: center;

  justify-content: space-between;

  margin-bottom: 8px;

}

.history-modal-body {

  overflow: hidden;

}

.history-close-btn {

  border: none;

  background: transparent;

  font-size: 20px;

  cursor: pointer;

  line-height: 1;

}

.history-table-wrapper {

  max-height: 320px;    /* ××ª××™× ×œ×› ~10 ×©×•×¨×•×ª */

  overflow-y: auto;

}

/* ××•× ×¢ ×§×¤×™×¦×” / ×¢×™×•×•×ª */

.history-table-wrapper table {

  width: 100%;

  border-collapse: collapse;

}

.history-table {

  width: 100%;

  border-collapse: collapse;

  font-size: 0.85rem;

}

.history-table th,

.history-table td {

  padding: 4px 8px;

  text-align: left;

  border-bottom: 1px solid #f0f0f0;

}



</style>



<style id="quick4-css">

  .wrow{display:flex;align-items:center;gap:6px;flex-wrap:wrap;padding-left:2px}

  .pinwrap{display:flex;align-items:center;gap:6px}

  .pin{height:32px;width:120px;padding:0 10px;border:1px solid #e5e7eb;border-radius:8px;text-align:center}

  .color{height:32px;width:46px;padding:0;border:1px solid #e5e7eb;border-radius:6px;background:#fff}

  .quick4{display:inline-flex;align-items:center;gap:6px;margin-left:6px}

  .quick4 .dot{width:18px;height:18px;border-radius:50%;border:1px solid #d0d0d0;cursor:pointer}

  .spacer{flex:1 1 auto}

</style>



<style>#reorderBtn.active{filter:brightness(1.2);box-shadow:0 0 0 2px rgba(255,255,255,.35) inset}</style>

</head>

<body>

  <!-- LOGIN SECTION -->
  <section id="login-section" style="max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h1 style="text-align:center;font-size:28px;margin-bottom:24px;">Fair Flow â€“ Login</h1>

    <input id="login-email" type="email" placeholder="Email"
           style="width:100%;margin-bottom:12px;padding:12px 16px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="login-password" type="password" placeholder="Password"
           style="width:100%;margin-bottom:16px;padding:12px 16px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="login-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;margin-bottom:16px;">
      Log in
    </button>

    <div id="forgot-password-container" style="margin-top:8px;text-align:center;font-size:13px;">
      <button id="forgot-password-button"
              type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;">
        Forgot your password?
      </button>
    </div>

    <div id="password-reset-message" style="margin-top:6px;font-size:13px;text-align:center;"></div>

    <div style="text-align:center;margin:8px 0;">or</div>

    <button id="google-login-button"
            style="width:100%;padding:12px 16px;border-radius:999px;border:1px solid #ddd;background:#fff;cursor:pointer;font-size:14px;">
      Continue with Google
    </button>

    <div id="login-error" style="color:red;margin-top:8px;text-align:center;"></div>

    <div id="login-to-signup-toggle" style="margin-top: 12px; text-align: center;">
      <span>Don't have an account?</span>
      <button id="show-signup-button" type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;margin-left:4px;">
        Sign up
      </button>
    </div>
  </section>

  <!-- SIGNUP SECTION -->
  <section id="signup-section" style="display:none;max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="text-align:center;font-size:24px;margin-bottom:20px;">Create your Fair Flow account</h2>

    <input id="signup-business-name" type="text" placeholder="Business name"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-owner-name" type="text" placeholder="Your name"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-email" type="email" placeholder="Email"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-password" type="password" placeholder="Password"
           style="width:100%;margin-bottom:10px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <input id="signup-password-confirm" type="password" placeholder="Confirm password"
           style="width:100%;margin-bottom:16px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="signup-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;">
      Create account
    </button>

    <div id="signup-error" style="color:red;margin-top:8px;text-align:center;"></div>

    <div id="signup-to-login-toggle" style="margin-top: 12px; text-align:center;">
      <span>Already have an account?</span>
      <button id="show-login-button" type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;margin-left:4px;">
        Log in
      </button>
    </div>
  </section>

  <!-- RESET PASSWORD SECTION -->
  <section id="reset-password-section"
           style="display:none;max-width:400px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="text-align:center;font-size:24px;margin-bottom:20px;">Reset your password</h2>

    <p style="font-size:14px;color:#555;margin-bottom:12px;">
      Enter the email you use to sign in. We'll send you a link to reset your password.
    </p>

    <input id="reset-email"
           type="email"
           placeholder="Email"
           style="width:100%;margin-bottom:12px;padding:10px 14px;border-radius:8px;border:1px solid #ddd;font-size:14px;" />

    <button id="reset-password-button"
            style="width:100%;padding:12px 16px;border:none;border-radius:999px;background:linear-gradient(90deg,#a855f7,#fb7185);color:#fff;font-size:16px;font-weight:600;cursor:pointer;">
      Send reset link
    </button>

    <div id="reset-error" style="color:red;margin-top:8px;text-align:center;"></div>
    <div id="reset-success" style="color:green;margin-top:8px;text-align:center;"></div>

    <div style="margin-top: 16px; text-align:center;">
      <button id="reset-back-to-login-button"
              type="button"
              style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;font-size:13px;">
        Back to login
      </button>
    </div>
  </section>

  <!-- Main App Content (visible after login) -->
  <!-- Reset Admin PIN Page -->
  <section id="reset-admin-pin-section" style="display:none;max-width:480px;margin:40px auto;padding:32px;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.08);">
    <h2 style="margin:0 0 8px;font-size:24px;font-weight:600;color:#111;">Reset Admin PIN</h2>
    <p id="reset-pin-status" style="margin:0 0 24px;font-size:14px;color:#666;">Verifying reset link...</p>
    
    <div id="reset-pin-form" style="display:none;">
      <p style="margin:0 0 16px;font-size:14px;color:#666;">Enter a new 4-6 digit PIN for admin access.</p>
      <div style="display:flex;flex-direction:column;gap:12px;margin-bottom:18px;">
        <div>
          <label style="display:block;font-size:13px;color:#666;margin-bottom:6px;font-weight:500;">New PIN (4-6 digits)</label>
          <input id="reset-pin-new" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Enter new PIN" style="width:100%;border:1px solid #ddd;border-radius:10px;padding:12px 16px;font-size:16px;outline:none;" />
        </div>
        <div>
          <label style="display:block;font-size:13px;color:#666;margin-bottom:6px;font-weight:500;">Confirm PIN</label>
          <input id="reset-pin-confirm" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Confirm new PIN" style="width:100%;border:1px solid #ddd;border-radius:10px;padding:12px 16px;font-size:16px;outline:none;" />
        </div>
      </div>
      <div id="reset-pin-error" style="color:#dc2626;font-size:13px;margin-bottom:12px;min-height:18px;"></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;">
        <button id="reset-pin-cancel" class="btn-pill" style="font-size:14px;">Cancel</button>
        <button id="reset-pin-submit" class="btn-primary" style="font-size:14px;">Reset PIN</button>
      </div>
    </div>
    
    <div id="reset-pin-success" style="display:none;">
      <div style="padding:16px;background:#f0fdf4;border:1px solid #86efac;border-radius:10px;margin-bottom:16px;">
        <p style="margin:0;font-size:14px;color:#166534;font-weight:500;">âœ“ Admin PIN has been reset successfully. You can now use the new PIN to access admin actions.</p>
      </div>
      <button id="reset-pin-close" class="btn-primary" style="font-size:14px;width:100%;">Return to App</button>
    </div>
    
    <div id="reset-pin-error-state" style="display:none;">
      <div style="padding:16px;background:#fef2f2;border:1px solid #fca5a5;border-radius:10px;margin-bottom:16px;">
        <p id="reset-pin-error-message" style="margin:0;font-size:14px;color:#991b1b;"></p>
      </div>
      <button id="reset-pin-try-again" class="btn-pill" style="font-size:14px;width:100%;">Request New Reset Link</button>
    </div>
  </section>

  <div id="main-app-content" style="display:none;">

  <!-- Owner View (contains existing Fair Flow app) -->
  <div id="owner-view" style="display:none;">
    <div class="header">

    <div class="header-inner">

      <div class="brandbox">

        <img id="brandLogo" class="logo" alt="Fair Flow App" src="fairflow-logo.png">

        <div class="title">

          <div class="appname">FAIR FLOW APP</div>

          <div class="owner owner-row" id="salonName">Owner: <strong>Shiri</strong></div>

        </div>

      </div>

      <div class="toolbar">

        <button id="settingsBtn" class="btn-pill">Settings</button>

        <button id="logBtn" class="btn-pill">History</button>

        <button id="reorderBtn" class="btn-pill">Reorder</button>

        <button id="resetBtn" class="btn-pill btn-danger">RESET</button>

        <button id="logout-button" class="btn-pill">Log out</button>

      </div>

    </div>

    <!-- Join row -->

    <div id="joinBar" class="joinbar">

      <label>JOIN</label>

      <select id="nameSelect" class="grow" style="cursor:pointer;"></select>

      <div class="grow pinwrap">

        <input id="pinInput" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="off" maxlength="6" placeholder="PIN (hidden)" style="cursor:text;"/>

        <span id="togglePin" class="eye">ğŸ‘ï¸</span>

      </div>

      <button id="joinBtn" class="btn-primary">Join</button>

      <span style="flex:1"></span>

      <button id="startFirstBtn" class="btn-ghost">START top</button>

    </div>

    <div id="joinError" style="max-width:1140px;margin:0 auto;padding:0 24px;color:red;font-size:13px;margin-top:6px;min-height:18px;display:none;"></div>

  </div>



  <div class="wrap">

    <div class="grid">

      <div class="col">

        <h2>AVAILABLE</h2>

        <div id="reorderHeader" style="display:none;background:#f3fbff;border:1px solid #60a5fa;border-radius:14px;padding:16px 12px;margin-bottom:10px;text-align:center;">

          <button id="addTechBtn" class="btn-primary">+ Add technician</button>

        </div>

        <div class="list available-list"><ul id="queueList"></ul></div>

      </div>

      <div class="col">

        <h2>IN SERVICE</h2>

        <div class="list inservice-list"><ul id="serviceList"></ul></div>

      </div>

    </div>

  </div>

  <div id="historyModal" class="history-modal code-dialog hidden">
    <div class="history-modal-backdrop"></div>
    <div class="history-modal-dialog">
      <div class="history-modal-header">
        <h3>History</h3>
        <button id="historyCloseBtn" class="history-close-btn" type="button">Ã—</button>
      </div>
      <div class="history-modal-body">
        <div class="history-table-wrapper">
          <table class="history-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Time</th>
                <th>Action</th>
                <th>Role</th>
                <th>Performed by</th>
                <th>Worker</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>
      </div>
      <div class="history-modal-footer">
        <button id="historyExportBtn" type="button">Export</button>
        <button id="historyClearBtn" type="button">Clear</button>
        <button id="historyCloseBtn2" type="button">Close</button>
      </div>
    </div>
  </div>



  <!-- Settings (ADMIN ONLY) -->

  <dialog id="settingsDlg" class="code-dialog">

    <form method="dialog">

      <div class="dlg">

        <h3>Settings</h3>

        <div class="row small">Admin only. Managers cannot access.</div>



        <h4>Codes</h4>

        <div class="row">

          <span class="pill">Admin code:

            <input id="adminCode" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="off" maxlength="6" style="height:32px;width:120px;padding:0 10px">

            <button class="btn-mini" type="button" data-eye="adminCode">ğŸ‘</button>

          </span>

        </div>



        <h4>Managers (name â€¢ code)</h4>

        <div id="managersBox"></div>

        <div class="row"><button id="addManager" type="button" class="btn-mini">+ Add manager</button></div>



        <div class="settings-row-brand">
          <h4>Brand</h4>

          <div class="row">

            <div class="brand-logo-upload">

              <img id="logoPreview" class="logo-thumb" alt="logo"/>

              <input id="logoFile" type="file" accept="image/*"/>

            </div>

            <input id="salonInput" type="text" placeholder="Business/Owner name" style="flex:1;height:32px;padding:0 10px">

          </div>
        </div>



        <h4>Workers (name â€¢ PIN â€¢ color)</h4>

        <div id="workersBox"></div>

        <div class="row"><button id="addWorker" type="button" class="btn-mini">+ Add worker</button></div>

        <div class="row small">Only these names can join. Duplicates are blocked.</div>

      </div>

      <footer>

        <button class="btn-pill" value="cancel">Cancel</button>

        <button id="saveSettings" class="btn-primary" value="default">Save</button>

      </footer>

    </form>

  </dialog>



  <!-- Log (ADMIN ONLY) -->

  <dialog id="logDlg">

    <form method="dialog">

      <div class="dlg">

        <h3>History</h3>

        <div id="logBox" style="max-height:55vh;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:10px;background:#fff;font-size:12px"></div>

      </div>

      <footer>

        <button class="btn-pill" value="cancel">Close</button>

        <button id="exportLog" class="btn-pill">Export</button>

        <button id="clearLog" class="btn-pill btn-danger">Clear</button>

      </footer>

    </form>

  </dialog>



  <!-- Add Technician (REORDER MODE ONLY) -->

  <dialog id="addTechDlg" class="code-dialog">

    <form method="dialog">

      <div class="dlg">

        <h3>Add Technician to AVAILABLE</h3>

        <div class="row">

          <label style="display:flex;flex-direction:column;gap:6px;width:100%;">

            <span style="font-weight:600;">Technician name:</span>

            <select id="addTechSelect" style="height:42px;padding:0 16px;border:1px solid var(--border);border-radius:22px;background:#fff;font-size:16px;width:100%">

              <option value="">-- Select technician --</option>

            </select>

          </label>

        </div>

        <p class="small" style="margin-top:8px;color:var(--sub);">

          The technician will be added to the end of the AVAILABLE list.

        </p>

      </div>

      <footer>

        <button type="button" id="addTechCancel" class="btn-pill">Cancel</button>

        <button type="button" id="addTechConfirm" class="btn-primary">Add</button>

      </footer>

    </form>

  </dialog>



<script>

// Helpers

const ls=(k,v)=>v===undefined?JSON.parse(localStorage.getItem(k)||"null"):localStorage.setItem(k,JSON.stringify(v));

const $=s=>document.querySelector(s); const $$=s=>Array.from(document.querySelectorAll(s));

const btn=(t,c)=>{const b=document.createElement("button"); b.textContent=t; b.className=c; return b;};

const stamp=()=>new Date().toLocaleString();

const escapeHtml=s=>(s||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));

function toDataURL(file){return new Promise(res=>{const r=new FileReader(); r.onload=e=>res(e.target.result); r.readAsDataURL(file);});}

function formatHistoryDate(date) {
  return date.toLocaleDateString('en-US', {
    month: '2-digit',
    day: '2-digit'
  });
}

function formatHistoryTime(date) {
  return date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  });
}



// State

const DEFAULTS={

  adminCode:"5050",

  managers:[{name:"Manager A", code:"6060"}],

  brand:{name:"Shiri", logo:null},

  brandPalette:["#FBE54D","#D4452D","#79A7E5","#8AD97A"],

  core:["#111827","#5b21b6","#7c3aed","#2563eb","#0ea5e9","#10b981","#84cc16","#f59e0b","#ef4444","#f472b6"],

  workers:[

    {name:"Katy", pin:"1111", color:"#c0841a"},

    {name:"Johanna", pin:"2222", color:"#2563eb"},

    {name:"Maya", pin:"3333", color:"#ef4444"},

    {name:"Daniel", pin:"4444", color:"#10b981"},

    {name:"Noa", pin:"5555", color:"#111827"}

  ]

};

let settings=ls("ffv24_settings")||DEFAULTS;

// Ensure settings.workers exists and is an array
if (!settings.workers || !Array.isArray(settings.workers) || settings.workers.length === 0) {
  console.warn('settings.workers is missing or empty, initializing from defaults');
  settings.workers = DEFAULTS.workers ? [...DEFAULTS.workers] : [];
  save();
}

// Initialize task reminder settings if not present
if (!settings.taskReminders) {
  settings.taskReminders = {
    Opening: { enabled: false, type: 'daily', time: '07:30' },
    Closing: { enabled: false, type: 'daily', time: '16:00' },
    Weekly: { enabled: false, type: 'weekly', weekday: 1, time: '09:00' }, // 1 = Monday
    Monthly: { enabled: false, type: 'monthly', day: 1, time: '09:00' },
    Yearly: { enabled: false, type: 'yearly', month: 1, day: 1, time: '09:00' } // month: 1-12, day: 1-31
  };
}

// Initialize task notes if not present (backward compatible)
if (!settings.taskNotes) {
  settings.taskNotes = {
    opening: '',
    closing: '',
    weekly: '',
    monthly: '',
    yearly: ''
  };
}

// Initialize incomplete tasks badge setting (backward compatible)
if (settings.showIncompleteTasksBadge === undefined) {
  settings.showIncompleteTasksBadge = false; // Default to disabled
}

// Initialize brandPalette if missing (backward compatibility)

if(!settings.brandPalette){

  // Try to infer from first worker's quick colors, otherwise use defaults

  if(settings.workers && settings.workers.length>0 && settings.workers[0].quickColors){

    settings.brandPalette=settings.workers[0].quickColors.slice(0,4);

  }else{

    settings.brandPalette=DEFAULTS.brandPalette.slice();

  }

  // Ensure exactly 4 colors

  while(settings.brandPalette.length<4){

    settings.brandPalette.push(DEFAULTS.brandPalette[settings.brandPalette.length]||"#111827");

  }

}

let queue=ls("ffv24_queue")||[];      // {name, held:false}

let service=ls("ffv24_service")||[];  // {name}

let log=ls("ffv24_log")||[];

const history = [];

let reorderMode=false;



// Elements

// Get elements - use getElementById for more reliable selection
const nameSelect = document.getElementById("nameSelect") || $("#nameSelect");
const pinInput = document.getElementById("pinInput") || $("#pinInput");
const togglePin = document.getElementById("togglePin") || $("#togglePin");
const joinBtn = document.getElementById("joinBtn") || $("#joinBtn");

const startFirstBtn=$("#startFirstBtn"); // adminBtn removed

const resetBtn=$("#resetBtn"), reorderBtn=$("#reorderBtn"), logBtn=$("#logBtn"), settingsBtn=$("#settingsBtn");

// Declare salonName early to ensure it's available before renderBrand() is called
const salonName=$("#salonName"), salonInput=$("#salonInput"), brandLogo=$("#brandLogo");

// Numeric-only PIN/code input enforcement using event delegation
(function() {
  // Matcher function to identify PIN/code inputs
  function isPinLikeInput(el) {
    if (!el || el.tagName !== 'INPUT' || el.type === 'email' || el.type === 'file') {
      return false;
    }
    
    const id = (el.id || '').toLowerCase();
    const name = (el.name || '').toLowerCase();
    const placeholder = (el.placeholder || '').toLowerCase();
    const className = (el.className || '').toLowerCase();
    
    return (
      id.includes('pin') || id.includes('code') ||
      name.includes('pin') || name.includes('code') ||
      placeholder.includes('pin') || placeholder.includes('code') ||
      className.includes('pin') || className.includes('mcode') || className.includes('wpin')
    );
  }
  
  // Configure a PIN input with numeric attributes
  // Keep type="password" by default for visual hiding, but allow eye toggle to change to text
  function configurePinInput(el) {
    if (!el || !isPinLikeInput(el)) return;
    
    // Set to password by default (hidden), unless already text (eye toggle revealed it)
    // Don't override if eye toggle has set it to text
    if (el.type !== 'text') {
      el.type = "password";
    }
    // If type is already 'text' (from eye toggle), leave it as text
    
    el.inputMode = "numeric";
    el.pattern = "[0-9]*";
    // Use one-time-code for autocomplete, but allow override
    if (!el.hasAttribute('autocomplete')) {
      el.autocomplete = "one-time-code";
    }
  }
  
  // Focusin handler: configure input when focused
  document.addEventListener('focusin', function(e) {
    if (isPinLikeInput(e.target)) {
      configurePinInput(e.target);
    }
  }, true);
  
  // Input handler: strip non-digits
  document.addEventListener('input', function(e) {
    if (isPinLikeInput(e.target)) {
      e.target.value = e.target.value.replace(/\D/g, "");
    }
  }, true);
  
  // Paste handler: strip non-digits from pasted content
  document.addEventListener('paste', function(e) {
    if (isPinLikeInput(e.target)) {
      e.preventDefault();
      const pastedText = (e.clipboardData || window.clipboardData).getData('text');
      const numericOnly = pastedText.replace(/\D/g, "");
      if (numericOnly) {
        const start = e.target.selectionStart || 0;
        const end = e.target.selectionEnd || 0;
        const currentValue = e.target.value;
        e.target.value = currentValue.substring(0, start) + numericOnly + currentValue.substring(end);
        e.target.setSelectionRange(start + numericOnly.length, start + numericOnly.length);
        e.target.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }
  }, true);
  
  // Initialize existing inputs on DOM ready
  function initPinInputs() {
    document.querySelectorAll('input').forEach(function(input) {
      if (isPinLikeInput(input)) {
        configurePinInput(input);
      }
    });
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPinInputs);
  } else {
    initPinInputs();
  }
})();

const queueList=$("#queueList"), serviceList=$("#serviceList");

const settingsDlg=$("#settingsDlg");

const logoPreview=$("#logoPreview"), logoFile=$("#logoFile");

const logDlg=$("#logDlg"), logBox=$("#logBox");



// Roles helpers

function isManagerCode(code){ return (settings.managers||[]).some(m=>m.code.toString()===code.toString()); }

// Cache for admin PIN from Firestore
let cachedAdminPin = null;
let adminPinCacheTime = 0;
const ADMIN_PIN_CACHE_DURATION = 60000; // 1 minute cache

// Get admin PIN (checks Firestore first, then falls back to local settings)
async function getAdminPin() {
  // Try Firestore first
  if (window.getAdminPinFromFirestore && typeof window.getAdminPinFromFirestore === 'function') {
    const now = Date.now();
    // Use cache if available and not expired
    if (cachedAdminPin !== null && (now - adminPinCacheTime) < ADMIN_PIN_CACHE_DURATION) {
      return cachedAdminPin;
    }
    
    try {
      const firestorePin = await window.getAdminPinFromFirestore();
      if (firestorePin !== null) {
        cachedAdminPin = firestorePin;
        adminPinCacheTime = now;
        return firestorePin;
      }
    } catch (error) {
      console.error("[AdminPIN] Error getting PIN from Firestore, falling back to local:", error);
    }
  }
  
  // Fall back to local settings
  return (settings.adminCode || "").toString();
}

// Clear admin PIN cache (call after updating PIN)
function clearAdminPinCache() {
  cachedAdminPin = null;
  adminPinCacheTime = 0;
}

// Check if code matches admin PIN (checks Firestore first, then local)
async function isAdminCodeAsync(code) {
  const adminPin = await getAdminPin();
  return adminPin.toString() === code.toString();
}

// Synchronous version for backward compatibility (uses cached value or local)
// This is the main function used throughout the app
function isAdminCode(code) {
  // Use cached value if available
  if (cachedAdminPin !== null) {
    return cachedAdminPin.toString() === code.toString();
  }
  // Fall back to local settings
  return (settings.adminCode || "").toString() === code.toString();
}

// Initialize admin PIN cache on load
(async function initAdminPinCache() {
  if (window.getAdminPinFromFirestore && typeof window.getAdminPinFromFirestore === 'function') {
    try {
      const firestorePin = await window.getAdminPinFromFirestore();
      if (firestorePin !== null) {
        cachedAdminPin = firestorePin;
        adminPinCacheTime = Date.now();
        // Also update local settings for backward compatibility
        if (settings) {
          settings.adminCode = firestorePin;
        }
      }
    } catch (error) {
      console.error("[AdminPIN] Error initializing PIN cache:", error);
    }
  }
})();

// Get actor object for history logging
// Returns { role, name }
function getActorForAction(options) {
  // options:
  //   - workerName?  (for tech self-actions)
  //   - managerCode? (when a manager types a PIN)
  //   - adminCode?   (when admin code used)

  // Manager by PIN
  if (options && options.managerCode) {
    const pin = String(options.managerCode);
    const managers = (settings.managers || []);

    const manager = managers.find(m => String(m.code || m.pin) === pin);
    if (manager) {
      return {
        role: "Manager",
        name: manager.name || "Manager"
      };
    }
  }

  // Admin
  if (options && options.adminCode) {
    if (String(settings.adminCode) === String(options.adminCode)) {
      return {
        role: "Admin",
        name: settings.adminName || settings.ownerName || "Admin"
      };
    }
  }

  // Tech (default â€“ worker acts ×¢×œ ×¢×¦××•)
  if (options && options.workerName) {
    return {
      role: "Tech",
      name: options.workerName
    };
  }

  // Safety fallback
  return {
    role: "Tech",
    name: "-"
  };
}

function getCurrentActorRole() {
  // Check window.__ff_actorRole first (set by securePromptOnce wrapper)
  if (window.__ff_actorRole === 'Manager' || window.__ff_actorRole === 'Admin') {
    return window.__ff_actorRole;
  }
  // Fallback to old window.lastActorRole
  if (window.lastActorRole === 'Manager' || window.lastActorRole === 'Admin') {
    return window.lastActorRole;
  }
  return 'Tech';
}

function getCurrentActorName() {
  // Check window.__ff_actorName first (set by securePromptOnce wrapper)
  // Note: We check for undefined/null, not falsy, because empty string is a valid value
  if (window.__ff_actorName !== undefined && window.__ff_actorName !== null && window.__ff_actorName !== '') {
    return window.__ff_actorName;
  }
  // Check sessionStorage (also set by securePromptOnce wrapper)
  try {
    const storedName = sessionStorage.getItem('ff_actor_name');
    if (storedName && storedName !== '') {
      return storedName;
    }
  } catch(e) {}
  // Fallback to old window.lastManagerName
  return window.lastManagerName || '';
}

// Get actor information for history entry
// Returns { actorRole, actorName, workerName }
function getActorInfo(code = null, workerName = '') {
  let actorRole = 'Tech';
  let actorName = '';
  
  // If a code was provided, validate it to determine actor
  if (code != null) {
    if (isAdminCode(code)) {
      actorRole = 'Admin';
      actorName = (settings.ownerName || settings.adminName || (settings.owner && settings.owner.name) || 'Admin');
    } else if (isManagerCode(code)) {
      actorRole = 'Manager';
      // Find the manager by code - must match exactly
      const manager = (settings.managers || []).find(m => m.code && m.code.toString() === code.toString());
      actorName = (manager && manager.name) ? manager.name : 'Manager';
    } else {
      // Code provided but not admin/manager - must be worker PIN, so Tech
      actorRole = 'Tech';
      actorName = workerName || 'Tech';
    }
  } else {
    // No code provided - check if there's a current actor (from securePromptOnce)
    const currentRole = getCurrentActorRole();
    if (currentRole === 'Manager' || currentRole === 'Admin') {
      actorRole = currentRole;
      let currentName = getCurrentActorName();
      
      // For Manager: ensure we have the actual manager name, not just "Manager"
      if (currentRole === 'Manager') {
        // If name is missing, empty, or "Manager", try to get it from window.__ff_actorName directly
        if (!currentName || currentName === '' || currentName === 'Manager') {
          // Check window.__ff_actorName first (most recent)
          if (window.__ff_actorName && window.__ff_actorName !== '' && window.__ff_actorName !== 'Manager') {
            currentName = window.__ff_actorName;
          } else {
            // Check sessionStorage
            try {
              const storedName = sessionStorage.getItem('ff_actor_name');
              if (storedName && storedName !== '' && storedName !== 'Manager') {
                currentName = storedName;
              }
            } catch(e) {}
          }
        }
        
        // If we still don't have a proper name, use "Manager" as fallback
        // This should rarely happen if securePromptOnce wrapper works correctly
        actorName = (currentName && currentName !== '' && currentName !== 'Manager') ? currentName : 'Manager';
      } else {
        // Admin
        if (currentName && currentName !== '') {
          actorName = currentName;
        } else {
          actorName = (settings.ownerName || settings.adminName || 'Admin');
        }
      }
    } else {
      // Default to Tech with worker name
      actorRole = 'Tech';
      actorName = workerName || 'Tech';
    }
  }
  
  return {
    actorRole: actorRole,
    actorName: actorName || '-',
    workerName: workerName || ''
  };
}

function addHistoryEntry(actionText, actor, workerName) {
  const now = new Date();
  
  history.unshift({
    timestamp: now,
    date: formatHistoryDate(now),   // 11/16
    time: formatHistoryTime(now),   // 16:40
    action: actionText,
    role: actor.role,            // Tech / Manager / Admin
    performedBy: actor.name,     // Shiri / Leya / Admin / ...
    worker: workerName || '',
    // Keep backward compatibility fields
    actorRole: actor.role,
    actorName: actor.name,
    workerName: workerName || ''
  });
  renderHistory();
}

function renderHistory() {
  const tableBody = document.getElementById('historyBody');
  if (!tableBody) return;

  tableBody.innerHTML = history.map(entry => {
    const d = entry.timestamp;
    // Backwards compatibility: handle old structure
    let role = entry.role || entry.actorRole;
    let performedBy = entry.performedBy || entry.actorName;
    let worker = entry.worker || entry.workerName;
    
    // Try to get from old structure if missing
    if (!performedBy) {
      if (entry.performedBy) {
        performedBy = entry.performedBy;
      } else if (entry.actorName) {
        performedBy = entry.actorName;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        performedBy = entry.performedBy.name || '-';
      } else {
        performedBy = '-';
      }
    }
    
    if (!role) {
      if (entry.actorRole) {
        role = entry.actorRole;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        role = entry.performedBy.role || 'Tech';
      } else {
        role = 'Tech';
      }
    }
    
    if (!worker && entry.workerName) {
      worker = entry.workerName;
    }
    
    return `
      <tr>
        <td>${formatHistoryDate(d)}</td>
        <td>${formatHistoryTime(d)}</td>
        <td>${escapeHtml(entry.action)}</td>
        <td>${escapeHtml(role || '-')}</td>
        <td>${escapeHtml(performedBy || '-')}</td>
        <td>${escapeHtml(worker || '')}</td>
      </tr>
    `;
  }).join('');
}



// Render

function renderBrand(){
  if (salonName) {
    salonName.innerHTML="Owner: <strong>"+escapeHtml(settings.brand.name||"")+"</strong>";
  }

  if (brandLogo) {
    brandLogo.src = "fairflow-logo.png";
    brandLogo.style.visibility="visible";
  }
}

function loadTechniciansFromSettings() {
  // Load technicians from settings.workers (stored in localStorage)
  // This is the same data source used in Settings page
  console.log('[loadTechniciansFromSettings] Loading technicians from settings.workers');
  
  // Ensure settings.workers exists and is an array
  if (!settings.workers || !Array.isArray(settings.workers)) {
    console.warn('[loadTechniciansFromSettings] settings.workers is not defined or not an array, using defaults');
    settings.workers = DEFAULTS.workers ? [...DEFAULTS.workers] : [];
    save();
  }
  
  console.log('[loadTechniciansFromSettings] Found', settings.workers.length, 'technicians');
  console.log('[loadTechniciansFromSettings] Technicians:', settings.workers.map(w => ({ name: w.name, hasPin: !!w.pin })));
  
  return settings.workers;
}

function renderSelect(){
  // Try to get element if not already available
  const selectEl = document.getElementById("nameSelect");
  
  if (!selectEl) {
    console.error('[renderSelect] nameSelect element not found in DOM');
    // Try again after a short delay in case DOM isn't ready
    setTimeout(() => {
      const retryEl = document.getElementById("nameSelect");
      if (retryEl) {
        console.log('[renderSelect] Found element on retry, rendering now');
        renderSelect();
      } else {
        console.error('[renderSelect] Still cannot find nameSelect after retry');
      }
    }, 500);
    return;
  }

  // Check if owner-view is visible
  const ownerView = document.getElementById("owner-view");
  if (ownerView && ownerView.style.display === 'none') {
    console.log('[renderSelect] owner-view is hidden, will retry when visible');
    // Retry when view becomes visible
    setTimeout(renderSelect, 1000);
    return;
  }

  // Load technicians from the same data source as Settings page
  const technicians = loadTechniciansFromSettings();
  
  console.log('[renderSelect] Rendering dropdown with', technicians.length, 'technicians');
  
  selectEl.innerHTML="";

  // Ensure dropdown is enabled and interactive
  selectEl.disabled = false;
  selectEl.style.pointerEvents = 'auto';
  selectEl.style.cursor = 'pointer';
  selectEl.style.opacity = '1';
  selectEl.removeAttribute('readonly');
  selectEl.removeAttribute('disabled');

  if (technicians.length === 0) {
    console.warn('[renderSelect] No technicians found in settings.workers');
    // Add a placeholder option
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "No technicians available - Add in Settings";
    placeholder.disabled = true;
    placeholder.selected = true;
    selectEl.appendChild(placeholder);
    selectEl.disabled = true;
    return;
  }

  // Add a default "Select technician" option
  const defaultOption = document.createElement("option");
  defaultOption.value = "";
  defaultOption.textContent = "Select technician...";
  defaultOption.disabled = true;
  defaultOption.selected = true;
  selectEl.appendChild(defaultOption);

  // Populate dropdown with technicians from settings
  let addedCount = 0;
  technicians.forEach(technician => { 
    if (technician && technician.name && technician.name.trim()) {
      const option = document.createElement("option"); 
      option.value = technician.name.trim(); // Use name as the ID/value
      option.textContent = technician.name.trim(); 
      option.dataset.technicianId = technician.name.trim(); // Store ID for reference
      selectEl.appendChild(option);
      addedCount++;
    }
  });
  
  console.log('[renderSelect] Added', addedCount, 'technicians to dropdown');
  
  // Update global reference
  if (typeof window !== 'undefined') {
    window.nameSelect = selectEl;
  }
}

function colorOf(name){ const f=settings.workers.find(w=>w.name===name); return f?f.color:"#111827"; }

function fontColorOf(name){

  const w = (settings.workers||[]).find(x=>x.name===name);

  return (w && w.fcolor) ? w.fcolor : '#ffffff';

}



function namePill(name){

  const span=document.createElement('span');

  span.className='name-pill';

  span.style.background=colorOf(name);

  span.style.color=fontColorOf(name);

  span.textContent=name;

  return span;

}

function renderQueue(){

  queueList.innerHTML="";

  queue.forEach((q,i)=>{

    const li=document.createElement("li"); li.className="item"; li.setAttribute("held",q.held?"true":"false");

    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=i+1;

    const nm=document.createElement("div"); nm.appendChild(namePill(q.name));

    const ctrls=document.createElement("div"); ctrls.className="controls";

    const start=btn("START","start-btn");

    const hold=btn(q.held?"RELEASE":"HOLD","hold-btn");

    start.onclick=() =>guardStart(q.name, i, ()=>startSpecific(i));

    hold.onclick=() =>guardHold(()=>toggleHold(i));

    ctrls.append(hold,start);

    if(reorderMode){ const up=btn("â†‘","start-btn"), down=btn("â†“","start-btn"); up.onclick=() =>move(i,-1); down.onclick=() =>move(i,1); const del=btn("âœ–","finish-btn"); del.title="Remove from queue"; del.onclick=()=>guardHold(()=>removeFromQueue(i)); ctrls.prepend(up); ctrls.append(down); ctrls.append(del); }

    li.append(badge,nm,ctrls); queueList.appendChild(li);

  });

}



function removeFromQueue(i){

  if(i<0 || i>=queue.length) return;

  const rem = queue.splice(i,1)[0];

  save();

  renderQueue(); 

  log.push(`${new Date().toLocaleString()} â€“ REMOVED ${rem.name} by admin/manager`);

  save();

  // Remove from queue is always done by manager/admin (guardHold ensures this)
  // Use the last validated code or current actor state
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry('Remove from queue', actor, rem.name);

}

function renderService(){

  serviceList.innerHTML="";

  service.forEach((s,i)=>{

    const li=document.createElement("li"); li.className="item";

    const badge=document.createElement("div"); badge.className="badge"; badge.textContent="â€¢";

    const nm=document.createElement("div"); const pill=namePill(s.name); pill.textContent=s.name; nm.appendChild(pill);

    const fin=btn("FINISH","finish-btn"); fin.onclick=() =>guardFinish(s.name, ()=>finish(i));

    li.append(badge,nm,fin); serviceList.appendChild(li);

  });

}



// Actions

function handleJoin(){
  try {
  console.log('[handleJoin] Join button clicked');

  const joinErrorEl = document.getElementById('joinError');
  
  // Clear any previous error
  if (joinErrorEl) {
    joinErrorEl.textContent = '';
    joinErrorEl.style.display = 'none';
  }

  // Get elements fresh to ensure they exist
  const nameSelectEl = document.getElementById("nameSelect");
  const pinInputEl = document.getElementById("pinInput");
  
  if (!nameSelectEl) {
    console.error('[handleJoin] nameSelect element not found');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: Dropdown not found. Please refresh the page.';
      joinErrorEl.style.display = 'block';
    }
    return;
  }
  
  if (!pinInputEl) {
    console.error('[handleJoin] pinInput element not found');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: PIN input not found. Please refresh the page.';
      joinErrorEl.style.display = 'block';
    }
    return;
  }

  // Get selected technician name (this is the technician ID in this app)
  const selectedTechnicianName = nameSelectEl.value;
  const pin = (pinInputEl.value || "").toString().trim();
  
  console.log('[handleJoin] Join clicked', selectedTechnicianName, pin);
  console.log('[handleJoin] Available workers:', settings.workers?.length || 0);
  
  // Validate that both name and PIN are provided
  if (!selectedTechnicianName || selectedTechnicianName === '' || selectedTechnicianName === 'Select technician...') {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Please select a technician';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Please select a technician');
    }
    return;
  }

  if (!pin || pin === '') {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Please enter a PIN';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Please enter a PIN');
    }
    return;
  }

  // Load the selected technician from settings.workers
  const technician = settings.workers.find(w => w.name === selectedTechnicianName);
  
  if (!technician) {
    console.error('[handleJoin] Technician not found:', selectedTechnicianName);
    console.log('[handleJoin] Available technicians:', settings.workers.map(w => w.name));
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Technician not found in settings';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Technician not found');
    }
    return;
  }

  console.log('[handleJoin] Found technician:', technician.name, 'Stored PIN:', technician.pin);

  // Verify that the entered PIN matches the technician's stored PIN
  const storedPin = (technician.pin || "").toString();
  const enteredPin = pin.toString();
  
  if (storedPin !== enteredPin) {
    console.error('[handleJoin] PIN mismatch. Expected:', storedPin, 'Got:', enteredPin);
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Incorrect PIN';
      joinErrorEl.style.display = 'block';
    } else {
      alert('Incorrect PIN');
    }
    // Clear PIN field on error
    pinInputEl.value = '';
    return;
  }

  // Check if technician is already in queue or service
  if (queue.some(x => x.name === selectedTechnicianName) || service.some(x => x.name === selectedTechnicianName)) {
    if (joinErrorEl) {
      joinErrorEl.textContent = 'This technician is already active';
      joinErrorEl.style.display = 'block';
    } else {
      alert('This technician is already active');
    }
    return;
  }

  // All validations passed - add to queue
  console.log('[handleJoin] Adding technician to queue:', selectedTechnicianName);
  queue.push({name: selectedTechnicianName, held: false});
  log.unshift(stamp() + ` join: ${selectedTechnicianName}`);
  save();
  renderQueue();
  
  // Clear PIN field and error message on success
  pinInputEl.value = '';
  if (joinErrorEl) {
    joinErrorEl.textContent = '';
    joinErrorEl.style.display = 'none';
  }
  
  console.log('[handleJoin] Successfully added', selectedTechnicianName, 'to queue');

  // Join is done directly by worker (Tech action)
  const techActor = getActorForAction({ workerName: selectedTechnicianName });
  addHistoryEntry('Join', techActor, selectedTechnicianName);
  } catch (e) {
    console.error('[handleJoin] Error in handleJoin:', e);
    const joinErrorEl = document.getElementById('joinError');
    if (joinErrorEl) {
      joinErrorEl.textContent = 'Error: ' + (e.message || 'Unknown error');
      joinErrorEl.style.display = 'block';
    } else {
      alert('Error joining: ' + (e.message || 'Unknown error'));
    }
  }
}

// Keep backward compatibility
function join() {
  return handleJoin();
}

function startFirst(){

  const idx=queue.findIndex(x=>!x.held); if(idx===-1) return alert("No available worker (empty or all on HOLD)");

  const target=queue[idx]; guardStart(target.name, idx, ()=>startSpecific(idx));

}

function startSpecific(idx){

  const [it]=queue.splice(idx,1); service.push({name:it.name});

  log.unshift(stamp()+` START -> IN SERVICE: ${it.name}`); save(); renderQueue(); renderService();

  // Actor info is already set by guardStart (manager/admin code or worker PIN)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Worker PIN was used - tech action
    actor = getActorForAction({ workerName: it.name });
  }
  addHistoryEntry('Start (Available â†’ In service)', actor, it.name);

}

function toggleHold(i){ queue[i].held=!queue[i].held; log.unshift(stamp()+` ${queue[i].held?"HOLD":"RELEASE"}: ${queue[i].name}`); save(); renderQueue(); 

  // Actor info is already set by guardHold (manager/admin code)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry(queue[i].held ? 'Hold' : 'Release', actor, queue[i].name);

}

function finish(i){

  const [it]=service.splice(i,1);

  queue.push({name:it.name, held:false}); // back to end

  log.unshift(stamp()+` FINISH -> Back to end: ${it.name}`); save(); renderQueue(); renderService();

  // Actor info is already set by guardFinish (manager/admin code or worker PIN)
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Worker PIN was used - tech action
    actor = getActorForAction({ workerName: it.name });
  }
  addHistoryEntry('Finish (In service â†’ Available)', actor, it.name);

}

function move(i,d){ const j=i+d; if(j<0||j>=queue.length) return; const t=queue[j]; queue[j]=queue[i]; queue[i]=t; save(); renderQueue(); 

  // Reorder is done in reorder mode which requires manager/admin code
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const name = window.__ff_actorName || 'Manager';
    actor = { role, name };
  }
  addHistoryEntry('Reorder list', actor, '');

}

async function resetDay(){
  // Check if user is owner/admin - block if not
  if (typeof window.isCurrentUserOwner === 'function') {
    try {
      const isOwner = await window.isCurrentUserOwner();
      if (!isOwner) {
        alert("Not authorized - Only admin/owner can reset the day");
        return;
      }
    } catch (e) {
      console.warn('[Reset] Could not verify user role, proceeding with admin code check:', e);
      // Continue to admin code check if role verification fails
    }
  }
  
  // Step 1: Show confirmation modal
  const confirmed = await showResetConfirmation();
  if (!confirmed) {
    return; // User cancelled
  }
  
  // Step 2: Show admin/manager PIN modal (same as REORDER) with inline error handling
  const code = await showResetPinPrompt();
  if (code == null || !code) {
    return; // User cancelled or invalid code (error already shown)
  }
  
  // Set actor info if using securePromptOnce wrapper
  if (window.securePromptOnce) {
    // Actor info is already set by securePromptOnce wrapper
    window.__ff_lastValidatedCode = code;
  } else {
    // If using prompt, set actor info manually
    const actorInfo = getActorInfo(code, '');
    window.__ff_actorRole = actorInfo.actorRole;
    window.__ff_actorName = actorInfo.actorName;
    window.__ff_lastValidatedCode = code;
  }
  
  // Proceed with reset - clear queues only, NOT history
  queue = [];
  service = [];
  // History is NOT cleared - log and history arrays remain untouched
  save();
  renderQueue();
  renderService();
  
  // Tasks feature removed - no Tasks state to clear
}

// Helper function to show RESET confirmation modal (Step 1)
function showResetConfirmation() {
  return new Promise((resolve) => {
    const overlay = document.getElementById('resetConfirmOverlay');
    const cancelBtn = document.getElementById('resetConfirmCancel');
    const continueBtn = document.getElementById('resetConfirmContinue');
    
    if (!overlay || !cancelBtn || !continueBtn) {
      // Fallback to native confirm if modal elements not found
      resolve(confirm("Are you sure you want to RESET THE DAY? This will clear all queues. History will NOT be deleted."));
      return;
    }
    
    // Show modal
    overlay.style.display = 'flex';
    overlay.style.pointerEvents = 'auto';
    overlay.style.visibility = 'visible';
    
    // Clean up previous handlers
    const newCancelBtn = cancelBtn.cloneNode(true);
    const newContinueBtn = continueBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    continueBtn.parentNode.replaceChild(newContinueBtn, continueBtn);
    
    // Set up handlers
    newCancelBtn.onclick = () => {
      hideResetConfirmation();
      resolve(false);
    };
    
    newContinueBtn.onclick = () => {
      hideResetConfirmation();
      resolve(true);
    };
    
    // Close on overlay click (outside modal)
    const overlayClickHandler = (e) => {
      if (e.target === overlay) {
        hideResetConfirmation();
        overlay.removeEventListener('click', overlayClickHandler);
        resolve(false);
      }
    };
    overlay.addEventListener('click', overlayClickHandler);
    
    // Close on Escape key
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        hideResetConfirmation();
        document.removeEventListener('keydown', escapeHandler);
        resolve(false);
      }
    };
    document.addEventListener('keydown', escapeHandler);
  });
}

// Helper function to hide RESET confirmation modal
function hideResetConfirmation() {
  const overlay = document.getElementById('resetConfirmOverlay');
  if (overlay) {
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';
    overlay.style.visibility = 'hidden';
  }
}

// Helper function to show RESET PIN prompt with inline error handling (same as REORDER modal)
async function showResetPinPrompt() {
  if (!window.securePromptOnce) {
    // Fallback: native prompt if securePromptOnce not available
    const code = prompt("Enter admin/manager code to RESET");
    if (code == null) return null;
    if (isAdminCode(code) || isManagerCode(code)) {
      return code;
    } else {
      alert('Invalid admin/manager code - Reset cancelled');
      return null;
    }
  }
  
  // Use securePromptOnce but handle errors inline
  let code = await window.securePromptOnce("Enter admin/manager code to RESET");
  if (code == null) {
    return null; // User cancelled
  }
  
  // Verify PIN
  const isValid = isAdminCode(code) || isManagerCode(code);
  if (!isValid) {
    // Show error inline - reopen modal with error message
    const overlay = document.getElementById('codePromptOverlay');
    const msg = document.getElementById('codePromptMsg');
    const input = document.getElementById('codePromptInput');
    
    if (overlay && msg && input) {
      // Update message
      msg.textContent = 'Enter admin/manager code to RESET';
      msg.style.color = '#111';
      
      // Clear input
      input.value = '';
      input.type = 'password';
      
      // Create or update error element
      let errorEl = document.getElementById('codePromptError');
      if (!errorEl) {
        errorEl = document.createElement('div');
        errorEl.id = 'codePromptError';
        errorEl.style.cssText = 'color:#dc2626;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;';
        // Insert error before the "Forgot Admin PIN?" button container
        const forgotPinContainer = document.getElementById('codePromptForgotPin')?.parentElement;
        if (forgotPinContainer && forgotPinContainer.parentElement) {
          forgotPinContainer.parentElement.insertBefore(errorEl, forgotPinContainer);
        } else {
          // Fallback: insert before buttons
          const buttonsContainer = document.getElementById('codePromptOk')?.parentElement;
          if (buttonsContainer && buttonsContainer.parentElement) {
            buttonsContainer.parentElement.insertBefore(errorEl, buttonsContainer);
          }
        }
      }
      errorEl.textContent = 'Invalid admin/manager code';
      errorEl.style.display = 'block';
      
      // Show modal again
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      overlay.style.visibility = 'visible';
      
      // Focus input
      setTimeout(() => input.focus(), 50);
      
      // Wait for retry or cancel
      const retryCode = await window.securePromptOnce("Enter admin/manager code to RESET");
      if (retryCode == null) {
        // Hide error on cancel
        if (errorEl) errorEl.style.display = 'none';
        return null; // User cancelled
      }
      
      // Verify retry code
      const retryValid = isAdminCode(retryCode) || isManagerCode(retryCode);
      if (!retryValid) {
        // Still wrong - update error message
        if (errorEl) {
          errorEl.textContent = 'Invalid admin/manager code - Reset cancelled';
        }
        return null;
      }
      
      // Retry code is valid
      if (errorEl) errorEl.style.display = 'none';
      return retryCode;
    } else {
      // Modal elements not found - fallback to alert
      alert('Invalid admin/manager code - Reset cancelled');
      return null;
    }
  }
  
  return code; // Valid code
}



// Guards

function gateAdmin(){ const code=prompt("Admin code"); if(code===null) return false; return isAdminCode(code); }

function gateManager(){ const code=prompt("Manager code"); if(code===null) return false; return isManagerCode(code); }

function workerGate(name){ const w=settings.workers.find(x=>x.name===name); if(!w) return false; const code=prompt(`PIN for ${name}`); if(code===null) return false; return code.toString()===(w.pin||"").toString(); }

async function guardHold(fn){

  const entry = window.securePromptOnce

    ? await window.securePromptOnce('Enter admin or manager code')

    : prompt('Enter admin or manager code');

  if (entry == null) return;

  if (isAdminCode(entry) || isManagerCode(entry)) { 
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, '');
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    fn(); 
  }

  else alert('Not authorized');

}

async function guardStart(workerName, idx, fn){

  const entry = window.securePromptOnce ? await window.securePromptOnce('Enter admin/manager code or worker PIN to START') : prompt('Enter admin/manager code or worker PIN to START');

  if(entry==null) return;

  if(isAdminCode(entry)||isManagerCode(entry)) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, workerName);
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    return fn();
  }

  const w=settings.workers.find(x=>x.name===workerName);

  if(w && entry.toString()===(w.pin||"").toString()) {
    // Worker PIN - Tech action, clear any previous actor info
    window.__ff_actorRole = 'Tech';
    window.__ff_actorName = workerName;
    window.__ff_lastValidatedCode = null; // Clear code since it's worker action
    return fn();
  }

  alert("Not authorized");

}

async function guardFinish(workerName, fn){

  const entry = window.securePromptOnce ? await window.securePromptOnce('Enter admin/manager code or worker PIN to FINISH') : prompt('Enter admin/manager code or worker PIN to FINISH');

  if(entry==null) return;

  if(isAdminCode(entry)||isManagerCode(entry)) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = entry;
    // Actor info is already set by securePromptOnce wrapper, but if using prompt, set it here
    if (!window.securePromptOnce) {
      const actorInfo = getActorInfo(entry, workerName);
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }
    return fn();
  }

  const w=settings.workers.find(x=>x.name===workerName);

  if(w && entry.toString()===(w.pin||"").toString()) {
    // Worker PIN - Tech action, clear any previous actor info
    window.__ff_actorRole = 'Tech';
    window.__ff_actorName = workerName;
    window.__ff_lastValidatedCode = null; // Clear code since it's worker action
    return fn();
  }

  alert("Not authorized");

}



// Settings + Log

async function openSettingsSecure(){

  // Modal-based admin code prompt (with eye). No other logic changed.

  if(!window.securePromptOnce){ return alert("Admin only"); }

  const code = await window.securePromptOnce("Enter admin code");

  if(code==null || !isAdminCode(code)) { alert("Admin only"); return; }

  renderSettings();
  
  settingsDlg.showModal();

}

// Expose globally for onclick handlers
window.openSettingsSecure = openSettingsSecure;

function renderSettings(){

  // Admin code

  $("#adminCode").value=settings.adminCode||"";

  // Managers - only initialize if empty

  const mb=$("#managersBox");
  
  if (mb.children.length === 0) {
    // First time rendering - build all rows
    (settings.managers||[]).forEach((m,i)=>mb.appendChild(managerRow(i,m)));
  }

  // Brand

  $("#salonInput").value=settings.brand.name||""; logoPreview.src=settings.brand.logo||"";

  // Workers - only initialize if empty

  const wb=$("#workersBox");
  
  if (wb.children.length === 0) {
    // First time rendering - build structure and all rows
    
    // Global Color Palette (inside workersBox, above workers)
    const paletteRow = document.createElement("div");
    paletteRow.className = "row";
    paletteRow.style.cssText = "margin-bottom:12px;align-items:center;gap:12px";

    const paletteLabel = document.createElement("span");
    paletteLabel.textContent = "Color palette:";
    paletteLabel.style.cssText = "font-weight:600;font-size:13px";

    const paletteContainer = document.createElement("span");
    paletteContainer.className = "quick4";
    paletteContainer.style.cssText = "display:inline-flex;gap:6px;align-items:center";

    (settings.brandPalette||DEFAULTS.brandPalette).forEach((color,idx)=>{
      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.cssText = "width:18px;height:18px;border-radius:50%;border:1px solid #d0d0d0;cursor:pointer;background:"+color;
      dot.title = color;
      dot.dataset.paletteIndex = idx;
      dot.onclick = () => editPaletteColor(idx);
      paletteContainer.appendChild(dot);
    });

    paletteRow.appendChild(paletteLabel);
    paletteRow.appendChild(paletteContainer);
    wb.appendChild(paletteRow);

    // Create workers table container
    const workersTable = document.createElement("div");
    workersTable.className = "workers-table";

    // Create grid header row
    const workersHeader = document.createElement("div");
    workersHeader.className = "workers-header";

    const nameHeader = document.createElement("span");
    nameHeader.textContent = "";
    const pinHeader = document.createElement("span");
    pinHeader.textContent = "";
    const eyeHeader = document.createElement("span");
    eyeHeader.textContent = "";
    const buttonHeader = document.createElement("span");
    buttonHeader.textContent = "Button";
    buttonHeader.style.cssText = "text-align:center";
    const fontHeader = document.createElement("span");
    fontHeader.textContent = "Font";
    fontHeader.style.cssText = "text-align:center";
    const paletteHeader = document.createElement("span");
    paletteHeader.textContent = "";
    const deleteHeader = document.createElement("span");
    deleteHeader.textContent = "";

    workersHeader.append(nameHeader, pinHeader, eyeHeader, buttonHeader, fontHeader, paletteHeader, deleteHeader);
    workersTable.appendChild(workersHeader);

    // Add worker rows
    (settings.workers||[]).forEach((w,i)=>workersTable.appendChild(workerRow(i,w)));

    wb.appendChild(workersTable);
  }
  
  // Tasks-related UI removed (Task Reminders, Task Notes sections)
  // These will be rebuilt from scratch in the future

}

// Guard against infinite loop in renderTaskReminders
let isRenderingTaskReminders = false;

// Render task reminders settings
function renderTaskReminders() {
  // GUARD: Prevent infinite loop if already rendering
  if (isRenderingTaskReminders) {
    console.warn('[Tasks] renderTaskReminders already rendering, skipping to prevent loop');
    return;
  }
  
  const container = document.getElementById('taskRemindersBox');
  if (!container) return;
  
  // Set guard flag
  isRenderingTaskReminders = true;
  
  try {
    // Clear existing content
    container.innerHTML = '';
    
    // Ensure taskReminders exists
    if (!settings.taskReminders) {
      settings.taskReminders = {
        Opening: { enabled: false, type: 'daily', time: '07:30' },
        Closing: { enabled: false, type: 'daily', time: '16:00' },
        Weekly: { enabled: false, type: 'weekly', weekday: 1, time: '09:00' },
        Monthly: { enabled: false, type: 'monthly', day: 1, time: '09:00' },
        Yearly: { enabled: false, type: 'yearly', month: 1, day: 1, time: '09:00' }
      };
    }
    
    const categories = [
      { key: 'Opening', label: 'Opening', type: 'daily' },
      { key: 'Closing', label: 'Closing', type: 'daily' },
      { key: 'Weekly', label: 'Weekly', type: 'weekly' },
      { key: 'Monthly', label: 'Monthly', type: 'monthly' },
      { key: 'Yearly', label: 'Yearly', type: 'yearly' }
    ];
    
    categories.forEach(cat => {
      const reminder = settings.taskReminders[cat.key] || { enabled: false, type: cat.type };
      
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:16px;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb;';
      
      // Enable/disable checkbox
      const header = document.createElement('div');
      header.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:8px;';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = reminder.enabled || false;
      checkbox.id = `reminder-${cat.key}-enabled`;
      checkbox.addEventListener('change', () => {
        if (!settings.taskReminders[cat.key]) {
          settings.taskReminders[cat.key] = { enabled: false, type: cat.type };
        }
        settings.taskReminders[cat.key].enabled = checkbox.checked;
        save();
        // DEFERRED re-render to prevent infinite loop - use setTimeout to break recursion
        setTimeout(() => {
          isRenderingTaskReminders = false; // Clear flag before calling
          renderTaskReminders(); // Re-render to show/hide config
        }, 0);
      });
    
    const label = document.createElement('label');
    label.htmlFor = `reminder-${cat.key}-enabled`;
    label.textContent = cat.label;
    label.style.cssText = 'font-weight:600;font-size:14px;cursor:pointer;';
    
    header.appendChild(checkbox);
    header.appendChild(label);
    row.appendChild(header);
    
    // Configuration fields (only shown if enabled)
    if (checkbox.checked) {
      const configDiv = document.createElement('div');
      configDiv.style.cssText = 'margin-left:24px;display:flex;flex-direction:column;gap:8px;';
      
      if (cat.type === 'daily') {
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Start showing reminders at:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '07:30';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'weekly') {
        const weekdayLabel = document.createElement('label');
        weekdayLabel.textContent = 'Reminder weekday:';
        weekdayLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const weekdaySelect = document.createElement('select');
        weekdaySelect.style.cssText = 'width:140px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        weekdays.forEach((day, idx) => {
          const option = document.createElement('option');
          option.value = idx;
          option.textContent = day;
          if ((reminder.weekday || 1) === idx) option.selected = true;
          weekdaySelect.appendChild(option);
        });
        weekdaySelect.addEventListener('change', () => {
          settings.taskReminders[cat.key].weekday = parseInt(weekdaySelect.value);
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(weekdayLabel);
        configDiv.appendChild(weekdaySelect);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'monthly') {
        const dayLabel = document.createElement('label');
        dayLabel.textContent = 'Reminder day of month (1-28):';
        dayLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const dayInput = document.createElement('input');
        dayInput.type = 'number';
        dayInput.min = 1;
        dayInput.max = 28;
        dayInput.value = reminder.day || 1;
        dayInput.style.cssText = 'width:80px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        dayInput.addEventListener('change', () => {
          const day = Math.min(28, Math.max(1, parseInt(dayInput.value) || 1));
          settings.taskReminders[cat.key].day = day;
          dayInput.value = day;
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(dayLabel);
        configDiv.appendChild(dayInput);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      } else if (cat.type === 'yearly') {
        const monthLabel = document.createElement('label');
        monthLabel.textContent = 'Reminder month:';
        monthLabel.style.cssText = 'font-size:13px;color:#666;';
        
        const monthSelect = document.createElement('select');
        monthSelect.style.cssText = 'width:140px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        months.forEach((month, idx) => {
          const option = document.createElement('option');
          option.value = idx + 1;
          option.textContent = month;
          if ((reminder.month || 1) === (idx + 1)) option.selected = true;
          monthSelect.appendChild(option);
        });
        monthSelect.addEventListener('change', () => {
          settings.taskReminders[cat.key].month = parseInt(monthSelect.value);
          save();
          updateAllTabBadges();
        });
        
        const dayLabel = document.createElement('label');
        dayLabel.textContent = 'Reminder day:';
        dayLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const dayInput = document.createElement('input');
        dayInput.type = 'number';
        dayInput.min = 1;
        dayInput.max = 31;
        dayInput.value = reminder.day || 1;
        dayInput.style.cssText = 'width:80px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        dayInput.addEventListener('change', () => {
          const day = Math.min(31, Math.max(1, parseInt(dayInput.value) || 1));
          settings.taskReminders[cat.key].day = day;
          dayInput.value = day;
          save();
          updateAllTabBadges();
        });
        
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Reminder time:';
        timeLabel.style.cssText = 'font-size:13px;color:#666;margin-top:8px;';
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.value = reminder.time || '09:00';
        timeInput.style.cssText = 'width:120px;padding:6px 8px;border:1px solid #ddd;border-radius:6px;font-size:13px;';
        timeInput.addEventListener('change', () => {
          settings.taskReminders[cat.key].time = timeInput.value;
          save();
          updateAllTabBadges();
        });
        
        configDiv.appendChild(monthLabel);
        configDiv.appendChild(monthSelect);
        configDiv.appendChild(dayLabel);
        configDiv.appendChild(dayInput);
        configDiv.appendChild(timeLabel);
        configDiv.appendChild(timeInput);
      }
      
      row.appendChild(configDiv);
    }
    
    container.appendChild(row);
  });
    
    // Clear guard flag after rendering completes
    isRenderingTaskReminders = false;
  } catch (error) {
    console.error('[Tasks] Error in renderTaskReminders:', error);
    isRenderingTaskReminders = false; // Clear flag on error
  }
}

// Render incomplete tasks badge setting
function renderIncompleteTasksBadgeSetting() {
  const container = document.getElementById('taskNotesBox');
  if (!container) return;
  
  // Check if setting toggle already exists
  let toggleRow = document.getElementById('incompleteTasksBadgeToggle');
  if (!toggleRow) {
    toggleRow = document.createElement('div');
    toggleRow.id = 'incompleteTasksBadgeToggle';
    toggleRow.style.cssText = 'margin-bottom:20px;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb;';
    
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;';
    
    const label = document.createElement('label');
    label.textContent = 'Show incomplete tasks badge on Home screen';
    label.style.cssText = 'font-size:14px;font-weight:600;color:var(--text);cursor:pointer;';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = settings.showIncompleteTasksBadge === true;
    checkbox.style.cssText = 'width:18px;height:18px;cursor:pointer;';
    
    checkbox.addEventListener('change', (e) => {
      settings.showIncompleteTasksBadge = e.target.checked;
      save();
    });
    
    label.addEventListener('click', () => {
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    header.appendChild(label);
    header.appendChild(checkbox);
    
    const description = document.createElement('p');
    description.textContent = 'When enabled, a red badge with the number of incomplete tasks will appear on the Tasks button on the Home screen.';
    description.style.cssText = 'font-size:12px;color:var(--sub);margin:0;line-height:1.5;';
    
    toggleRow.appendChild(header);
    toggleRow.appendChild(description);
    
    // Insert before task notes section
    container.insertBefore(toggleRow, container.firstChild);
  } else {
    // Update checkbox state if it already exists
    const checkbox = toggleRow.querySelector('input[type="checkbox"]');
    if (checkbox) {
      checkbox.checked = settings.showIncompleteTasksBadge === true;
    }
  }
}

// Render task notes settings
function renderTaskNotes() {
  const container = document.getElementById('taskNotesBox');
  if (!container) return;
  
  // Clear existing content
  container.innerHTML = '';
  
  // Ensure taskNotes exists
  if (!settings.taskNotes) {
    settings.taskNotes = {
      opening: '',
      closing: '',
      weekly: '',
      monthly: '',
      yearly: ''
    };
  }
  
  const categories = [
    { key: 'opening', label: 'Opening tasks note' },
    { key: 'closing', label: 'Closing tasks note' },
    { key: 'weekly', label: 'Weekly tasks note' },
    { key: 'monthly', label: 'Monthly tasks note' },
    { key: 'yearly', label: 'Yearly tasks note' }
  ];
  
  categories.forEach(cat => {
    const note = settings.taskNotes[cat.key] || '';
    
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:16px;';
    
    const label = document.createElement('label');
    label.textContent = cat.label;
    label.style.cssText = 'display:block;font-size:13px;color:#666;font-weight:500;margin-bottom:6px;';
    
    const textarea = document.createElement('textarea');
    textarea.value = note || '';
    textarea.placeholder = `Note for ${cat.label.toLowerCase()} (optional)`;
    textarea.rows = 2;
    textarea.style.cssText = 'width:100%;border:1px solid #ddd;border-radius:6px;padding:8px 12px;font-size:13px;outline:none;background:#fff;font-family:inherit;resize:vertical;min-height:60px;';
    
    textarea.addEventListener('input', (e) => {
      const value = e.target.value.trim();
      if (!settings.taskNotes) {
        settings.taskNotes = {};
      }
      settings.taskNotes[cat.key] = value || '';
      // Auto-save on change
      save();
    });
    
    row.appendChild(label);
    row.appendChild(textarea);
    container.appendChild(row);
  });
}

// Append a single manager row without rebuilding the table
function appendManagerRow() {
  const mb = $("#managersBox");
  if (!mb) return;
  
  const index = settings.managers.length;
  const newManager = {name: "", code: ""};
  settings.managers.push(newManager);
  
  const row = managerRow(index, newManager);
  mb.appendChild(row);
  
  save();
}

// Update manager row indices after deletion
function updateManagerIndices() {
  const mb = $("#managersBox");
  if (!mb) return;
  
  const rows = mb.querySelectorAll('.manager-grid');
  rows.forEach((row, newIndex) => {
    const inputs = row.querySelectorAll('.mname, .mcode');
    const buttons = row.querySelectorAll('.mdel, .eyeBtn');
    
    inputs.forEach(input => {
      input.dataset.i = newIndex;
    });
    
    buttons.forEach(button => {
      button.dataset.i = newIndex;
    });
  });
}

// Append a single worker row without rebuilding the table
function appendWorkerRow() {
  const wb = $("#workersBox");
  if (!wb) return;
  
  // Find the workers table (should be the last child after palette row)
  const workersTable = wb.querySelector('.workers-table');
  if (!workersTable) {
    // If table doesn't exist, need to initialize first
    renderSettings();
    return;
  }
  
  const index = settings.workers.length;
  const newWorker = {
    name: "",
    pin: "",
    color: "#111827",
    fcolor: "#ffffff"
  };
  settings.workers.push(newWorker);
  
  const row = workerRow(index, newWorker);
  workersTable.appendChild(row);
  
  save();
}

// Update worker row indices after deletion
function updateWorkerIndices() {
  const wb = $("#workersBox");
  if (!wb) return;
  
  const workersTable = wb.querySelector('.workers-table');
  if (!workersTable) return;
  
  const rows = workersTable.querySelectorAll('.worker-row');
  rows.forEach((row, newIndex) => {
    const inputs = row.querySelectorAll('.wname, .wpin');
    const buttons = row.querySelectorAll('.wdel');
    const colorInputs = row.querySelectorAll('.wcolor, .wfont');
    
    // Update data-i for inputs
    inputs.forEach(input => {
      input.dataset.i = newIndex;
      input.dataset.index = newIndex;
    });
    
    // Update data-i for delete button
    buttons.forEach(button => {
      button.dataset.i = newIndex;
    });
    
    // Update data-index for color inputs
    colorInputs.forEach(input => {
      input.dataset.index = newIndex;
    });
  });
}

function editPaletteColor(index){

  const currentColor = (settings.brandPalette||DEFAULTS.brandPalette)[index]||"#111827";

  // Create a temporary color input to trigger the native color picker

  const colorInput = document.createElement("input");

  colorInput.type = "color";

  colorInput.value = currentColor;

  // Position the color picker near the Color palette row

  const paletteRow = document.querySelector("#workersBox .row:first-child");

  if(paletteRow){

    const rect = paletteRow.getBoundingClientRect();

    colorInput.style.position = "fixed";

    colorInput.style.left = `${rect.left + 150}px`;

    colorInput.style.top = `${rect.bottom + 40}px`;

    colorInput.style.zIndex = "10000";

  }else{

    colorInput.style.position = "fixed";

    colorInput.style.left = "50%";

    colorInput.style.top = "50%";

    colorInput.style.zIndex = "10000";

  }

  colorInput.style.opacity = "0";

  colorInput.style.pointerEvents = "none";

  document.body.appendChild(colorInput);

  // Cleanup function

  const cleanup = ()=>{

    if(document.body.contains(colorInput)){

      document.body.removeChild(colorInput);

    }

  };

  // Handle color change

  colorInput.addEventListener("change", ()=>{

    const newColor = colorInput.value;

    if(!settings.brandPalette) settings.brandPalette = DEFAULTS.brandPalette.slice();

    settings.brandPalette[index] = newColor;

    // Update all worker rows to reflect the new palette color

    renderSettings();

    cleanup();

  });

  // Handle cancel/close - only cleanup when dialog closes, not on timeout

  colorInput.addEventListener("cancel", cleanup);

  // Click outside to close - handle blur but don't auto-close immediately

  colorInput.addEventListener("blur", ()=>{

    // Small delay to allow change event to fire first

    setTimeout(()=>{

      if(document.body.contains(colorInput) && document.activeElement !== colorInput){

        cleanup();

      }

    }, 100);

  });

  colorInput.click();

}

function managerRow(i,m){

  const div=document.createElement("div"); div.className="manager-grid";

  div.innerHTML=`

    <input class="mname" data-i="${i}" type="text" placeholder="Manager name" value="${escapeHtml(m.name||"")}">

    <div style="display:flex;gap:8px;align-items:center">

      <input class="mcode" data-i="${i}" type="text" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" placeholder="Code" value="${escapeHtml(m.code||"")}" style="height:32px;padding:0 10px;width:120px">

      <button class="btn-mini eyeBtn" data-for="mcode" data-i="${i}" type="button">ğŸ‘</button>

    </div>

    <button class="btn-mini mdel" data-i="${i}" type="button">Delete</button>`;

  div.querySelector(".mdel").onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    settings.managers.splice(idx,1); 
    // Remove the row from DOM
    const row = e.target.closest('.manager-grid');
    if (row) row.remove();
    // Update indices of remaining rows
    updateManagerIndices();
    save();
  };

  div.querySelector(".eyeBtn").onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    const inp=div.querySelector('.mcode'); 
    // Toggle between password (hidden) and text (visible)
    inp.type = (inp.type === "password") ? "text" : "password";
  };
  
  // Apply numeric enforcement to the manager code input
  const mcodeInput = div.querySelector('.mcode');
  // Manager code input will be configured automatically by event delegation

  return div;

}







function workerRow(i,w){

  const wrap=document.createElement("div"); wrap.className="worker-row";

  // Name

  const name = document.createElement("input");

  name.className="wname"; name.dataset.i=i; name.type="text"; name.placeholder="Worker name";

  name.value = (w.name||"");

  name.style.cssText="flex:2;min-width:260px;height:32px;padding:0 10px";
  
  // Update settings.workers directly on input
  name.dataset.index = i;
  name.addEventListener("input", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].name = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });



  // PIN + eye (always password by default)

  const pinBox = document.createElement("div"); pinBox.className="pinwrap"; pinBox.style.cssText="grid-column:span 2";

  const pin = document.createElement("input");

  pin.className="wpin pin"; pin.dataset.i=i; pin.type="password"; pin.inputMode="numeric"; pin.pattern="[0-9]*"; pin.autocomplete="off"; pin.maxLength="6"; pin.placeholder="PIN"; pin.value=(w.pin||"");

  const eye = document.createElement("button"); eye.type="button"; eye.className="btn-mini"; eye.textContent="ğŸ‘";

  eye.onclick=()=>{ 
    // Toggle between password (hidden) and text (visible)
    pin.type = (pin.type === "password") ? "text" : "password";
  };
  
  // PIN input will be configured automatically by event delegation
  
  // Update settings.workers directly on input
  pin.dataset.index = i;
  pin.addEventListener("input", (e) => {
    // Enforce numeric-only input
    e.currentTarget.value = e.currentTarget.value.replace(/\D/g, "");
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].pin = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });

  pinBox.append(pin,eye);



  // Colors

  const bg = document.createElement("input"); bg.type="color"; bg.className="wcolor color"; bg.value=w.color||"#111827";
  
  // Update settings.workers directly on change
  bg.dataset.index = i;
  bg.addEventListener("change", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].color = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });

  const font = document.createElement("input"); font.type="color"; font.className="wfont color"; font.value=w.fcolor||"#ffffff";
  
  // Update settings.workers directly on change
  font.dataset.index = i;
  font.addEventListener("change", (e) => {
    const idx = Number(e.currentTarget.dataset.index);
    if (settings.workers[idx]) {
      settings.workers[idx].fcolor = e.currentTarget.value;
      save(); // Auto-save on change
    }
  });



  // Quick dots - now use global brandPalette

  const quick = document.createElement("span"); quick.className="quick4";

  const palette = settings.brandPalette || DEFAULTS.brandPalette;

  palette.forEach((hex,idx)=>{

    const d=document.createElement('span'); d.className='dot'; d.style.background=hex; d.title=hex;

    d.dataset.paletteIndex = idx;

    // Clicking a palette dot edits the global palette, not the worker's colors

    d.onclick=()=>{ editPaletteColor(idx); };

    quick.appendChild(d);

  });



  // Delete

  const del = document.createElement("button"); del.type="button"; del.className="btn-mini wdel"; del.dataset.i=i; del.textContent="Delete";

  del.style.marginLeft = "2px";

  del.onclick=e=>{ 
    const idx=+e.target.dataset.i; 
    settings.workers.splice(idx,1); 
    // Remove the row from DOM
    const row = e.target.closest('.worker-row');
    if (row) row.remove();
    // Update indices of remaining rows
    updateWorkerIndices();
    save();
  };



  wrap.append(name, pinBox, bg, font, quick, del);

  return wrap;

}





$("#addManager").onclick=() => {
  appendManagerRow();
};

$("#addWorker").onclick=() => {
  appendWorkerRow();
};



async function saveSettings(e){

  // collect

  settings.adminCode=$("#adminCode").value||"5050";

  // managers

  const mnames=$$(".mname").map(e=>e.value.trim()); const mcodes=$$(".mcode").map(e=>(e.value||"").toString());

  const mans=[]; mnames.forEach((n,i)=>{ if(n){ mans.push({name:n, code:mcodes[i]||""}); } });

  settings.managers=mans;

  // brand

  settings.brand.name=$("#salonInput").value||"";

  if(logoFile.files && logoFile.files[0]) settings.brand.logo=await toDataURL(logoFile.files[0]);

  // workers
  // Workers are already synced to settings.workers via input handlers in workerRow()
  // Here we just clean up: remove empty workers and dedupe by name
  const validWorkers = [];
  const seen = new Set();
  
  settings.workers.forEach((w) => {
    // Skip empty workers (no name)
    if (!w || !w.name || !w.name.trim()) {
      return;
    }
    
    // Skip duplicates (keep first occurrence)
    if (seen.has(w.name)) {
      return;
    }
    
    seen.add(w.name);
    validWorkers.push({
      name: w.name.trim(),
      pin: (w.pin || "").toString() || "0000",
      color: w.color || "#111827",
      fcolor: w.fcolor || "#ffffff"
    });
  });
  
  settings.workers = validWorkers.slice(0, 48);

  // Save brandPalette (it's already updated in memory when edited)

  if(!settings.brandPalette) settings.brandPalette = DEFAULTS.brandPalette.slice();

  save(); 
  renderBrand(); 
  renderSelect(); // Refresh dropdown when settings are saved
  renderQueue(); 
  renderService();
  console.log('[saveSettings] Settings saved, dropdown refreshed');

}

$("#saveSettings").addEventListener("click", e=>{e.preventDefault(); saveSettings(); settingsDlg.close();});



async function openLog(){ 
  if (!window.securePromptOnce) return alert("Admin only");
  const code = await window.securePromptOnce("Enter admin code to view log");
  if (code == null || !isAdminCode(code)) {
    alert("Admin only");
    return;
  }
  openHistoryModal();
}

$("#exportLog").addEventListener("click", e=>{ e.preventDefault(); const blob=new Blob([log.join("\n")],{type:"text/plain"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="fair-flow-log.txt"; a.click(); URL.revokeObjectURL(url); });

$("#clearLog").addEventListener("click", e=>{ e.preventDefault(); if(confirm("Clear history?")){ log=[]; save(); openLog(); } });



// Bind

// Connect JOIN button handler - ensure it runs after DOM is ready
function initializeJoinButton() {
  try {
    const joinBtnEl = document.getElementById("joinBtn");
    if (joinBtnEl) {
      // Remove any existing handlers by cloning
      const parent = joinBtnEl.parentNode;
      if (parent) {
        const newJoinBtn = joinBtnEl.cloneNode(true);
        parent.replaceChild(newJoinBtn, joinBtnEl);
        const freshJoinBtn = document.getElementById("joinBtn");
        
        if (freshJoinBtn) {
          freshJoinBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoin();
          };
          freshJoinBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoin();
          }, { capture: true });
          freshJoinBtn.style.cursor = 'pointer';
          freshJoinBtn.style.pointerEvents = 'auto';
          freshJoinBtn.style.position = 'relative';
          freshJoinBtn.style.zIndex = '100';
          freshJoinBtn.disabled = false;
          freshJoinBtn.removeAttribute('disabled');
          console.log('[Init] JOIN button handler connected successfully');
          return true;
} else {
          console.error('[Init] joinBtn not found after cloning');
        }
      }
    } else {
      console.warn('[Init] joinBtn element not found');
      return false;
    }
  } catch (e) {
    console.error('[Init] Error connecting JOIN button handler:', e);
    return false;
  }
  return false;
}

// Initialize JOIN button when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      if (!initializeJoinButton()) {
        // Retry after delay if first attempt failed
        setTimeout(initializeJoinButton, 500);
      }
    }, 100);
  });
} else {
  // DOM already ready
  setTimeout(() => {
    if (!initializeJoinButton()) {
      // Retry after delay if first attempt failed
      setTimeout(initializeJoinButton, 500);
    }
  }, 100);
}

// Expose initializeJoinButton globally for app.js to call
window.initializeJoinButton = initializeJoinButton;

// Also keep backward compatibility
if (typeof window !== 'undefined') {
  window.join = handleJoin;
  window.handleJoin = handleJoin;
}

// =====================
// Remove Blocking Overlays Function
// =====================
/**
 * Detects and removes any overlays that might be blocking clicks on the header
 * This function should be called on page load and after any modal operations
 */
function removeBlockingOverlays() {
  try {
    console.log('[Overlay Audit] Scanning for blocking overlays...');
    
    // List of known modal/overlay IDs that should be hidden
    const knownOverlayIds = [
      'codePromptOverlay',
      'log-secure-overlay',
      'historyModal',
      'tasksAdminAccessModal',
      'tasksResetModal',
      'tasksFinishModal',
      'tasksSelectModal',
      'tasksEditModal',
      'tasksInstructionsModal',
      'tasksScreen'
    ];
    
    // Check known overlays
    knownOverlayIds.forEach(overlayId => {
      const overlay = document.getElementById(overlayId);
      if (overlay) {
        const computedStyle = window.getComputedStyle(overlay);
        const display = computedStyle.display;
        const zIndex = parseInt(computedStyle.zIndex) || 0;
        const position = computedStyle.position;
        
        // If overlay is visible and has high z-index, ensure it's properly hidden
        if (display !== 'none' && zIndex >= 1000 && (position === 'fixed' || position === 'absolute')) {
          console.warn(`[Overlay Audit] Found visible blocking overlay: ${overlayId} (z-index: ${zIndex}, display: ${display})`);
          overlay.style.display = 'none';
          overlay.style.pointerEvents = 'none';
          overlay.style.visibility = 'hidden';
          overlay.style.opacity = '0';
        } else if (display === 'none') {
          // Even when hidden, ensure pointer-events is none
          overlay.style.pointerEvents = 'none';
        }
      }
    });
    
    // Scan for any fixed/absolute positioned elements with high z-index that might be blocking
    const allElements = document.querySelectorAll('*');
    let blockingCount = 0;
    
    allElements.forEach(el => {
      const computedStyle = window.getComputedStyle(el);
      const zIndex = parseInt(computedStyle.zIndex) || 0;
      const position = computedStyle.position;
      const display = computedStyle.display;
      const pointerEvents = computedStyle.pointerEvents;
      
      // Check if element is a potential blocker
      if (
        (position === 'fixed' || position === 'absolute') &&
        zIndex >= 1000 &&
        zIndex < 100000 && // Don't touch header (z-index: 100000)
        display !== 'none' &&
        pointerEvents !== 'none' &&
        !el.closest('.header') && // Don't touch header elements
        !el.closest('.toolbar') && // Don't touch toolbar elements
        !knownOverlayIds.includes(el.id) // Skip known overlays (already handled)
      ) {
        // Check if element covers the header area (top 100px of viewport)
        const rect = el.getBoundingClientRect();
        if (rect.top <= 100 && rect.bottom >= 0 && rect.left <= window.innerWidth && rect.right >= 0) {
          console.warn(`[Overlay Audit] Found potential blocking element:`, {
            id: el.id,
            className: el.className,
            zIndex: zIndex,
            position: position,
            display: display,
            pointerEvents: pointerEvents,
            rect: { top: rect.top, bottom: rect.bottom, left: rect.left, right: rect.right }
          });
          
          // If it's not a known modal content, set pointer-events to none
          if (!el.closest('dialog') && !el.classList.contains('code-dialog') && !el.closest('.history-modal-dialog')) {
            el.style.pointerEvents = 'none';
            blockingCount++;
          }
        }
      }
    });
    
    if (blockingCount > 0) {
      console.log(`[Overlay Audit] Fixed ${blockingCount} potential blocking elements`);
    } else {
      console.log('[Overlay Audit] No blocking overlays found');
    }
    
    // Ensure header is always on top
    const header = document.querySelector('.header');
    if (header) {
      header.style.zIndex = '100000';
      header.style.pointerEvents = 'auto';
      header.style.position = 'sticky';
    }
    
    // Ensure toolbar buttons are clickable
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => {
      btn.style.zIndex = '100001';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
    });
    
  } catch (e) {
    console.error('[Overlay Audit] Error scanning for blocking overlays:', e);
  }
}

// Run overlay audit on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(removeBlockingOverlays, 100);
  });
} else {
  setTimeout(removeBlockingOverlays, 100);
}

// Expose globally for manual calls
window.removeBlockingOverlays = removeBlockingOverlays;

startFirstBtn.onclick=startFirst;

// adminBtn.onclick handler removed - button no longer exists
// adminBtn.onclick = async () => {
//   const code = window.securePromptOnce ? await window.securePromptOnce("Enter admin code") : prompt("Enter admin code");
//   if(code!==null) alert(isAdminCode(code)?"Admin verified.":"Wrong code");
// };

// resetBtn.onclick is set later with wrapper function to ensure tasksScreen is hidden
// resetBtn.onclick=resetDay; // Removed - now using resetDayWithNav wrapper

// Reorder handler - wrapped in try/catch for safety
async function handleReorderClick() {
  try {
  console.log('Reorder clicked');
  ensureTasksScreenHidden();

  // Secure prompt just for REORDER (no changes elsewhere)

  let ok = false;
  let code = null;

  if (window.securePromptOnce) {

    code = await window.securePromptOnce("Enter admin/manager code to REORDER");

    if (code == null) return;

    ok = (isAdminCode(code) || isManagerCode(code));

  } else {

    // Fallback: native prompt if securePromptOnce not available

    code = prompt("Admin or manager code");

    if (code == null) return;

    ok = (isAdminCode(code) || isManagerCode(code));
    
    // If using prompt, set actor info manually
    if (ok) {
      const actorInfo = getActorInfo(code, '');
      window.__ff_actorRole = actorInfo.actorRole;
      window.__ff_actorName = actorInfo.actorName;
    }

  }

  if (ok) {
    // Store the validated code for later use in addHistoryEntry
    window.__ff_lastValidatedCode = code;

    reorderMode = !reorderMode; 
    renderQueue(); 
    
    // Update button appearance based on reorder mode
    const btn = document.getElementById('reorderBtn');
    const header = document.getElementById('reorderHeader');
      if (btn) {
    if (reorderMode) {
      btn.textContent = 'Reorder mode';
      btn.classList.remove('btn-pill');
      btn.classList.add('btn-primary');
      if (header) header.style.display = 'block';
      
      // Ensure "+ Add technician" button handler is properly attached when entering reorder mode
      const addTechBtn = document.getElementById('addTechBtn');
      if (addTechBtn) {
        // Reattach handler to ensure it works in reorder mode
        addTechBtn.onclick = openAddTechDialog;
        addTechBtn.style.pointerEvents = 'auto';
        addTechBtn.style.cursor = 'pointer';
        console.log('[Reorder] Add technician button handler reattached');
      }
    } else {
      btn.textContent = 'Reorder';
      btn.classList.remove('btn-primary');
      btn.classList.add('btn-pill');
      if (header) header.style.display = 'none';
    }
      }
  } else {
    alert("Not authorized");
    }
  } catch (e) {
    console.error('[Navigation] Error in handleReorderClick:', e);
    alert('Error in reorder: ' + (e.message || 'Unknown error'));
  }
}

// Expose globally
window.handleReorderClick = handleReorderClick;

// Attach handler safely - will be re-initialized in initializeNavigationButtons
try {
  if (reorderBtn) {
    reorderBtn.onclick = handleReorderClick;
  }
} catch (e) {
  console.error('[Init] Error attaching reorder handler:', e);
}

const historyButton = document.getElementById('logBtn');
const historyModal = document.getElementById('historyModal');
const historyCloseBtn = document.getElementById('historyCloseBtn');
const historyBackdrop = document.querySelector('.history-modal-backdrop');

function openHistoryModal() {
  if (!historyModal) return;
  historyModal.classList.remove('hidden');
  renderHistory();
}

function closeHistoryModal() {
  if (!historyModal) return;
  historyModal.classList.add('hidden');
}

if (historyButton) {
  historyButton.addEventListener('click', () => {
    openLog();
  });
}

if (historyCloseBtn) {
  historyCloseBtn.addEventListener('click', closeHistoryModal);
}

if (historyBackdrop) {
  historyBackdrop.addEventListener('click', closeHistoryModal);
}

const historyExportBtn = document.getElementById('historyExportBtn');
const historyClearBtn = document.getElementById('historyClearBtn');
const historyCloseBtn2 = document.getElementById('historyCloseBtn2');

function exportHistory() {
  const blob = new Blob([history.map(entry => {
    const d = entry.timestamp;
    // Backwards compatibility: handle old structure
    let role = entry.role || entry.actorRole;
    let performedBy = entry.performedBy || entry.actorName;
    let worker = entry.worker || entry.workerName;
    
    // Try to get from old structure if missing
    if (!performedBy) {
      if (entry.actorName) {
        performedBy = entry.actorName;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        performedBy = entry.performedBy.name || '-';
      } else {
        performedBy = '-';
      }
    }
    
    if (!role) {
      if (entry.actorRole) {
        role = entry.actorRole;
      } else if (entry.performedBy && typeof entry.performedBy === 'object') {
        role = entry.performedBy.role || 'Tech';
      } else {
        role = 'Tech';
      }
    }
    
    if (!worker && entry.workerName) {
      worker = entry.workerName;
    }
    
    return `${formatHistoryDate(d)},${formatHistoryTime(d)},${entry.action},${role || '-'},${performedBy || '-'},${worker || ''}`;
  }).join('\n')], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'fair-flow-history.txt';
  a.click();
  URL.revokeObjectURL(url);
}

function clearHistory() {
  if (!confirm("Clear history?")) return;
  history.length = 0;
  renderHistory();
}

if (historyExportBtn) {
  historyExportBtn.addEventListener('click', exportHistory);
}

if (historyClearBtn) {
  historyClearBtn.addEventListener('click', () => {
    clearHistory();
  });
}

if (historyCloseBtn2) {
  historyCloseBtn2.addEventListener('click', closeHistoryModal);
}

// Helper function to hide tasksScreen if visible and restore main view
// Tasks feature removed - this is now a no-op but kept for compatibility
function ensureTasksScreenHidden() {
  try {
    // Tasks feature removed - just ensure main content is visible
    const mainContent = document.querySelector('#owner-view .wrap');
    const joinBar = document.getElementById('joinBar');
    
    if (mainContent && mainContent.style.display === 'none') {
      mainContent.style.display = 'block';
    }
    if (joinBar && joinBar.style.display === 'none') {
      joinBar.style.display = 'flex';
    }
  } catch (e) {
    console.warn('[Navigation] Error in ensureTasksScreenHidden:', e);
  }
}

// Initialize navigation on page load
function initializeNavigation() {
  try {
  console.log('[Navigation] Initializing navigation handlers');
  
    // Ensure tasksScreen is hidden on load (Tasks feature removed - safe no-op)
  ensureTasksScreenHidden();
  
  // Ensure header buttons are all properly set up
  const header = document.querySelector('.header');
  if (header) {
    header.style.zIndex = '201';
    header.style.pointerEvents = 'auto';
    
    const headerButtons = header.querySelectorAll('button');
      if (headerButtons) {
    headerButtons.forEach(btn => {
          if (btn) {
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.zIndex = '202';
      btn.style.position = 'relative';
      console.log('[Navigation] Initialized button:', btn.id || btn.textContent);
          }
        });
      }
    } else {
      console.warn('[Navigation] Missing element: .header');
    }
  } catch (e) {
    console.error('[Navigation] initializeNavigation failed', e);
  }
}

// Run initialization when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeNavigation);
} else {
  initializeNavigation();
}

// Wrap navigation handlers to ensure tasksScreen is hidden
// Use window properties to avoid TDZ issues - functions are hoisted but consts are not
if (!window.__originalOpenLog) {
  window.__originalOpenLog = openLog;
}
if (!window.__originalOpenSettingsSecure) {
  window.__originalOpenSettingsSecure = openSettingsSecure;
}
if (!window.__originalResetDay) {
  window.__originalResetDay = resetDay;
}

async function openLogWithNav() {
  try {
  console.log('History clicked');
  ensureTasksScreenHidden();
  return (window.__originalOpenLog || openLog)();
  } catch (e) {
    console.error('[Navigation] Error in openLogWithNav:', e);
  }
}

async function openSettingsSecureWithNav() {
  try {
  console.log('Settings clicked');
  ensureTasksScreenHidden();
  return (window.__originalOpenSettingsSecure || openSettingsSecure)();
  } catch (e) {
    console.error('[Navigation] Error in openSettingsSecureWithNav:', e);
  }
}

async function resetDayWithNav() {
  try {
  console.log('RESET clicked');
  ensureTasksScreenHidden();
  await (window.__originalResetDay || resetDay)();
  } catch (e) {
    console.error('[Navigation] Error in resetDayWithNav:', e);
  }
}

// Safe button initialization function
function initializeNavigationButtons() {
  try {
    // History button
    const logBtnEl = document.getElementById("logBtn") || logBtn;
    if (logBtnEl) {
      logBtnEl.onclick = openLogWithNav;
      logBtnEl.style.cursor = 'pointer';
      logBtnEl.style.pointerEvents = 'auto';
      logBtnEl.disabled = false;
      logBtnEl.removeAttribute('disabled');
      console.log('[Navigation] History button initialized');
    } else {
      console.warn('[Navigation] Missing element: logBtn');
    }

    // Settings button
    const settingsBtnEl = document.getElementById("settingsBtn") || settingsBtn;
    if (settingsBtnEl) {
      settingsBtnEl.onclick = openSettingsSecureWithNav;
      settingsBtnEl.style.cursor = 'pointer';
      settingsBtnEl.style.pointerEvents = 'auto';
      settingsBtnEl.disabled = false;
      settingsBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Settings button initialized');
    } else {
      console.warn('[Navigation] Missing element: settingsBtn');
    }

    // Reset button
    const resetBtnEl = document.getElementById("resetBtn") || resetBtn;
    if (resetBtnEl) {
      resetBtnEl.onclick = resetDayWithNav;
      resetBtnEl.style.cursor = 'pointer';
      resetBtnEl.style.pointerEvents = 'auto';
      resetBtnEl.disabled = false;
      resetBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Reset button initialized');
    } else {
      console.warn('[Navigation] Missing element: resetBtn');
    }

    // Reorder button
    const reorderBtnEl = document.getElementById("reorderBtn") || reorderBtn;
    if (reorderBtnEl) {
      if (typeof window.handleReorderClick === 'function') {
        reorderBtnEl.onclick = window.handleReorderClick;
      } else if (typeof handleReorderClick === 'function') {
        reorderBtnEl.onclick = handleReorderClick;
      }
      reorderBtnEl.style.cursor = 'pointer';
      reorderBtnEl.style.pointerEvents = 'auto';
      reorderBtnEl.disabled = false;
      reorderBtnEl.removeAttribute('disabled');
      console.log('[Navigation] Reorder button initialized');
    } else {
      console.warn('[Navigation] Missing element: reorderBtn');
    }
  } catch (e) {
    console.error('[Navigation] Error initializing navigation buttons:', e);
  }
}

// Initialize buttons when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(initializeNavigationButtons, 100);
  });
} else {
  setTimeout(initializeNavigationButtons, 100);
}

// Expose for re-initialization after login
window.initializeNavigationButtons = initializeNavigationButtons;

// Get currently active staff member name
function getCurrentActiveStaffName() {
  // Check if there's a staff member in service (most recent activity)
  if (service && service.length > 0) {
    return service[0].name;
  }
  // Check if there's a staff member in queue
  if (queue && queue.length > 0) {
    return queue[0].name;
  }
  // Fallback to nameSelect value if set
  const nameSelect = document.getElementById('nameSelect');
  if (nameSelect && nameSelect.value) {
    return nameSelect.value;
  }
  return null;
}

// Tasks feature completely removed - all Tasks-related code has been deleted
// Stub TasksComponent to prevent errors if anything tries to access it
window.TasksComponent = {
  mount: function() { 
    console.warn('[Tasks] Tasks feature removed - mount() is a no-op');
  },
  unmount: function() { 
    console.warn('[Tasks] Tasks feature removed - unmount() is a no-op');
  },
  isMounted: function() { 
    return false; 
  },
  getCurrentCategory: function() { 
    return null; 
  },
  verifyHeaderButtons: function() { 
    return {}; 
  }
};

// Legacy Tasks functions removed - stubs to prevent errors
function showTasksScreen() {
  console.warn('[Tasks] Tasks feature removed - showTasksScreen() is a no-op');
}

function goBackToMainScreen(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.warn('[Tasks] Tasks feature removed - goBackToMainScreen() is a no-op');
}

function initTasksTabs() {
  // No-op - Tasks feature removed
}

function updateTaskNoteDisplay(category) {
  // No-op - Tasks feature removed
}

// Expose stubs globally to prevent errors
window.showTasksScreen = showTasksScreen;
window.goBackToMainScreen = goBackToMainScreen;
window.updateTaskNoteDisplay = updateTaskNoteDisplay;

// Remove all Tasks state and data structures
// Tasks feature removed - no Tasks data to initialize

// All Tasks-related helper functions removed - they referenced undefined variables
// No Tasks code remains in the main application

// Add Technician dialog functions (non-Tasks code starts here)
  /**
   * Track and schedule timeout
   */
  function scheduleTimeout(callback, delay) {
    const timerId = setTimeout(() => {
      callback();
      resources.timers.delete(timerId);
    }, delay);
    resources.timers.add(timerId);
    return timerId;
  }
  
  /**
   * Track and schedule animation frame
   */
  function scheduleAnimationFrame(callback) {
    const rafId = requestAnimationFrame(() => {
      callback();
      resources.animationFrames.delete(rafId);
    });
    resources.animationFrames.add(rafId);
    return rafId;
  }
  
  /**
   * Add tracked event listener
   */
  function addTrackedEventListener(element, event, handler, options) {
    if (!element) return;
    
    element.addEventListener(event, handler, options);
    
    if (!resources.eventListeners.has(element)) {
      resources.eventListeners.set(element, []);
    }
    resources.eventListeners.get(element).push({ event, handler, options });
  }
  
  /**
   * Close all modals that might block clicks
   */
  function closeAllBlockingModals() {
    const modalIds = [
      'tasksAdminAccessModal',
      'tasksResetModal',
      'tasksFinishModal',
      'tasksSelectModal',
      'tasksEditModal',
      'tasksInstructionsModal',
      'codePromptOverlay',
      'log-secure-overlay',
      'historyModal'
    ];
    
    modalIds.forEach(modalId => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = 'none';
        modal.style.pointerEvents = 'none';
        modal.style.visibility = 'hidden';
        modal.style.opacity = '0';
        modal.style.zIndex = '-1';
        if (modal.classList) {
          modal.classList.add('hidden');
        }
      }
    });
    
    // Close any dynamically created overlays with high z-index
    const allOverlays = document.querySelectorAll('[style*="z-index"][style*="position:fixed"]');
    allOverlays.forEach(overlay => {
      const zIndex = parseInt(window.getComputedStyle(overlay).zIndex) || 0;
      const display = window.getComputedStyle(overlay).display;
      if (zIndex >= 1000 && display !== 'none' && overlay.id !== 'tasksScreen') {
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        overlay.style.visibility = 'hidden';
        overlay.style.opacity = '0';
        overlay.style.zIndex = '-1';
      }
    });
  }
  
  /**
   * Apply header styles for Tasks screen (stores originals)
   */
  function applyHeaderStyles() {
    if (!elements.header) return;
    
    storeOriginalStyle(elements.header, ['zIndex', 'pointerEvents', 'position']);
    elements.header.style.zIndex = '400';
    elements.header.style.pointerEvents = 'auto';
    elements.header.style.position = 'sticky';
    
    const headerButtons = elements.header.querySelectorAll('button');
    headerButtons.forEach(btn => {
      storeOriginalStyle(btn, ['zIndex', 'pointerEvents', 'cursor', 'position']);
      btn.style.zIndex = '600';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.position = 'relative';
    });
    
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => {
      storeOriginalStyle(btn, ['zIndex', 'pointerEvents', 'cursor', 'position']);
      btn.style.zIndex = '600';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.position = 'relative';
    });
  }
  
  /**
   * Restore header styles to original values
   */
  function restoreHeaderStyles() {
    if (elements.header) {
      restoreOriginalStyle(elements.header);
      
      const headerButtons = elements.header.querySelectorAll('button');
      headerButtons.forEach(btn => restoreOriginalStyle(btn));
    }
    
    const toolbarButtons = document.querySelectorAll('.toolbar button');
    toolbarButtons.forEach(btn => restoreOriginalStyle(btn));
  }
  
  /**
   * Initialize header buttons (Back, Settings, Reset)
   * Enhanced with comprehensive verification and error handling
   */
  function initializeHeaderButtons() {
    console.log('[Tasks] Initializing header buttons...');
    
    // Helper function to initialize a single button
    function initButton(buttonId, buttonName, handlerFunction) {
      let button = document.getElementById(buttonId);
      
      if (!button) {
        console.error(`[Tasks] ${buttonName} button (${buttonId}) not found in DOM`);
        return false;
      }
      
      console.log(`[Tasks] Found ${buttonName} button, cloning to remove old listeners...`);
      
      // Clone to remove old listeners
      const parent = button.parentNode;
      if (!parent) {
        console.error(`[Tasks] ${buttonName} button has no parent node`);
        return false;
      }
      
      const newBtn = button.cloneNode(true);
      parent.replaceChild(newBtn, button);
      
      // Get fresh reference
      button = document.getElementById(buttonId);
      if (!button) {
        console.error(`[Tasks] ${buttonName} button not found after cloning`);
        return false;
      }
      
      // Create handler with comprehensive logging
      const handler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log(`[Tasks] ${buttonName} button clicked`);
        try {
          handlerFunction(e);
        } catch (error) {
          console.error(`[Tasks] Error in ${buttonName} handler:`, error);
        }
      };
      
      // Attach event listener (tracked for cleanup)
      addTrackedEventListener(button, 'click', handler);
      
      // Also set onclick as fallback (will be overridden by addEventListener, but ensures compatibility)
      button.onclick = handler;
      
      // CRITICAL: Set all interactivity styles explicitly
      button.style.pointerEvents = 'auto';
      button.style.cursor = 'pointer';
      button.style.position = 'relative';
      button.style.zIndex = '501';
      button.style.display = button.style.display || 'flex'; // Preserve display
      
      // Ensure button is not disabled
      button.disabled = false;
      button.removeAttribute('disabled');
      
      // Verify styles were applied
      const computedStyle = window.getComputedStyle(button);
      const pointerEvents = computedStyle.pointerEvents;
      const zIndex = computedStyle.zIndex;
      
      console.log(`[Tasks] ${buttonName} button initialized:`, {
        id: buttonId,
        pointerEvents: pointerEvents,
        zIndex: zIndex,
        cursor: computedStyle.cursor,
        position: computedStyle.position,
        disabled: button.disabled
      });
      
      // Warn if pointer-events is not auto
      if (pointerEvents !== 'auto') {
        console.warn(`[Tasks] WARNING: ${buttonName} button pointer-events is "${pointerEvents}", expected "auto"`);
        // Force it
        button.style.setProperty('pointer-events', 'auto', 'important');
      }
      
      return true;
    }
    
    // Initialize Back button
    const backInitialized = initButton('tasksBackBtn', 'Back', (e) => {
      TasksComponent.unmount();
    });
    
    // Initialize Settings button
    const settingsInitialized = initButton('tasksSettingsBtn', 'Settings', (e) => {
      if (typeof openTasksAdminAccessModal === 'function') {
        openTasksAdminAccessModal(e);
      } else {
        console.error('[Tasks] openTasksAdminAccessModal function not found');
      }
    });
    
    // Initialize Reset button
    const resetInitialized = initButton('tasksResetBtn', 'Reset', (e) => {
      if (typeof openTasksResetModal === 'function') {
        openTasksResetModal();
      } else {
        console.error('[Tasks] openTasksResetModal function not found');
      }
    });
    
    // Update element references
    elements.backBtn = document.getElementById('tasksBackBtn');
    elements.settingsBtn = document.getElementById('tasksSettingsBtn');
    elements.resetBtn = document.getElementById('tasksResetBtn');
    
    // Verify all buttons were initialized
    const allInitialized = backInitialized && settingsInitialized && resetInitialized;
    
    if (allInitialized) {
      console.log('[Tasks] All header buttons initialized successfully');
    } else {
      console.warn('[Tasks] Some header buttons failed to initialize:', {
        back: backInitialized,
        settings: settingsInitialized,
        reset: resetInitialized
      });
    }
    
    // Additional verification: Check parent container
    const headerRow = elements.backBtn?.parentElement;
    if (headerRow) {
      const headerRowStyle = window.getComputedStyle(headerRow);
      console.log('[Tasks] Header row styles:', {
        pointerEvents: headerRowStyle.pointerEvents,
        zIndex: headerRowStyle.zIndex,
        position: headerRowStyle.position
      });
      
      // Ensure header row doesn't block clicks
      if (headerRowStyle.pointerEvents === 'none') {
        console.warn('[Tasks] Header row has pointer-events:none, fixing...');
        headerRow.style.pointerEvents = 'auto';
      }
    }
    
    return allInitialized;
  }
  
  /**
   * Initialize category tabs
   */
  function initializeTabs() {
    if (!elements.tabs || elements.tabs.length === 0) {
      console.log('[Tasks] No tabs found');
      return;
    }
    
    const allTabs = Array.from(elements.tabs);
    
    allTabs.forEach(tab => {
      // Remove old onclick
      tab.onclick = null;
      
      // Add new listener
      const handler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const clickedTab = this;
        const clickedCategory = clickedTab.dataset.category || 'Opening';
        console.log("Tasks tab clicked", clickedCategory);
        
        currentCategory = clickedCategory;
        
        // Defer visual updates
        scheduleAnimationFrame(() => {
          // Update tab states
          allTabs.forEach(t => {
            if (t !== clickedTab) {
              t.style.background = 'transparent';
              t.style.borderBottom = '2px solid transparent';
              t.style.color = 'var(--sub)';
              t.style.fontWeight = '500';
              t.classList.remove('active');
            }
          });
          
          clickedTab.style.background = 'rgba(157,104,185,0.08)';
          clickedTab.style.borderBottom = '2px solid var(--brand1)';
          clickedTab.style.color = 'var(--text)';
          clickedTab.style.fontWeight = '600';
          clickedTab.classList.add('active');
          
          if (elements.selectedCategorySpan) {
            elements.selectedCategorySpan.textContent = clickedCategory;
          }
          
          // Update note display
          if (typeof window.updateTaskNoteDisplay === 'function') {
            window.updateTaskNoteDisplay(clickedCategory);
          }
          
          // Re-render tasks
          scheduleAnimationFrame(() => {
            try {
              if (window.renderTasks && typeof window.renderTasks === 'function') {
                window.renderTasks();
              }
              if (window.renderPendingTasks && typeof window.renderPendingTasks === 'function') {
                window.renderPendingTasks();
              }
            } catch (error) {
              console.error('[Tasks] Error rendering tasks:', error);
            }
          });
        });
      };
      
      addTrackedEventListener(tab, 'click', handler, { passive: false });
      
      // Set basic styles
      tab.style.pointerEvents = 'auto';
      tab.style.cursor = 'pointer';
      tab.style.position = 'relative';
      tab.style.zIndex = '501';
    });
    
    // Set initial active tab
    scheduleAnimationFrame(() => {
      allTabs.forEach(tab => {
        if (tab.dataset.category === 'Opening') {
          tab.style.background = 'rgba(157,104,185,0.08)';
          tab.style.borderBottom = '2px solid var(--brand1)';
          tab.style.color = 'var(--text)';
          tab.style.fontWeight = '600';
          tab.classList.add('active');
          if (elements.selectedCategorySpan) {
            elements.selectedCategorySpan.textContent = 'Opening';
          }
        } else {
          tab.style.background = 'transparent';
          tab.style.borderBottom = '2px solid transparent';
          tab.style.color = 'var(--sub)';
          tab.style.fontWeight = '500';
          tab.classList.remove('active');
        }
      });
      
      if (typeof window.updateTaskNoteDisplay === 'function') {
        scheduleTimeout(() => {
          window.updateTaskNoteDisplay('Opening');
        }, 0);
      }
    });
  }
  
  /**
   * Enable interactivity for all Tasks screen elements
   */
  function enableInteractivity() {
    if (!elements.tasksScreen) return;
    
    scheduleAnimationFrame(() => {
      // Enable all buttons
      const buttons = elements.tasksScreen.querySelectorAll('button');
      buttons.forEach(btn => {
        btn.style.pointerEvents = 'auto';
        btn.style.cursor = 'pointer';
        btn.style.position = 'relative';
        btn.style.zIndex = '500';
        if (btn.disabled) {
          btn.style.cursor = 'not-allowed';
        }
      });
      
      // Enable containers
      const containers = elements.tasksScreen.querySelectorAll('#taskListContainer, #pendingTasksContainer');
      containers.forEach(container => {
        container.style.pointerEvents = 'auto';
      });
      
      // Enable interactive elements
      const interactive = elements.tasksScreen.querySelectorAll('a, input, select, [role="button"]');
      interactive.forEach(el => {
        el.style.pointerEvents = 'auto';
        if (el.tagName === 'A' || el.getAttribute('role') === 'button') {
          el.style.cursor = 'pointer';
        }
      });
    });
  }
  
  /**
   * Clean up all resources
   */
  function cleanup() {
    console.log('[Tasks] Starting cleanup...');
    
    // Clear all timers
    resources.timers.forEach(timerId => clearTimeout(timerId));
    resources.timers.clear();
    
    // Cancel all animation frames
    resources.animationFrames.forEach(rafId => cancelAnimationFrame(rafId));
    resources.animationFrames.clear();
    
    // Remove all event listeners
    resources.eventListeners.forEach((listeners, element) => {
      listeners.forEach(({ event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
    });
    resources.eventListeners.clear();
    
    // Restore original styles
    resources.originalStyles.forEach((original, element) => {
      restoreOriginalStyle(element);
    });
    resources.originalStyles.clear();
    
    console.log('[Tasks] Cleanup complete');
  }
  
  // ============================================
  // PUBLIC API - TasksComponent
  // ============================================
  window.TasksComponent = {
    /**
     * Mount the Tasks component (show it)
     */
    mount: function() {
      if (isInitializing || isMounted) {
        console.warn('[Tasks] Already mounted or initializing');
        return;
      }
      
      isInitializing = true;
      console.log('[Tasks] Mounting component...');
      
      // Get DOM elements
      elements.tasksScreen = document.getElementById('tasksScreen');
      elements.mainContent = document.querySelector('#owner-view .wrap');
      elements.joinBar = document.getElementById('joinBar');
      elements.header = document.querySelector('.header');
      elements.backBtn = document.getElementById('tasksBackBtn');
      elements.settingsBtn = document.getElementById('tasksSettingsBtn');
      elements.resetBtn = document.getElementById('tasksResetBtn');
      elements.tabs = document.querySelectorAll('.task-tab');
      elements.selectedCategorySpan = document.getElementById('selectedCategory');
      
      if (!elements.tasksScreen || !elements.mainContent) {
        console.error('[Tasks] Required elements not found');
        isInitializing = false;
        return;
      }
      
      // Close blocking modals
      closeAllBlockingModals();
      
      // Apply header styles (stores originals)
      applyHeaderStyles();
      
      // Show Tasks screen
      elements.tasksScreen.style.pointerEvents = 'auto';
      elements.tasksScreen.style.display = 'flex';
      elements.tasksScreen.style.visibility = 'visible';
      elements.tasksScreen.style.opacity = '1';
      elements.tasksScreen.style.zIndex = '300';
      
      // Hide main content
      elements.mainContent.style.display = 'none';
      if (elements.joinBar) {
        elements.joinBar.style.display = 'none';
      }
      
      // Initialize components (deferred to avoid blocking)
      scheduleTimeout(() => {
        // Initialize header buttons FIRST (most critical for user interaction)
        const headerButtonsOk = initializeHeaderButtons();
        if (!headerButtonsOk) {
          console.error('[Tasks] Header buttons initialization failed, retrying...');
          // Retry once after a short delay
          scheduleTimeout(() => {
            initializeHeaderButtons();
          }, 100);
        }
        
        // Then initialize tabs
        initializeTabs();
        
        // Finally enable general interactivity
        enableInteractivity();
        
        // Re-render tasks
        if (window.renderTasks && typeof window.renderTasks === 'function') {
          window.renderTasks();
        }
        if (window.renderPendingTasks && typeof window.renderPendingTasks === 'function') {
          window.renderPendingTasks();
        }
        
        // Update badges
        if (window.updateAllTabBadges && typeof window.updateAllTabBadges === 'function') {
          window.updateAllTabBadges();
        }
        
        isInitializing = false;
        isMounted = true;
        console.log('[Tasks] Component mounted successfully');
      }, 50);
    },
    
    /**
     * Unmount the Tasks component (hide it and clean up)
     */
    unmount: function() {
      if (!isMounted && !isInitializing) {
        return; // Already unmounted
      }
      
      console.log('[Tasks] Unmounting component...');
      
      // Clean up all resources
      cleanup();
      
      // Restore header styles
      restoreHeaderStyles();
      
      // Hide Tasks screen
      if (elements.tasksScreen) {
        elements.tasksScreen.style.display = 'none';
        elements.tasksScreen.style.pointerEvents = 'none';
      }
      
      // Show main content
      if (elements.mainContent) {
        elements.mainContent.style.display = 'block';
      }
      if (elements.joinBar) {
        elements.joinBar.style.display = 'flex';
      }
      
      // Reset state
      isMounted = false;
      isInitializing = false;
      
      // Clear element references
      Object.keys(elements).forEach(key => {
        elements[key] = null;
      });
      
      console.log('[Tasks] Component unmounted successfully');
    },
    
    /**
     * Get current mounted state
     */
    isMounted: function() {
      return isMounted;
    },
    
    /**
     * Get current category
     */
    getCurrentCategory: function() {
      return currentCategory;
    },
    
    /**
     * Verify header buttons are properly initialized and clickable
     * Useful for debugging - call TasksComponent.verifyHeaderButtons() in console
     */
    verifyHeaderButtons: function() {
      const buttons = {
        back: document.getElementById('tasksBackBtn'),
        settings: document.getElementById('tasksSettingsBtn'),
        reset: document.getElementById('tasksResetBtn')
      };
      
      const results = {};
      
      Object.keys(buttons).forEach(key => {
        const btn = buttons[key];
        if (!btn) {
          results[key] = { found: false, error: 'Button not found in DOM' };
          return;
        }
        
        const computed = window.getComputedStyle(btn);
        const rect = btn.getBoundingClientRect();
        
        results[key] = {
          found: true,
          visible: rect.width > 0 && rect.height > 0,
          pointerEvents: computed.pointerEvents,
          zIndex: computed.zIndex,
          cursor: computed.cursor,
          position: computed.position,
          disabled: btn.disabled,
          hasListener: btn.onclick !== null || btn.getAttribute('onclick') !== null,
          boundingRect: {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height
          }
        };
      });
      
      console.log('[Tasks] Header buttons verification:', results);
      return results;
    }
  };

// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// The following Tasks functions and state have been completely removed:
// - showTasksScreen, goBackToMainScreen
// - initTasksTabs, updateTaskNoteDisplay
// - tasksData, pendingTasks, completedTasks, defaultTasks
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish, Select, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks initialization code
//
// Stub functions to prevent errors if anything tries to call them:
function showTasksScreen() {
  console.warn('[Tasks] Tasks feature removed - showTasksScreen() is a no-op');
}

function goBackToMainScreen(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.warn('[Tasks] Tasks feature removed - goBackToMainScreen() is a no-op');
}

function initTasksTabs() {
  // No-op - Tasks feature removed
}

function updateTaskNoteDisplay(category) {
  // No-op - Tasks feature removed
}

// Expose stubs globally to prevent errors
window.showTasksScreen = showTasksScreen;
window.goBackToMainScreen = goBackToMainScreen;
window.updateTaskNoteDisplay = updateTaskNoteDisplay;

// Tasks functionality - simplified structure (arrays of strings)
let tasksData = {
  Opening: [],
  Closing: [],
  Weekly: [],
  Monthly: [],
  Yearly: []
};

// Helper functions to normalize tasks (backward compatibility)
// Tasks can be stored as strings (old format) or objects with {name, instructions?}
function normalizeTask(task) {
  if (typeof task === 'string') {
    return { name: task, instructions: '' };
  }
  if (task && typeof task === 'object' && task.name) {
    return { name: task.name, instructions: task.instructions || '' };
  }
  return { name: '', instructions: '' };
}

function getTaskName(task) {
  if (typeof task === 'string') return task;
  if (task && typeof task === 'object' && task.name) return task.name;
  return '';
}

function getTaskInstructions(task) {
  if (task && typeof task === 'object' && task.instructions) {
    return task.instructions || '';
  }
  return '';
}

function normalizeTasksArray(tasks) {
  if (!Array.isArray(tasks)) return [];
  return tasks.map(normalizeTask);
}

// Pending tasks for each category
let pendingTasks = {
  Opening: [],
  Closing: [],
  Weekly: [],
  Monthly: [],
  Yearly: []
};

// Completed tasks - structure: { "YYYY-MM-DD": { "Opening": ["task1", "task2"], ... } }
let completedTasks = {};

// Default placeholder tasks
// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// The following Tasks code has been completely removed:
// - defaultTasks constant
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish Task, Select Task, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks state variables (tasksData, pendingTasks, completedTasks, defaultTasks, etc.)
// ============================================

// Add Technician dialog functions (non-Tasks code starts here)

// ============================================
// ALL TASKS-RELATED CODE REMOVED
// ============================================
// All Tasks functions, state, and initialization code have been completely removed.
// This includes:
// - initTasksData, saveTasksData, getTodayDateString
// - isTaskCompletedToday, getTaskStatus, isReminderActive
// - countIncompleteTasks, updateTabBadge, updateAllTabBadges
// - getCurrentTasksCategory, renderTasks, markTaskAsDone
// - addTaskToPending, resetTasksForCategory
// - All Tasks modal functions (Admin Access, Reset, Finish Task, Select Task, Edit, Instructions)
// - initTasksFunctionality, initializeTasksOnce, initTasksHeaderButtons
// - All Tasks-related event handlers and state management
// ============================================
// ORPHANED CODE BLOCK COMMENTED OUT - Contains top-level return statements
// This code was part of a function that was removed during Tasks cleanup
/*
      if (currentDay > reminderDay || (currentDay === reminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    case 'monthly': {
      const [hours, minutes] = (reminder.time || '09:00').split(':').map(Number);
      const reminderTime = hours * 60 + minutes;
      const currentDay = now.getDate();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      
      // Get the last day of current month
      const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
      const reminderDay = Math.min(reminder.day || 1, lastDayOfMonth);
      
      // If we're past the reminder day this month, or on the reminder day and past the time
      if (currentDay > reminderDay || (currentDay === reminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    case 'yearly': {
      const [hours, minutes] = (reminder.time || '09:00').split(':').map(Number);
      const reminderTime = hours * 60 + minutes;
      const currentMonth = now.getMonth() + 1; // 1-12
      const currentDay = now.getDate();
      const reminderMonth = reminder.month || 1;
      const reminderDay = reminder.day || 1;
      
      // Handle day clamping for months with fewer days
      const lastDayOfReminderMonth = new Date(now.getFullYear(), reminderMonth, 0).getDate();
      const actualReminderDay = Math.min(reminderDay, lastDayOfReminderMonth);
      
      // If we're past the reminder date this year, or on the reminder date and past the time
      if (currentMonth > reminderMonth || 
          (currentMonth === reminderMonth && currentDay > actualReminderDay) ||
          (currentMonth === reminderMonth && currentDay === actualReminderDay && currentTime >= reminderTime)) {
        return true;
      }
      return false;
    }
    
    default:
      return false;
  }
}
*/

// Count incomplete tasks for a category
// A task is incomplete if it is NOT in the "done" state
// This includes tasks that are "not_started" (available) or "pending"
// Only tasks marked as "done" (green in UI) are excluded from the count
function countIncompleteTasks(category) {
  const tasks = tasksData[category] || [];
  if (tasks.length === 0) return 0;
  
  let incompleteCount = 0;
  tasks.forEach(task => {
    // Count task if it's NOT completed (not in done state)
    // This includes both "not_started" and "pending" tasks
    const taskName = getTaskName(task);
    if (!isTaskCompletedToday(category, taskName)) {
      incompleteCount++;
    }
  });
  
  return incompleteCount;
}

// Update badge for a specific tab
function updateTabBadge(category) {
  const tab = document.querySelector(`.task-tab[data-category="${category}"]`);
  if (!tab) return;
  
  // Remove existing badge if any
  const existingBadge = tab.querySelector('.task-tab-badge');
  if (existingBadge) {
    existingBadge.remove();
  }
  
  // Check if reminder is active for this category
  if (!isReminderActive(category)) {
    return; // Don't show badge if reminder is not active
  }
  
  // Count incomplete tasks
  const incompleteCount = countIncompleteTasks(category);
  
  // Only show badge if count > 0
  if (incompleteCount > 0) {
    const badge = document.createElement('span');
    badge.className = 'task-tab-badge';
    badge.textContent = incompleteCount.toString();
    badge.style.cssText = 'display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 5px;background:var(--danger);color:#fff;border-radius:999px;font-size:11px;font-weight:700;margin-left:6px;line-height:1;';
    tab.appendChild(badge);
  }
}

// Update all tab badges
function updateAllTabBadges() {
  const categories = ['Opening', 'Closing', 'Weekly', 'Monthly', 'Yearly'];
  categories.forEach(category => {
    updateTabBadge(category);
  });
}

// Make updateAllTabBadges globally available
window.updateAllTabBadges = updateAllTabBadges;

// Get current category
function getCurrentTasksCategory() {
  const activeTab = document.querySelector('.task-tab.active');
  return activeTab ? (activeTab.dataset.category || 'Opening') : 'Opening';
}

// Render tasks for current category (main Task List panel)
function renderTasks() {
  const category = getCurrentTasksCategory();
  const container = document.getElementById('taskListContainer');
  if (!container) {
    console.warn('[Tasks] renderTasks: container not found');
    return;
  }
  
  const tasks = tasksData[category] || [];
  const pending = pendingTasks[category] || [];
  
  console.log('[Tasks] Rendering tasks for category:', category, 'Tasks count:', tasks.length);
  
  if (tasks.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sub);"><p style="font-size:13px;">No tasks available.</p></div>';
    return;
  }
  
  container.innerHTML = '';
  
  tasks.forEach((task, index) => {
    const taskName = getTaskName(task);
    const taskInstructions = getTaskInstructions(task);
    const status = getTaskStatus(category, taskName);
    
    const taskDiv = document.createElement('div');
    // Determine background color and opacity based on status
    let bgColor, opacity;
    if (status === 'done') {
      bgColor = '#f3f4f6';
      opacity = '0.7';
    } else {
      bgColor = 'var(--muted)';
      opacity = '1';
    }
    taskDiv.style.cssText = `display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:${bgColor};border-radius:8px;border:1px solid var(--border);opacity:${opacity};margin-bottom:6px;`;
    
    const leftDiv = document.createElement('div');
    leftDiv.style.cssText = 'display:flex;align-items:center;gap:8px;flex:1;';
    
    // Status dot color based on status
    let dotColor;
    if (status === 'done') {
      dotColor = '#10b981'; // green for done
    } else if (status === 'pending') {
      dotColor = '#6366f1'; // purple for pending
    } else {
      dotColor = '#ef4444'; // red for not done today
    }
    
    const statusDot = document.createElement('div');
    statusDot.style.cssText = `width:8px;height:8px;border-radius:50%;background:${dotColor};flex-shrink:0;`;
    
    // Checkmark icon if done
    if (status === 'done') {
      const checkmark = document.createElement('span');
      checkmark.textContent = 'âœ“';
      checkmark.style.cssText = 'color:#10b981;font-size:13px;font-weight:bold;margin-right:4px;flex-shrink:0;';
      leftDiv.appendChild(checkmark);
    }
    
    const taskSpan = document.createElement('span');
    taskSpan.textContent = taskName;
    taskSpan.style.cssText = 'font-size:13px;color:var(--text);';
    
    leftDiv.appendChild(statusDot);
    leftDiv.appendChild(taskSpan);
    
    const rightDiv = document.createElement('div');
    rightDiv.style.cssText = 'display:flex;align-items:center;gap:6px;';
    
    // Info button (only show if task has instructions)
    if (taskInstructions && taskInstructions.trim() !== '') {
      const infoBtn = document.createElement('button');
      infoBtn.innerHTML = 'â„¹';
      infoBtn.className = 'btn-mini';
      infoBtn.style.cssText = 'width:24px;height:24px;padding:0;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;border-radius:50%;background:var(--brand1);color:#fff;border:none;cursor:pointer;flex-shrink:0;';
      infoBtn.title = 'View instructions';
      infoBtn.addEventListener('click', () => {
        openTaskInstructionsModal(taskName, taskInstructions);
      });
      rightDiv.appendChild(infoBtn);
    }
    
    const selectBtn = document.createElement('button');
    selectBtn.className = 'btn-mini';
    selectBtn.style.fontSize = '11px';
    selectBtn.style.padding = '6px 10px';
    
    // Button state based on status
    if (status === 'done' || status === 'pending') {
      selectBtn.textContent = 'Selected';
      selectBtn.disabled = true;
      selectBtn.style.opacity = '0.6';
      selectBtn.style.cursor = 'not-allowed';
    } else {
      selectBtn.textContent = 'Select';
      selectBtn.disabled = false;
      selectBtn.style.opacity = '1';
      selectBtn.style.cursor = 'pointer';
      // Add click handler to open PIN modal for selecting task
      selectBtn.addEventListener('click', () => {
        openSelectTaskModal(category, taskName);
      });
    }
    
    rightDiv.appendChild(selectBtn);
    
    taskDiv.appendChild(leftDiv);
    taskDiv.appendChild(rightDiv);
    container.appendChild(taskDiv);
  });
  
  // Update tab badges after rendering
  updateAllTabBadges();
}

// Mark task as done (simplified version without PIN requirement)
function markTaskAsDone(category, taskName) {
  if (!category || !taskName) {
    console.warn('[Tasks] markTaskAsDone: Missing category or taskName');
    return;
  }
  
  // Mark task as done in completedTasks
  const today = getTodayDateString();
  if (!completedTasks[today]) {
    completedTasks[today] = {};
  }
  if (!completedTasks[today][category]) {
    completedTasks[today][category] = [];
  }
  
  // Add to completed tasks if not already there
  if (!completedTasks[today][category].includes(taskName)) {
    completedTasks[today][category].push(taskName);
  }
  
  // Remove from pending list (done tasks should not appear in "My Tasks (Pending)")
  const pending = pendingTasks[category] || [];
  const pendingIndex = pending.indexOf(taskName);
  if (pendingIndex !== -1) {
    pending.splice(pendingIndex, 1);
    pendingTasks[category] = pending;
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Re-render both columns immediately
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  if (typeof updateAllTabBadges === 'function') {
    updateAllTabBadges();
  }
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
}

// Add task to pending list
function addTaskToPending(category, taskName, assignedToName) {
  // Prevent adding done tasks to pending list
  if (isTaskCompletedToday(category, taskName)) {
    return; // Task is done, cannot be added to pending
  }
  
  const pending = pendingTasks[category] || [];
  
  // Normalize pending array: convert strings to objects for backward compatibility
  const normalizedPending = pending.map(item => {
    if (typeof item === 'string') {
      // Old format: just task name string
      return { taskName: item, assignedToName: undefined };
    }
    // New format: already an object
    return item;
  });
  
  // Check if already in pending (no duplicates)
  const existingIndex = normalizedPending.findIndex(item => {
    const name = typeof item === 'string' ? item : item.taskName;
    return name === taskName;
  });
  
  if (existingIndex === -1) {
    // Add new task with staff name
    normalizedPending.push({
      taskName: taskName,
      assignedToName: assignedToName || undefined
    });
    pendingTasks[category] = normalizedPending;
    saveTasksData();
    renderTasks(); // Re-render to update button state
    renderPendingTasks(); // Update right column
  } else {
    // Update existing task with staff name if provided
    if (assignedToName) {
      normalizedPending[existingIndex].assignedToName = assignedToName;
      pendingTasks[category] = normalizedPending;
      saveTasksData();
      renderPendingTasks(); // Update right column
    }
  }
}

// Reset tasks for a specific category
function resetTasksForCategory(category) {
  // Clear pending tasks for this category
  if (pendingTasks[category]) {
    pendingTasks[category] = [];
  }
  
  // Clear completed tasks for today for this category
  const today = getTodayDateString();
  if (completedTasks[today] && completedTasks[today][category]) {
    delete completedTasks[today][category];
    // If the day object is now empty, we can optionally clean it up
    if (Object.keys(completedTasks[today]).length === 0) {
      delete completedTasks[today];
    }
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Re-render both columns
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  updateAllTabBadges();
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
}

// Store the category to reset (captured when modal opens)
let currentResetCategory = null;

// Open reset confirmation modal
function openTasksResetModal() {
  // Capture the current category when modal opens (not when confirmed)
  currentResetCategory = getCurrentTasksCategory();
  console.log('[Reset Modal] Opening for category:', currentResetCategory);
  
  const modal = document.getElementById('tasksResetModal');
  const modalContent = document.getElementById('tasksResetModalContent');
  const title = document.getElementById('tasksResetModalTitle');
  const body = document.getElementById('tasksResetModalBody');
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (modal && title && body && input) {
    // Update modal text with current category
    title.textContent = `Reset ${currentResetCategory} tasks?`;
    body.textContent = `This will reset all tasks in the ${currentResetCategory} list back to their initial state (not selected, not done). This does NOT delete history. Are you sure?`;
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
      
      // Use event delegation on modal content - remove old listener first
      const newModalContent = modalContent.cloneNode(true);
      modalContent.parentNode.replaceChild(newModalContent, modalContent);
      const freshModalContent = document.getElementById('tasksResetModalContent');
      
      if (freshModalContent) {
        freshModalContent.addEventListener('click', (e) => {
          if (e.target.id === 'tasksResetConfirm' || e.target.closest('#tasksResetConfirm')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Reset Modal] Confirm clicked via delegation');
            if (typeof confirmTasksReset === 'function') {
              confirmTasksReset();
            } else {
              console.error('[Tasks] confirmTasksReset function not found');
              closeTasksResetModal();
            }
          } else if (e.target.id === 'tasksResetCancel' || e.target.closest('#tasksResetCancel')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('[Reset Modal] Cancel clicked via delegation');
            closeTasksResetModal();
          }
        }, { capture: true });
      }
    }
    
    // Clear and prepare input
    input.value = '';
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.style.pointerEvents = 'auto';
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Ensure buttons are enabled and clickable (get fresh references after cloning)
    const freshConfirmBtn = document.getElementById('tasksResetConfirm');
    const freshCancelBtn = document.getElementById('tasksResetCancel');
    
    if (freshConfirmBtn) {
      freshConfirmBtn.disabled = false;
      freshConfirmBtn.removeAttribute('disabled');
      freshConfirmBtn.style.pointerEvents = 'auto';
      freshConfirmBtn.style.cursor = 'pointer';
      freshConfirmBtn.style.position = 'relative';
      freshConfirmBtn.style.zIndex = '1102';
      freshConfirmBtn.setAttribute('type', 'button');
    }
    if (freshCancelBtn) {
      freshCancelBtn.disabled = false;
      freshCancelBtn.removeAttribute('disabled');
      freshCancelBtn.style.pointerEvents = 'auto';
      freshCancelBtn.style.cursor = 'pointer';
      freshCancelBtn.style.position = 'relative';
      freshCancelBtn.style.zIndex = '1102';
      freshCancelBtn.setAttribute('type', 'button');
    }
    
    setTimeout(() => {
      const focusInput = document.getElementById('tasksResetPinInput');
      if (focusInput) focusInput.focus();
    }, 100);
  }
}

function closeTasksResetModal() {
  const modal = document.getElementById('tasksResetModal');
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none'; // Disable clicks when modal is closed
  }
  
  // Clear input and error
  if (input) {
    input.value = '';
    input.blur();
  }
  if (error) {
    error.textContent = '';
  }
  
  // Clear the stored category when modal closes
  currentResetCategory = null;
}

// Validate PIN and reset tasks
function confirmTasksReset() {
  const input = document.getElementById('tasksResetPinInput');
  const error = document.getElementById('tasksResetPinError');
  
  if (!input) return;
  
  const pin = input.value.trim();
  if (!pin) {
    if (error) error.textContent = 'Please enter manager/admin PIN';
    return;
  }
  
  // Validate PIN - must be admin or manager
  const isAdmin = isAdminCode(pin);
  const isManager = isManagerCode(pin);
  
  if (!isAdmin && !isManager) {
    if (error) error.textContent = 'Only manager or admin can reset this task list.';
    input.value = '';
    setTimeout(() => input.focus(), 100);
    return;
  }
  
  // PIN is valid - reset the category (use the category captured when modal opened)
  const category = currentResetCategory || getCurrentTasksCategory();
  console.log('[Reset Modal] Resetting category:', category);
  if (!category) {
    console.error('[Reset Modal] No category to reset!');
    if (error) error.textContent = 'Error: No category selected. Please try again.';
    return;
  }
  resetTasksForCategory(category);
  
  // Clear the stored category after reset
  currentResetCategory = null;
  
  // Clear input and error
  input.value = '';
  if (error) error.textContent = '';
  
  // Force close modal - ensure it's completely hidden
  const modal = document.getElementById('tasksResetModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
    modal.style.pointerEvents = 'none';
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
  }
  
  // Also call the close function for consistency
  closeTasksResetModal();
}

// Open finish task modal
let currentFinishTask = { category: null, taskName: null };
let currentSelectTask = { category: null, taskName: null };
let taskStaffCode = ''; // State for staff code in Select Task modal

function openSelectTaskModal(category, taskName) {
  currentSelectTask = { category, taskName };
  taskStaffCode = ''; // Initialize state - CRITICAL: must be cleared
  const modal = document.getElementById('tasksSelectModal');
  const input = document.getElementById('tasksSelectPinInput');
  const error = document.getElementById('tasksSelectPinError');
  const confirmBtn = document.getElementById('tasksSelectConfirm');
  const cancelBtn = document.getElementById('tasksSelectCancel');
  
  if (modal && input) {
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure input is fully enabled and ready for typing
    // CRITICAL: Clear both input value and state to ensure they're in sync
    input.value = '';
    taskStaffCode = ''; // Double-check state is cleared
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('inputmode', 'numeric');
    input.setAttribute('maxlength', '4');
    input.style.pointerEvents = 'auto';
    
    // Ensure buttons are enabled and clickable
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.removeAttribute('disabled');
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = 'pointer';
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
    }
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Focus input after a short delay to ensure modal is fully rendered
    setTimeout(() => {
      input.focus();
      // Ensure input is still enabled after focus
      input.readOnly = false;
      input.disabled = false;
    }, 100);
  }
}

function closeSelectTaskModal() {
  try {
    const modal = document.getElementById('tasksSelectModal');
    const input = document.getElementById('tasksSelectPinInput');
    const error = document.getElementById('tasksSelectPinError');
    
    if (modal) {
      // Clear input field
      if (input) {
        input.value = '';
        input.blur();
      }
      
      // Clear error message
      if (error) {
        error.textContent = '';
      }
      
      // Force hide modal using multiple methods and ensure it doesn't block clicks
      modal.style.display = 'none';
      modal.style.visibility = 'hidden';
      modal.style.opacity = '0';
      modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
      modal.classList.remove('active');
      modal.setAttribute('aria-hidden', 'true');
      
      // Clear state
      taskStaffCode = '';
      currentSelectTask = { category: null, taskName: null };
    }
  } catch (err) {
    console.error('[Tasks] Error closing select task modal:', err);
    // Force close even on error
    const modal = document.getElementById('tasksSelectModal');
    if (modal) {
      modal.style.display = 'none';
      modal.style.visibility = 'hidden';
      modal.style.opacity = '0';
      modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  }
}

// Validate PIN and add task to pending
function confirmSelectTask() {
  try {
    const input = document.getElementById('tasksSelectPinInput');
    const error = document.getElementById('tasksSelectPinError');
    
    if (!input || !currentSelectTask.category || !currentSelectTask.taskName) {
      console.warn('[Tasks] confirmSelectTask: Missing required elements or task info');
      // Clear state
      taskStaffCode = '';
      currentSelectTask = { category: null, taskName: null };
      // FORCE CLOSE MODAL - This is the very last line in critical error path
      const taskModal = document.getElementById('tasksSelectModal');
      if (taskModal) {
        taskModal.style.display = 'none';
      }
      return;
    }
    
    // Use state value, with fallback to reading from input directly
    // This ensures we always get the current value even if state is out of sync
    // Use the EXACT same pattern as JOIN function: pin=(pinInput.value||"").toString()
    let code = taskStaffCode || '';
    if (!code && input) {
      // Fallback: read directly from input if state is empty
      code = (input.value || '').toString();
      // Update state with the value we read
      if (code) {
        taskStaffCode = code;
      }
    }
    
    // Convert to string and trim (same as JOIN function does)
    code = (code || '').toString().trim();
    
    // Check if code is empty
    if (!code || code === '') {
      if (error) error.textContent = 'Please enter code (admin, manager, or staff)';
      return; // Don't close modal - user needs to enter code
    }
    
    // Validate code - accept admin, manager, or tech (worker) codes
    // This allows anyone (admin, manager, or tech) to select tasks
    // CRITICAL: Use trimmed code for all comparisons
    const codeStr = code;
    
    let matchedWorker = null;
    let matchedRole = null;
    let matchedName = null;
    
    // Check if code matches admin (check FIRST)
    const adminCheck = isAdminCode(codeStr);
    if (adminCheck) {
      matchedRole = 'Admin';
      matchedName = settings.ownerName || settings.adminName || 'Admin';
      // Create a worker-like object for consistency
      matchedWorker = { name: matchedName, pin: codeStr, role: 'Admin' };
      console.log('[Tasks] Admin code validated:', matchedName);
    }
    // Check if code matches manager (check SECOND)
    else {
      const managerCheck = isManagerCode(codeStr);
      if (managerCheck) {
        const managers = settings.managers || [];
        const manager = managers.find(m => {
          if (!m.code) return false;
          return m.code.toString().trim() === codeStr;
        });
        if (manager) {
          matchedRole = 'Manager';
          matchedName = manager.name || 'Manager';
          matchedWorker = { name: matchedName, pin: codeStr, role: 'Manager' };
          console.log('[Tasks] Manager code validated:', matchedName);
        } else {
          console.warn('[Tasks] isManagerCode returned true but manager not found in list');
        }
      }
      // Check if code matches worker (tech) (check THIRD)
      else {
        const workersList = settings.workers || [];
        for (let i = 0; i < workersList.length; i++) {
          const worker = workersList[i];
          if (!worker.pin) continue;
          // Use exact same comparison as JOIN: w.pin.toString() === code
          const workerPinStr = worker.pin.toString().trim();
          if (workerPinStr === codeStr) {
            matchedWorker = worker;
            matchedRole = 'Tech';
            matchedName = worker.name;
            console.log('[Tasks] Tech code validated:', matchedName);
            break;
          }
        }
      }
    }
    
    if (!matchedWorker) {
      // Debug: log what we're comparing to help troubleshoot
      console.log('[Tasks] Code validation failed - no match found:', {
        enteredCode: codeStr,
        codeType: typeof codeStr,
        codeLength: codeStr.length,
        isAdminCheck: isAdminCode(codeStr),
        isManagerCheck: isManagerCode(codeStr),
        workersCount: (settings.workers || []).length,
        managersCount: (settings.managers || []).length
      });
      if (error) error.textContent = 'Invalid code. Please enter admin, manager, or staff code.';
      // Clear input and state for retry
      taskStaffCode = '';
      if (input) input.value = '';
      setTimeout(() => input.focus(), 100);
      return; // Don't close modal - user needs to correct code
    }
    
    console.log('[Tasks] Code validation SUCCESS:', {
      role: matchedRole,
      name: matchedName,
      code: codeStr
    });
    
    // PIN is valid - add task to pending with staff name
    try {
      if (typeof addTaskToPending === 'function') {
        // Pass the matched staff name to addTaskToPending
        addTaskToPending(currentSelectTask.category, currentSelectTask.taskName, matchedName);
      } else {
        console.warn('[Tasks] addTaskToPending function not found');
      }
      
      // Record in history who selected it
      // Use getActorInfo to properly determine role based on the code
      if (typeof getActorForAction === 'function' && typeof addHistoryEntry === 'function') {
        let actor = null;
        if (matchedRole === 'Admin') {
          actor = getActorForAction({ adminCode: code });
        } else if (matchedRole === 'Manager') {
          actor = getActorForAction({ managerCode: code });
        } else {
          actor = getActorForAction({ workerName: matchedName });
        }
        addHistoryEntry(`Select task: ${currentSelectTask.taskName} (${currentSelectTask.category})`, actor, matchedName);
      }
      
      // Update tab badges
      if (typeof updateAllTabBadges === 'function') {
        updateAllTabBadges();
      }
      
      // Update Tasks button badge (for incomplete tasks count)
      if (typeof updateTasksButtonBadge === 'function') {
        updateTasksButtonBadge();
      }
    } catch (taskErr) {
      console.error('[Tasks] Error processing task selection:', taskErr);
      // Continue to close modal even if task processing fails
    }
    
    // Clear input, error message, and state
    const staffCodeInput = document.getElementById('tasksSelectPinInput');
    const errorMsg = document.getElementById('tasksSelectPinError');
    if (staffCodeInput) {
      staffCodeInput.value = '';
    }
    if (errorMsg) {
      errorMsg.textContent = ''; // Clear error message on success
    }
    taskStaffCode = '';
    currentSelectTask = { category: null, taskName: null };
    
    // FORCE CLOSE MODAL - This is the very last line in success path
    const taskModal = document.getElementById('tasksSelectModal');
    if (taskModal) {
      taskModal.style.display = 'none';
      taskModal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  } catch (err) {
    console.error('[Tasks] Error in confirmSelectTask:', err);
    
    // Clear input, error message, and state
    const staffCodeInput = document.getElementById('tasksSelectPinInput');
    const errorMsg = document.getElementById('tasksSelectPinError');
    if (staffCodeInput) {
      staffCodeInput.value = '';
    }
    if (errorMsg) {
      errorMsg.textContent = ''; // Clear error message
    }
    taskStaffCode = '';
    currentSelectTask = { category: null, taskName: null };
    
    // FORCE CLOSE MODAL - This is the very last line in error path
    const taskModal = document.getElementById('tasksSelectModal');
    if (taskModal) {
      taskModal.style.display = 'none';
      taskModal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    }
  }
}

function openFinishTaskModal(category, taskName) {
  currentFinishTask = { category, taskName };
  const modal = document.getElementById('tasksFinishModal');
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  const confirmBtn = document.getElementById('tasksFinishConfirm');
  const cancelBtn = document.getElementById('tasksFinishCancel');
  
  if (modal && input) {
    const modalContent = document.getElementById('tasksFinishModalContent');
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto'; // Enable clicks when modal is open
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Clear and prepare input
    input.value = '';
    input.type = 'password';
    input.readOnly = false;
    input.disabled = false;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    input.style.pointerEvents = 'auto';
    
    // Clear error message
    if (error) error.textContent = '';
    
    // Ensure buttons are enabled and clickable
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.removeAttribute('disabled');
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.position = 'relative';
      confirmBtn.style.zIndex = '1102';
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.position = 'relative';
      cancelBtn.style.zIndex = '1102';
    }
    
    setTimeout(() => input.focus(), 100);
  }
}

function closeFinishTaskModal() {
  const modal = document.getElementById('tasksFinishModal');
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  
  if (modal) {
    // Clear input and error
    if (input) {
      input.value = '';
      input.blur();
    }
    if (error) {
      error.textContent = '';
    }
    
    // Force hide modal and ensure it doesn't block clicks
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none'; // CRITICAL: Prevent blocking clicks after close
    currentFinishTask = { category: null, taskName: null };
  }
}

// Validate PIN and mark task as done
async function confirmFinishTask() {
  const input = document.getElementById('tasksFinishPinInput');
  const error = document.getElementById('tasksFinishPinError');
  
  if (!input || !currentFinishTask.category || !currentFinishTask.taskName) {
    console.warn('[Tasks] confirmFinishTask: Missing required elements or task info');
    closeFinishTaskModal();
    return;
  }
  
  // Use the EXACT same pattern as JOIN function: pin=(pinInput.value||"").toString()
  let pin = (input.value || '').toString().trim();
  
  if (!pin || pin === '') {
    if (error) error.textContent = 'Please enter code (admin, manager, or staff)';
    return; // Don't close modal - user needs to enter code
  }
  
  // Validate PIN - accept admin, manager, or tech (worker) codes
  // This allows anyone (admin, manager, or tech) to mark tasks as done
  // CRITICAL: Use trimmed PIN for all comparisons
  const pinStr = pin;
  
  let matchedWorker = null;
  let matchedRole = null;
  let matchedName = null;
  
  // Check if PIN matches admin (check FIRST)
  const adminCheck = isAdminCode(pinStr);
  if (adminCheck) {
    matchedRole = 'Admin';
    matchedName = settings.ownerName || settings.adminName || 'Admin';
    // Create a worker-like object for consistency
    matchedWorker = { name: matchedName, pin: pinStr, role: 'Admin' };
    console.log('[Tasks] Admin code validated for finish task:', matchedName);
  }
  // Check if PIN matches manager (check SECOND)
  else {
    const managerCheck = isManagerCode(pinStr);
    if (managerCheck) {
      const managers = settings.managers || [];
      const manager = managers.find(m => {
        if (!m.code) return false;
        return m.code.toString().trim() === pinStr;
      });
      if (manager) {
        matchedRole = 'Manager';
        matchedName = manager.name || 'Manager';
        matchedWorker = { name: matchedName, pin: pinStr, role: 'Manager' };
        console.log('[Tasks] Manager code validated for finish task:', matchedName);
      } else {
        console.warn('[Tasks] isManagerCode returned true but manager not found in list');
      }
    }
    // Check if PIN matches worker (tech) (check THIRD)
    else {
      const workersList = settings.workers || [];
      for (let i = 0; i < workersList.length; i++) {
        const worker = workersList[i];
        if (!worker.pin) continue;
        // Use exact same comparison as JOIN: w.pin.toString() === pin
        const workerPinStr = worker.pin.toString().trim();
        if (workerPinStr === pinStr) {
          matchedWorker = worker;
          matchedRole = 'Tech';
          matchedName = worker.name;
          console.log('[Tasks] Tech code validated for finish task:', matchedName);
          break;
        }
      }
    }
  }
  
  if (!matchedWorker) {
    // Debug: log what we're comparing to help troubleshoot
    console.log('[Tasks] Code validation failed for finish task - no match found:', {
      enteredCode: pinStr,
      codeType: typeof pinStr,
      codeLength: pinStr.length,
      isAdminCheck: isAdminCode(pinStr),
      isManagerCheck: isManagerCode(pinStr),
      workersCount: (settings.workers || []).length,
      managersCount: (settings.managers || []).length
    });
    if (error) error.textContent = 'Invalid code. Please enter admin, manager, or staff code.';
    input.value = '';
    setTimeout(() => input.focus(), 100);
    return; // Don't close modal - user needs to correct code
  }
  
  console.log('[Tasks] Code validation SUCCESS for finish task:', {
    role: matchedRole,
    name: matchedName,
    code: pinStr
  });
  
  const worker = matchedWorker;
  
  // PIN is valid - record in history who completed it
  // Use getActorInfo to properly determine role based on the code
  let actor = null;
  if (matchedRole === 'Admin') {
    actor = getActorForAction({ adminCode: pin });
  } else if (matchedRole === 'Manager') {
    actor = getActorForAction({ managerCode: pin });
  } else {
    actor = getActorForAction({ workerName: matchedName });
  }
  addHistoryEntry(`Complete task: ${currentFinishTask.taskName} (${currentFinishTask.category})`, actor, matchedName);
  
  // PIN is valid - mark task as done
  const today = getTodayDateString();
  if (!completedTasks[today]) {
    completedTasks[today] = {};
  }
  if (!completedTasks[today][currentFinishTask.category]) {
    completedTasks[today][currentFinishTask.category] = [];
  }
  
  // Add to completed tasks if not already there
  if (!completedTasks[today][currentFinishTask.category].includes(currentFinishTask.taskName)) {
    completedTasks[today][currentFinishTask.category].push(currentFinishTask.taskName);
  }
  
  // Remove from pending list (done tasks should not appear in "My Tasks (Pending)")
  const pending = pendingTasks[currentFinishTask.category] || [];
  const pendingIndex = pending.indexOf(currentFinishTask.taskName);
  if (pendingIndex !== -1) {
    pending.splice(pendingIndex, 1);
    pendingTasks[currentFinishTask.category] = pending;
  }
  
  // Save to localStorage
  saveTasksData();
  
  // Close modal immediately
  closeFinishTaskModal();
  
  // Re-render both columns immediately (before async Firestore save)
  renderTasks();
  renderPendingTasks();
  
  // Update tab badges
  if (typeof updateAllTabBadges === 'function') {
    updateAllTabBadges();
  }
  
  // Update Tasks button badge (for incomplete tasks count)
  if (typeof updateTasksButtonBadge === 'function') {
    updateTasksButtonBadge();
  }
  
  // Save to Firestore (async, doesn't block UI update)
  saveTaskCompletionToFirestore(
    currentFinishTask.category,
    currentFinishTask.taskName,
    worker.name,
    pin
  ).catch(err => {
    console.error('[Tasks] Firestore save failed (non-blocking):', err);
  });
}

// Save task completion to Firestore
async function saveTaskCompletionToFirestore(category, taskName, staffName, staffCode) {
  try {
    const today = getTodayDateString();
    const now = new Date();
    
    const completionData = {
      date: today,
      timestamp: now.toISOString(),
      period: category,
      taskLabel: taskName,
      staffName: staffName || '',
      staffCode: staffCode || '',
      status: 'done'
    };
    
    // Use the function exposed by app.js
    if (typeof window.saveTaskCompletion === 'function') {
      await window.saveTaskCompletion(completionData);
    } else {
      console.warn('[Tasks] saveTaskCompletion function not available, task completion saved to localStorage only');
    }
  } catch(e) {
    console.error('[Tasks] Failed to save task completion to Firestore:', e);
    // Don't throw - localStorage save already succeeded
  }
}

// Render pending tasks for current category (right column)
function renderPendingTasks() {
  const category = getCurrentTasksCategory();
  const container = document.getElementById('pendingTasksContainer');
  if (!container) return;
  
  const pending = pendingTasks[category] || [];
  
  // Normalize pending array: convert strings to objects for backward compatibility
  const normalizedPending = pending.map(item => {
    if (typeof item === 'string') {
      // Old format: just task name string
      return { taskName: item, assignedToName: undefined };
    }
    // New format: already an object
    return item;
  });
  
  // Filter out done tasks - they should not appear in "My Tasks (Pending)"
  const activePending = normalizedPending.filter(item => {
    const taskName = typeof item === 'string' ? item : item.taskName;
    const status = getTaskStatus(category, taskName);
    return status !== 'done';
  });
  
  container.innerHTML = '';
  
  if (activePending.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sub);"><p style="font-size:13px;">No pending tasks.</p></div>';
    return;
  }
  
  activePending.forEach((item, index) => {
    // Extract task name and assigned name from item (handles both old string format and new object format)
    const taskName = typeof item === 'string' ? item : item.taskName;
    const assignedToName = typeof item === 'string' ? undefined : item.assignedToName;
    const status = getTaskStatus(category, taskName);
    
    // Find the task object to get instructions
    const tasks = tasksData[category] || [];
    const taskObj = tasks.find(t => getTaskName(t) === taskName);
    const taskInstructions = taskObj ? getTaskInstructions(taskObj) : '';
    
    const taskDiv = document.createElement('div');
    // Determine background color and opacity based on status
    let bgColor, opacity;
    if (status === 'done') {
      bgColor = '#f3f4f6';
      opacity = '0.7';
    } else {
      bgColor = 'var(--muted)';
      opacity = '1';
    }
    taskDiv.style.cssText = `display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:${bgColor};border-radius:8px;border:1px solid var(--border);opacity:${opacity};margin-bottom:6px;`;
    
    const leftDiv = document.createElement('div');
    leftDiv.style.cssText = 'display:flex;align-items:center;gap:8px;flex:1;';
    
    // Status dot color based on status
    let dotColor;
    if (status === 'done') {
      dotColor = '#9ca3af'; // grey
    } else {
      dotColor = '#6366f1'; // purple (pending)
    }
    
    const statusDot = document.createElement('div');
    statusDot.style.cssText = `width:8px;height:8px;border-radius:50%;background:${dotColor};flex-shrink:0;`;
    
    // Checkmark icon if done
    if (status === 'done') {
      const checkmark = document.createElement('span');
      checkmark.textContent = 'âœ“';
      checkmark.style.cssText = 'color:#10b981;font-size:13px;font-weight:bold;margin-right:4px;flex-shrink:0;';
      leftDiv.appendChild(checkmark);
    }
    
    const taskSpan = document.createElement('span');
    taskSpan.textContent = taskName;
    taskSpan.style.cssText = 'font-size:13px;color:var(--text);';
    
    leftDiv.appendChild(statusDot);
    leftDiv.appendChild(taskSpan);
    
    const rightDiv = document.createElement('div');
    rightDiv.style.cssText = 'display:flex;align-items:center;gap:6px;';
    
    // Info button removed from pending tasks - only show in main task list (left column)
    // Pending tasks should only show task name + Mark Done button
    
    // Hide "Mark Done" button if done
    if (status !== 'done') {
      // Show staff name BEFORE Mark Done button if available
      if (assignedToName && assignedToName.trim() !== '') {
        const nameSpan = document.createElement('span');
        nameSpan.textContent = assignedToName;
        // Match the font size and style of the "Mark Done" button
        nameSpan.style.cssText = 'font-size:11px;font-weight:700;color:var(--text);font-family:inherit;';
        rightDiv.appendChild(nameSpan);
      }
      
      const markDoneBtn = document.createElement('button');
      markDoneBtn.className = 'btn-mini';
      markDoneBtn.textContent = 'Mark Done';
      markDoneBtn.style.fontSize = '11px';
      markDoneBtn.style.padding = '6px 10px';
      markDoneBtn.type = 'button';
      markDoneBtn.style.pointerEvents = 'auto';
      markDoneBtn.style.cursor = 'pointer';
      // Add data attributes for event delegation
      markDoneBtn.setAttribute('data-action', 'mark-done');
      markDoneBtn.setAttribute('data-category', category);
      markDoneBtn.setAttribute('data-task-name', taskName);
      // Also add direct click handler as backup (in case event delegation fails)
      markDoneBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[Tasks] Mark Done button clicked directly:', { category, taskName });
        if (typeof openFinishTaskModal === 'function') {
          openFinishTaskModal(category, taskName);
        } else if (typeof markTaskAsDone === 'function') {
          console.log('[Tasks] Fallback: using markTaskAsDone directly');
          markTaskAsDone(category, taskName);
        } else {
          console.error('[Tasks] Neither openFinishTaskModal nor markTaskAsDone function found');
        }
      });
      rightDiv.appendChild(markDoneBtn);
    }
    
    taskDiv.appendChild(leftDiv);
    taskDiv.appendChild(rightDiv);
    container.appendChild(taskDiv);
  });
}

// Admin Access Modal functions
function openTasksAdminAccessModal(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  console.log("Tasks Settings clicked - opening admin access modal");
  const modal = document.getElementById('tasksAdminAccessModal');
  const modalContent = document.getElementById('tasksAdminAccessModalContent');
  const input = document.getElementById('tasksAdminPinInput');
  const error = document.getElementById('tasksAdminPinError');
  
  if (!modal) {
    console.error('[Tasks] Admin access modal not found in DOM');
    return;
  }
  
  if (!input) {
    console.error('[Tasks] Admin PIN input not found in DOM');
    return;
  }
  
  // Show modal with proper pointer events
  modal.style.display = 'flex';
  modal.style.pointerEvents = 'auto';
  modal.style.visibility = 'visible';
  modal.style.opacity = '1';
  
  // Ensure modal content is interactive
  if (modalContent) {
    modalContent.style.pointerEvents = 'auto';
    modalContent.style.position = 'relative';
    modalContent.style.zIndex = '1101';
  }
  
  // Clear any previous error
  if (error) {
    error.textContent = '';
  }
  
  // Clear input and focus it
  input.value = '';
  input.style.pointerEvents = 'auto';
  
  // Focus the input after a short delay to ensure modal is visible
  setTimeout(() => {
    input.focus();
  }, 50);
  
  console.log('[Tasks] Admin access modal opened');
}

function closeTasksAdminAccessModal() {
  console.log('[Tasks] Closing admin access modal');
  const modal = document.getElementById('tasksAdminAccessModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
  }
}

// Handle "Forgot admin PIN?" click
// This now calls the Cloud Function to send an email reset link instead of opening a modal
async function handleForgotAdminPin(event) {
  if (event) {
    event.preventDefault(); // Stop any default action
  }
  
  // Check if user is signed in
  if (!window.auth || !window.auth.currentUser) {
    alert('Please log in with your owner account to reset the admin PIN.');
    return;
  }
  
  // Show loading message
  alert('Sending PIN reset link. Please wait...');
  
  try {
    // Ensure Firebase Functions SDK is available
    if (!window.generatePinResetLink || typeof window.generatePinResetLink !== 'function') {
      throw new Error('Reset functionality is not available. Please refresh the page and try again.');
    }
    
    // Call the Cloud Function to generate reset link
    const result = await window.generatePinResetLink();
    
    // Success feedback
    const successMessage = result?.data?.message || 'Admin PIN reset link sent successfully to your email.';
    
    // Close any open modals
    closeTasksAdminAccessModal();
    
    // Show success alert
    alert('Success! ' + successMessage);
    
  } catch (error) {
    console.error('[AdminPIN] Error requesting PIN reset:', error);
    
    // Display user-friendly error message
    let errorMessage = 'Could not send reset link. ';
    
    if (error.code === 'unauthenticated') {
      errorMessage = 'Please log in to request a PIN reset.';
    } else if (error.code === 'failed-precondition') {
      errorMessage = 'Your account is not associated with a business. Please contact support.';
    } else if (error.code === 'internal') {
      errorMessage = 'Server error occurred. Please try again later or contact support.';
    } else if (error.message) {
      errorMessage = error.message;
    } else {
      errorMessage += 'Please try again or contact support.';
    }
    
    alert('Error: ' + errorMessage);
  }
}


function verifyTasksAdminPin() {
  const input = document.getElementById('tasksAdminPinInput');
  const error = document.getElementById('tasksAdminPinError');
  
  if (!input) return;
  
  const pin = input.value.trim();
  if (!pin) {
    if (error) error.textContent = 'Please enter admin code';
    return;
  }
  
  // Use existing isAdminCode function if available, otherwise hardcode '1234'
  let isValid = false;
  if (typeof isAdminCode === 'function') {
    isValid = isAdminCode(pin);
  } else {
    // Fallback: hardcoded admin PIN
    const ADMIN_PIN = '1234';
    isValid = pin === ADMIN_PIN;
  }
  
  if (isValid) {
    closeTasksAdminAccessModal();
    openTasksEditModal();
  } else {
    if (error) error.textContent = 'Invalid admin code';
    input.value = '';
    setTimeout(() => input.focus(), 100);
  }
}

// Tasks Edit Modal functions
let editModalTasks = []; // Local editable state for the modal (array of task objects: {name, instructions})

// Task Instructions Modal functions
function openTaskInstructionsModal(taskName, instructions) {
  const modal = document.getElementById('tasksInstructionsModal');
  const modalContent = document.getElementById('tasksInstructionsModalContent');
  const title = document.getElementById('tasksInstructionsModalTitle');
  const body = document.getElementById('tasksInstructionsModalBody');
  const closeBtn = document.getElementById('tasksInstructionsModalClose');
  
  if (modal && title && body) {
    title.textContent = taskName;
    body.textContent = instructions || 'No instructions available.';
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.pointerEvents = 'auto';
    
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Ensure Close button is enabled and clickable - reattach handler every time modal opens
    if (closeBtn) {
      closeBtn.style.pointerEvents = 'auto';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.position = 'relative';
      closeBtn.style.zIndex = '1102';
      closeBtn.disabled = false;
      closeBtn.setAttribute('type', 'button');
      
      // Reattach handler every time modal opens to ensure it works
      if (typeof window.attachInstructionsModalCloseHandler === 'function') {
        window.attachInstructionsModalCloseHandler();
        console.log('[Tasks] Instructions modal Close button handler reattached on open');
      }
    }
  }
}

function closeTaskInstructionsModal() {
  console.log('[Tasks] closeTaskInstructionsModal called');
  const modal = document.getElementById('tasksInstructionsModal');
  if (modal) {
    // Force close with multiple methods
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    modal.style.visibility = 'hidden';
    modal.style.opacity = '0';
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
    
    console.log('[Tasks] Modal closed successfully');
  } else {
    console.warn('[Tasks] Modal element not found');
  }
  
  // Clear any content
  const title = document.getElementById('tasksInstructionsModalTitle');
  const body = document.getElementById('tasksInstructionsModalBody');
  if (title) title.textContent = 'Task Instructions';
  if (body) body.textContent = '';
}

// Make function globally available
window.closeTaskInstructionsModal = closeTaskInstructionsModal;

function openTasksEditModal() {
  const modal = document.getElementById('tasksEditModal');
  const modalContent = document.getElementById('tasksEditModalContent');
  const title = document.getElementById('tasksEditModalTitle');
  const listContainer = document.getElementById('tasksEditModalList');
  
  if (modal) {
    // Get current category
    const activeTab = document.querySelector('.task-tab.active');
    const category = activeTab ? (activeTab.dataset.category || 'Opening') : 'Opening';
    
    // Update modal title with current category
    if (title) {
      title.textContent = `Edit Tasks â€“ ${category}`;
    }
    
    // Load current tasks for this category into local editable state (normalize to objects)
    const categoryTasks = tasksData[category] || [];
    editModalTasks = categoryTasks.map(task => normalizeTask(task));
    
    // Render editable task rows
    renderEditModalTasks();
    
    // Ensure modal is visible and clickable
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'auto';
    
    // Ensure modal content has proper z-index and pointer-events
    if (modalContent) {
      modalContent.style.zIndex = '1101';
      modalContent.style.position = 'relative';
      modalContent.style.pointerEvents = 'auto';
    }
    
    // Ensure Save and Cancel buttons are clickable
    const saveBtn = document.getElementById('tasksEditModalSave');
    const cancelBtn = document.getElementById('tasksEditModalCancel');
    const addBtn = document.getElementById('tasksEditAddTaskBtn');
    
    if (saveBtn) {
      saveBtn.disabled = false;
      saveBtn.removeAttribute('disabled');
      saveBtn.style.pointerEvents = 'auto';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.position = 'relative';
      saveBtn.style.zIndex = '1102';
      saveBtn.setAttribute('type', 'button');
    }
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.position = 'relative';
      cancelBtn.style.zIndex = '1102';
      cancelBtn.setAttribute('type', 'button');
    }
    if (addBtn) {
      addBtn.disabled = false;
      addBtn.removeAttribute('disabled');
      addBtn.style.pointerEvents = 'auto';
      addBtn.style.cursor = 'pointer';
      addBtn.setAttribute('type', 'button');
    }
  }
}

function closeTasksEditModal() {
  const modal = document.getElementById('tasksEditModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
    editModalTasks = []; // Clear local state
  }
}

function renderEditModalTasks() {
  const listContainer = document.getElementById('tasksEditModalList');
  if (!listContainer) return;
  
  listContainer.innerHTML = '';
  
  editModalTasks.forEach((task, index) => {
    const row = createEditModalTaskRow(task, index);
    listContainer.appendChild(row);
  });
}

function createEditModalTaskRow(task, index) {
  // Normalize task to object format
  const normalizedTask = normalizeTask(task);
  
  const row = document.createElement('div');
  row.className = 'edit-task-row';
  row.style.cssText = 'display:flex;flex-direction:column;gap:8px;padding:12px;background:var(--muted);border-radius:8px;border:1px solid var(--border);';
  
  // Top row: dot, input, delete button
  const topRow = document.createElement('div');
  topRow.style.cssText = 'display:flex;align-items:center;gap:10px;';
  
  // Status dot
  const dot = document.createElement('div');
  dot.style.cssText = 'width:8px;height:8px;border-radius:50%;background:#10b981;flex-shrink:0;';
  
  // Task name input
  const input = document.createElement('input');
  input.type = 'text';
  input.value = normalizedTask.name;
  input.placeholder = 'Task name';
  input.style.cssText = 'flex:1;border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:14px;outline:none;background:#fff;';
  input.addEventListener('input', (e) => {
    if (!editModalTasks[index] || typeof editModalTasks[index] === 'string') {
      editModalTasks[index] = { name: e.target.value, instructions: '' };
    } else {
      editModalTasks[index].name = e.target.value;
    }
  });
  
  // Delete button
  const deleteBtn = document.createElement('button');
  deleteBtn.innerHTML = 'âœ–';
  deleteBtn.className = 'btn-mini';
  deleteBtn.style.cssText = 'width:28px;height:28px;padding:0;display:flex;align-items:center;justify-content:center;font-size:14px;color:#ef4444;border-color:#fca5a5;flex-shrink:0;';
  deleteBtn.title = 'Delete task';
  deleteBtn.addEventListener('click', () => {
    editModalTasks.splice(index, 1);
    renderEditModalTasks();
  });
  
  topRow.appendChild(dot);
  topRow.appendChild(input);
  topRow.appendChild(deleteBtn);
  
  // Instructions textarea
  const instructionsTextarea = document.createElement('textarea');
  instructionsTextarea.value = normalizedTask.instructions || '';
  instructionsTextarea.placeholder = 'Instructions (optional) â€“ how to do this task';
  instructionsTextarea.rows = 2;
  instructionsTextarea.style.cssText = 'width:100%;border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:13px;outline:none;background:#fff;font-family:inherit;resize:vertical;';
  instructionsTextarea.addEventListener('input', (e) => {
    if (!editModalTasks[index] || typeof editModalTasks[index] === 'string') {
      editModalTasks[index] = { name: normalizedTask.name, instructions: e.target.value };
    } else {
      editModalTasks[index].instructions = e.target.value;
    }
  });
  
  row.appendChild(topRow);
  row.appendChild(instructionsTextarea);
  
  return row;
}

// Guard to prevent double-clicking
let isAddingTask = false;

function addTaskToEditModal() {
  // Prevent double execution
  if (isAddingTask) {
    console.log('[Tasks] Already adding a task, ignoring duplicate call');
    return;
  }
  
  isAddingTask = true;
  console.log('[Tasks] Adding new task to edit modal');
  
  try {
    editModalTasks.push({ name: '', instructions: '' });
    renderEditModalTasks();
    console.log('[Tasks] Task added. Total tasks in modal:', editModalTasks.length);
    
    // Focus the new input
    const listContainer = document.getElementById('tasksEditModalList');
    if (listContainer) {
      const lastRow = listContainer.lastElementChild;
      if (lastRow) {
        const input = lastRow.querySelector('input');
        if (input) {
          setTimeout(() => input.focus(), 50);
        }
      }
    }
  } catch (error) {
    console.error('[Tasks] Error adding task:', error);
  } finally {
    // Reset flag after a short delay to allow for legitimate rapid clicks
    setTimeout(() => {
      isAddingTask = false;
    }, 500);
  }
}

function saveEditModalTasks() {
  const category = getCurrentTasksCategory();
  const listContainer = document.getElementById('tasksEditModalList');
  
  // Read tasks directly from DOM inputs to ensure we get the latest values
  // This is more reliable than relying on state that might be out of sync
  const validTasks = [];
  
  if (listContainer) {
    // Use class selector for more reliable row finding
    const taskRows = listContainer.querySelectorAll('.edit-task-row');
    taskRows.forEach((row) => {
      const nameInput = row.querySelector('input[type="text"]');
      const instructionsTextarea = row.querySelector('textarea');
      
      if (nameInput) {
        const taskName = (nameInput.value || '').trim();
        const instructions = instructionsTextarea ? (instructionsTextarea.value || '').trim() : '';
        
        // Only add if task name is not empty
        if (taskName.length > 0) {
          validTasks.push({
            name: taskName,
            instructions: instructions
          });
        }
      }
    });
  } else {
    // Fallback: use editModalTasks state if DOM reading fails
    console.warn('[Tasks] Could not read from DOM, using state fallback');
    validTasks.push(...editModalTasks
      .map(t => {
        const normalized = normalizeTask(t);
        return {
          name: normalized.name.trim(),
          instructions: (normalized.instructions || '').trim()
        };
      })
      .filter(t => t.name.length > 0));
  }
  
  console.log('[Tasks] Saving tasks for category:', category, 'Tasks:', validTasks);
  
  // Update main tasks state - ensure it's an array
  if (!Array.isArray(validTasks)) {
    console.error('[Tasks] validTasks is not an array:', validTasks);
    return;
  }
  
  tasksData[category] = validTasks;
  
  // Update global reference immediately
  window.tasksData = tasksData;
  
  // Save to localStorage
  saveTasksData();
  
  // Verify the save worked
  const verify = localStorage.getItem('fairflow_tasks_config');
  if (verify) {
    const parsed = JSON.parse(verify);
    console.log('[Tasks] Verification - Saved', category, ':', parsed[category]);
  }
  
  // Re-render main task list - ensure we're rendering the correct category
  // First, make sure the active tab matches the category we just saved
  const categoryTabs = document.querySelectorAll('.task-tab');
  categoryTabs.forEach(tab => {
    if (tab.dataset.category === category) {
      tab.classList.add('active');
    } else {
      tab.classList.remove('active');
    }
  });
  
  // Update selected category span
  const selectedCategorySpan = document.getElementById('selectedCategorySpan');
  if (selectedCategorySpan) {
    selectedCategorySpan.textContent = category;
  }
  
  // Now render tasks
  if (typeof renderTasks === 'function') {
    renderTasks();
  } else {
    console.error('[Tasks] renderTasks function not found');
  }
  
  // Also re-render pending tasks
  if (typeof renderPendingTasks === 'function') {
    renderPendingTasks();
  }
  
  // Close modal first
  closeTasksEditModal();
  
  // Render tasks once after a short delay to ensure DOM is ready
  setTimeout(() => {
    console.log('[Tasks] Re-rendering after save');
    if (typeof renderTasks === 'function') {
      renderTasks();
    } else {
      console.error('[Tasks] renderTasks function not found');
    }
    
    // Also re-render pending tasks
    if (typeof renderPendingTasks === 'function') {
      renderPendingTasks();
    }
    
    // Update badges
    if (typeof updateAllTabBadges === 'function') {
      updateAllTabBadges();
    }
  }, 100);
}

// Initialize tasks functionality
function initTasksFunctionality() {
  initTasksData();
  
  // Modal handlers - initialize once on page load
  // Admin Access Modal handlers
  const adminModal = document.getElementById('tasksAdminAccessModal');
  const adminModalContent = document.getElementById('tasksAdminAccessModalContent');
  const adminPinInput = document.getElementById('tasksAdminPinInput');
  const adminContinueBtn = document.getElementById('tasksAdminAccessContinue');
  const adminCancelBtn = document.getElementById('tasksAdminAccessCancel');
  
  // Close admin modal when clicking outside (on overlay)
  if (adminModal && adminModalContent) {
    adminModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the backdrop (modal itself), not on content
      if (e.target === adminModal && !adminModalContent.contains(e.target)) {
        console.log('[Tasks] Closing admin modal - backdrop clicked');
        closeTasksAdminAccessModal();
      }
    });
    // Ensure modal backdrop is clickable
    adminModal.style.pointerEvents = 'auto';
  }
  
  // Cancel button
  if (adminCancelBtn) {
    adminCancelBtn.addEventListener('click', closeTasksAdminAccessModal);
  }
  
  // Forgot admin PIN button
  const forgotAdminPinBtn = document.getElementById('tasksForgotAdminPin');
  if (forgotAdminPinBtn) {
    forgotAdminPinBtn.addEventListener('click', handleForgotAdminPin);
  }
  
  // Continue button - validates PIN
  if (adminContinueBtn) {
    adminContinueBtn.addEventListener('click', verifyTasksAdminPin);
  }
  
  // Enter key to continue
  if (adminPinInput) {
    adminPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        verifyTasksAdminPin();
      } else if (e.key === 'Escape') {
        closeTasksAdminAccessModal();
      }
    });
  }
  
  // Numeric-only input for PIN fields (these elements may not exist yet, so check)
  const resetPinNewInput = document.getElementById('reset-pin-new');
  const resetPinConfirmInput = document.getElementById('reset-pin-confirm');
  if (resetPinNewInput) {
    resetPinNewInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
  }
  if (resetPinConfirmInput) {
    resetPinConfirmInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
  }
  
  // Tasks Edit Modal handlers
  const editModal = document.getElementById('tasksEditModal');
  const editModalContent = document.getElementById('tasksEditModalContent');
  const editModalCancel = document.getElementById('tasksEditModalCancel');
  const editModalSave = document.getElementById('tasksEditModalSave');
  const editAddTaskBtn = document.getElementById('tasksEditAddTaskBtn');
  
  // Close edit modal when clicking outside (on overlay)
  if (editModal && editModalContent) {
    editModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay background, not on the content
      if (e.target === editModal && !editModalContent.contains(e.target)) {
        closeTasksEditModal();
      }
      // Don't stop propagation for content clicks - let buttons handle their own clicks
    });
  }
  
  // Cancel button - use only addEventListener to prevent double execution
  if (editModalCancel) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[Tasks] Edit modal cancel clicked');
      closeTasksEditModal();
    };
    // Remove old handler and add new one
    const newCancel = editModalCancel.cloneNode(true);
    editModalCancel.parentNode.replaceChild(newCancel, editModalCancel);
    const freshCancel = document.getElementById('tasksEditModalCancel');
    if (freshCancel) {
      freshCancel.addEventListener('click', cancelHandler);
      freshCancel.disabled = false;
      freshCancel.removeAttribute('disabled');
      freshCancel.style.pointerEvents = 'auto';
      freshCancel.style.cursor = 'pointer';
      freshCancel.setAttribute('type', 'button');
    }
  }
  
  // Save button - use only addEventListener to prevent double execution
  if (editModalSave) {
    const saveHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('[Tasks] Edit modal save clicked');
      if (typeof saveEditModalTasks === 'function') {
        saveEditModalTasks();
      } else {
        console.error('[Tasks] saveEditModalTasks function not found');
        closeTasksEditModal();
      }
    };
    // Remove old handler and add new one
    const newSave = editModalSave.cloneNode(true);
    editModalSave.parentNode.replaceChild(newSave, editModalSave);
    const freshSave = document.getElementById('tasksEditModalSave');
    if (freshSave) {
      freshSave.addEventListener('click', saveHandler);
      freshSave.disabled = false;
      freshSave.removeAttribute('disabled');
      freshSave.style.pointerEvents = 'auto';
      freshSave.style.cursor = 'pointer';
      freshSave.setAttribute('type', 'button');
    }
  }
  
  // Add task button in edit modal
  if (editAddTaskBtn) {
    const addHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof addTaskToEditModal === 'function') {
        addTaskToEditModal();
      }
    };
    editAddTaskBtn.addEventListener('click', addHandler);
    editAddTaskBtn.onclick = addHandler; // Fallback
    editAddTaskBtn.setAttribute('type', 'button');
    editAddTaskBtn.style.pointerEvents = 'auto';
    editAddTaskBtn.style.cursor = 'pointer';
  }
  
  // Task Instructions Modal handlers
  const instructionsModal = document.getElementById('tasksInstructionsModal');
  const instructionsModalContent = document.getElementById('tasksInstructionsModalContent');
  const instructionsCloseBtn = document.getElementById('tasksInstructionsModalClose');
  
  // Close instructions modal when clicking outside (on overlay)
  if (instructionsModal && instructionsModalContent) {
    instructionsModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay, not on the content
      if (e.target === instructionsModal) {
        console.log('[Tasks] Instructions modal overlay clicked');
        closeTaskInstructionsModal();
      }
    });
  }
  
  // Close button - attach handler directly (will be reattached when modal opens too)
  const attachCloseHandler = () => {
    const closeBtn = document.getElementById('tasksInstructionsModalClose');
    if (closeBtn) {
      // Create a robust close handler
      const closeHandler = (e) => {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
        console.log('[Tasks] Instructions modal Close button clicked');
        closeTaskInstructionsModal();
        return false;
      };
      
      // Remove old listeners by cloning
      const newCloseBtn = closeBtn.cloneNode(true);
      closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
      
      // Attach multiple event handlers for maximum compatibility
      newCloseBtn.addEventListener('click', closeHandler, true); // Use capture phase
      newCloseBtn.onclick = closeHandler; // Direct onclick fallback
      
      // Ensure button is enabled and clickable
      newCloseBtn.disabled = false;
      newCloseBtn.style.pointerEvents = 'auto';
      newCloseBtn.style.cursor = 'pointer';
      newCloseBtn.style.position = 'relative';
      newCloseBtn.style.zIndex = '1102';
      newCloseBtn.setAttribute('type', 'button');
      
      console.log('[Tasks] Instructions modal Close button handler attached');
      return newCloseBtn;
    }
    return null;
  };
  
  // Attach handler on initialization
  attachCloseHandler();
  
  // Also make it available globally so it can be called when modal opens
  window.attachInstructionsModalCloseHandler = attachCloseHandler;
  
  // Event delegation for "Mark Done" buttons in pending tasks container
  // Use a flag to prevent duplicate listeners
  if (!window._tasksMarkDoneHandlerAttached) {
    const pendingTasksContainer = document.getElementById('pendingTasksContainer');
    if (pendingTasksContainer) {
      pendingTasksContainer.addEventListener('click', (e) => {
        // Check if click came from a "Mark Done" button
        const markDoneBtn = e.target.closest('[data-action="mark-done"]');
        if (markDoneBtn) {
          e.preventDefault();
          e.stopPropagation();
          const category = markDoneBtn.getAttribute('data-category');
          const taskName = markDoneBtn.getAttribute('data-task-name');
          
          if (category && taskName) {
            // Open the Finish task modal (requires PIN validation)
            if (typeof openFinishTaskModal === 'function') {
              openFinishTaskModal(category, taskName);
            } else if (typeof markTaskAsDone === 'function') {
              // Fallback: mark as done directly without PIN
              markTaskAsDone(category, taskName);
            } else {
              console.error('[Tasks] Neither openFinishTaskModal nor markTaskAsDone function found');
            }
          }
        }
      });
      window._tasksMarkDoneHandlerAttached = true;
    } else {
      console.warn('[Tasks] pendingTasksContainer not found on init - will retry on render');
    }
  }
  
  // Tasks Select Modal handlers
  const selectModal = document.getElementById('tasksSelectModal');
  const selectModalContent = document.getElementById('tasksSelectModalContent');
  const selectPinInput = document.getElementById('tasksSelectPinInput');
  const selectConfirmBtn = document.getElementById('tasksSelectConfirm');
  const selectCancelBtn = document.getElementById('tasksSelectCancel');
  
  // Close select modal when clicking outside (on overlay)
  if (selectModal && selectModalContent) {
    selectModal.addEventListener('click', (e) => {
      if (e.target === selectModal) {
        closeSelectTaskModal();
      }
    });
  }
  
  // Cancel button - instantly closes the modal and clears input
  if (selectCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Clear input field
      const input = document.getElementById('tasksSelectPinInput');
      if (input) {
        input.value = '';
      }
      // Clear error message
      const error = document.getElementById('tasksSelectPinError');
      if (error) {
        error.textContent = '';
      }
      // Clear state
      taskStaffCode = '';
      // Close modal
      const taskModal = document.getElementById('tasksSelectModal');
      if (taskModal) {
        taskModal.style.display = 'none';
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    selectCancelBtn.addEventListener('click', cancelHandler);
    selectCancelBtn.onclick = cancelHandler; // Fallback direct assignment
    // Ensure button is never disabled
    selectCancelBtn.disabled = false;
    selectCancelBtn.removeAttribute('disabled');
  }
  
  // Confirm button - validates PIN and adds task to pending
  if (selectConfirmBtn) {
    // Verify function exists
    if (typeof confirmSelectTask !== 'function') {
      console.error('[Tasks] confirmSelectTask function not found');
    }
    
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      // Call the confirmation function
      if (typeof confirmSelectTask === 'function') {
        confirmSelectTask();
      } else {
        console.error('[Tasks] confirmSelectTask function not available');
        // Fallback: close modal
        const taskModal = document.getElementById('tasksSelectModal');
        if (taskModal) {
          taskModal.style.display = 'none';
        }
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    selectConfirmBtn.addEventListener('click', confirmHandler);
    selectConfirmBtn.onclick = confirmHandler; // Fallback direct assignment
    // Ensure button is never disabled
    selectConfirmBtn.disabled = false;
    selectConfirmBtn.removeAttribute('disabled');
  }
  
  // Input handler - updates state with numeric-only, max 4 digits
  if (selectPinInput) {
    // Handle input events - updates state with typed value
    // CRITICAL: Always keep input.value and taskStaffCode state in sync
    selectPinInput.addEventListener('input', (e) => {
      const input = e.target;
      // Keep only digits, limit to 4 characters
      let value = input.value.replace(/\D/g, '').slice(0, 4);
      
      // ALWAYS update both input value and state to keep them perfectly in sync
      input.value = value;
      taskStaffCode = value;
      
      // Clear error message when user types
      const error = document.getElementById('tasksSelectPinError');
      if (error) {
        error.textContent = '';
      }
    });
    
    // Handle paste events
    selectPinInput.addEventListener('paste', (e) => {
      e.preventDefault();
      const pastedText = (e.clipboardData || window.clipboardData).getData('text');
      const numericOnly = pastedText.replace(/\D/g, '').slice(0, 4);
      if (numericOnly) {
        selectPinInput.value = numericOnly;
        taskStaffCode = numericOnly;
        // Clear error message when user pastes
        const error = document.getElementById('tasksSelectPinError');
        if (error && error.textContent) {
          error.textContent = '';
        }
        // Trigger input event to ensure consistency
        selectPinInput.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
    
    // Enter key to confirm, Escape to close
    selectPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmSelectTask();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        closeSelectTaskModal();
      }
      // All other keys are allowed - no preventDefault() to allow normal typing
    });
  }
  
  // Tasks Finish Modal handlers
  const finishModal = document.getElementById('tasksFinishModal');
  const finishModalContent = document.getElementById('tasksFinishModalContent');
  const finishPinInput = document.getElementById('tasksFinishPinInput');
  const finishConfirmBtn = document.getElementById('tasksFinishConfirm');
  const finishCancelBtn = document.getElementById('tasksFinishCancel');
  
  // Close finish modal when clicking outside (on overlay)
  if (finishModal && finishModalContent) {
    finishModal.addEventListener('click', (e) => {
      // Only close if clicking directly on the overlay background, not on the content
      // Check if the click target is the modal itself (overlay) and not the content or any child
      if (e.target === finishModal && !finishModalContent.contains(e.target)) {
        closeFinishTaskModal();
      }
      // Don't stop propagation for content clicks - let buttons handle their own clicks
    });
  }
  
  // Cancel button
  if (finishCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeFinishTaskModal();
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    finishCancelBtn.addEventListener('click', cancelHandler); // Fallback direct assignment
    // Ensure button is never disabled
    finishCancelBtn.disabled = false;
    finishCancelBtn.removeAttribute('disabled');
    finishCancelBtn.style.pointerEvents = 'auto';
    finishCancelBtn.style.cursor = 'pointer';
  }
  
  // Confirm button - validates PIN and marks task as done
  if (finishConfirmBtn) {
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof confirmFinishTask === 'function') {
        confirmFinishTask();
      } else {
        console.error('[Tasks] confirmFinishTask function not found');
        // Fallback: close modal
        closeFinishTaskModal();
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    finishConfirmBtn.addEventListener('click', confirmHandler);
    // Ensure button is never disabled
    finishConfirmBtn.disabled = false;
    finishConfirmBtn.removeAttribute('disabled');
    finishConfirmBtn.style.pointerEvents = 'auto';
    finishConfirmBtn.style.cursor = 'pointer';
  }
  
  // Enter key to confirm
  if (finishPinInput) {
    finishPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        confirmFinishTask();
      } else if (e.key === 'Escape') {
        closeFinishTaskModal();
      }
    });
  }
  
  // Tasks Reset Modal handlers
  const resetModal = document.getElementById('tasksResetModal');
  const resetModalContent = document.getElementById('tasksResetModalContent');
  const resetPinInput = document.getElementById('tasksResetPinInput');
  const resetConfirmBtn = document.getElementById('tasksResetConfirm');
  const resetCancelBtn = document.getElementById('tasksResetCancel');
  
  // Close reset modal when clicking outside (on overlay)
  if (resetModal && resetModalContent) {
    // Remove any existing listeners first
    const newResetModal = resetModal.cloneNode(true);
    resetModal.parentNode.replaceChild(newResetModal, resetModal);
    const freshResetModal = document.getElementById('tasksResetModal');
    const freshResetModalContent = document.getElementById('tasksResetModalContent');
    
    if (freshResetModal && freshResetModalContent) {
      freshResetModal.addEventListener('click', (e) => {
        // Only close if clicking directly on the overlay background, not on the content
        // Check if the click target is the modal itself (overlay) and not the content or any child
        if (e.target === freshResetModal && !freshResetModalContent.contains(e.target)) {
          closeTasksResetModal();
        }
        // Don't stop propagation for content clicks - let buttons handle their own clicks
      });
    }
  }
  
  // Cancel button
  if (resetCancelBtn) {
    const cancelHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeTasksResetModal();
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    resetCancelBtn.addEventListener('click', cancelHandler); // Fallback direct assignment
    // Ensure button is never disabled
    resetCancelBtn.disabled = false;
    resetCancelBtn.removeAttribute('disabled');
    resetCancelBtn.style.pointerEvents = 'auto';
    resetCancelBtn.style.cursor = 'pointer';
  }
  
  // Confirm button - validates PIN and resets tasks
  if (resetConfirmBtn) {
    const confirmHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (typeof confirmTasksReset === 'function') {
        confirmTasksReset();
      } else {
        console.error('[Tasks] confirmTasksReset function not found');
        // Fallback: close modal
        closeTasksResetModal();
      }
    };
    // Use both addEventListener and onclick for maximum compatibility
    // Use only addEventListener to prevent double execution
    resetConfirmBtn.addEventListener('click', confirmHandler);
    // Ensure button is never disabled
    resetConfirmBtn.disabled = false;
    resetConfirmBtn.removeAttribute('disabled');
    resetConfirmBtn.style.pointerEvents = 'auto';
    resetConfirmBtn.style.cursor = 'pointer';
  }
  
  // Enter key to confirm
  if (resetPinInput) {
    resetPinInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        confirmTasksReset();
      } else if (e.key === 'Escape') {
        closeTasksResetModal();
      }
    });
  }
  
  // Make renderTasks and renderPendingTasks globally available
  window.renderTasks = renderTasks;
  window.renderPendingTasks = renderPendingTasks;
  // Make task functions globally available
  window.openFinishTaskModal = openFinishTaskModal;
  window.markTaskAsDone = markTaskAsDone;
  window.confirmFinishTask = confirmFinishTask;
  
  // Render initial tasks and pending tasks
  renderTasks();
  renderPendingTasks();
}

// Add Technician dialog functions

function openAddTechDialog(){
  if (reorderMode) {
    console.log("Add technician clicked in reorder mode");
  } else {
    console.log("Add technician clicked");
  }
  
  const addTechDlg = document.getElementById('addTechDlg');

  const addTechSelect = document.getElementById('addTechSelect');

  const addTechConfirm = document.getElementById('addTechConfirm');

  if (!addTechDlg || !addTechSelect) return;

  

  // Clear and populate select with technicians not already in queue

  addTechSelect.innerHTML = '<option value="">-- Select technician --</option>';

  

  const availableNames = new Set(queue.map(q => q.name).concat(service.map(s => s.name)));

  const options = [];

  settings.workers.forEach(w => {

    if (!availableNames.has(w.name)) {

      const opt = document.createElement('option');

      opt.value = w.name;

      opt.textContent = w.name;

      addTechSelect.appendChild(opt);
      options.push(w.name);

    }

  });

  // Log technician options for debugging
  console.log("technician options", options);

  

  // CRITICAL: Ensure select dropdown is fully interactive
  // Remove any disabled state
  addTechSelect.disabled = false;
  addTechSelect.removeAttribute('disabled');
  
  // Ensure pointer events are enabled
  addTechSelect.style.pointerEvents = 'auto';
  addTechSelect.style.cursor = 'pointer';
  addTechSelect.style.zIndex = '1001'; // Above dialog backdrop
  addTechSelect.style.position = 'relative';
  
  // Ensure the select is not blocked by any overlay
  const selectParent = addTechSelect.closest('dialog, .code-dialog');
  if (selectParent) {
    selectParent.style.zIndex = '1000';
    selectParent.style.pointerEvents = 'auto';
  }

  // Disable Add button initially

  if (addTechConfirm) addTechConfirm.disabled = true;

  

  // Enable/disable Add button based on selection

  addTechSelect.onchange = () => {

    if (addTechConfirm) addTechConfirm.disabled = !addTechSelect.value;

  };

  

  addTechDlg.showModal();
  
  // After modal is shown, ensure select and buttons are interactive
  setTimeout(() => {
    if (addTechSelect) {
      addTechSelect.style.pointerEvents = 'auto';
      addTechSelect.style.cursor = 'pointer';
      addTechSelect.disabled = false;
      addTechSelect.removeAttribute('disabled');
      console.log('[AddTech] Select dropdown enabled and ready');
    }
    
    // Re-setup button handlers after modal opens to ensure they work
    setupAddTechnicianButtons();
    
    // Ensure buttons are interactive
    const cancelBtn = document.getElementById('addTechCancel');
    const confirmBtn = document.getElementById('addTechConfirm');
    if (cancelBtn) {
      cancelBtn.style.pointerEvents = 'auto';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.disabled = false;
      cancelBtn.removeAttribute('disabled');
    }
    if (confirmBtn) {
      confirmBtn.style.pointerEvents = 'auto';
      confirmBtn.style.cursor = confirmBtn.disabled ? 'not-allowed' : 'pointer';
      // Don't override disabled state, but ensure pointer events if enabled
      if (!confirmBtn.disabled) {
        confirmBtn.style.pointerEvents = 'auto';
      }
    }
    console.log('[AddTech] Buttons enabled and ready');
  }, 50);

}

function addTechnicianToQueue(){
  const addTechSelect = document.getElementById('addTechSelect');
  const addTechDlg = document.getElementById('addTechDlg');
  const name = addTechSelect ? addTechSelect.value : '';

  console.log("Add technician clicked", name || 'none');
  
  if (!name) {
    console.log("Add technician: No technician selected");
    return;
  }

  

  // Check if already in queue (shouldn't happen due to filtering, but safety check)

  if (queue.some(x => x.name === name) || service.some(x => x.name === name)) {

    alert('This technician is already active');

    return;

  }

  

  // Add to end of queue

  queue.push({name, held: false});

  log.unshift(stamp() + ` REORDER: ADD ${name} BY MANAGER`);

  save();

  renderQueue();

  addTechDlg.close();

  // Add technician is done in reorder mode which requires manager/admin code
  const lastCode = window.__ff_lastValidatedCode;
  let actor;
  if (lastCode && (isAdminCode(lastCode) || isManagerCode(lastCode))) {
    if (isAdminCode(lastCode)) {
      actor = getActorForAction({ adminCode: lastCode });
    } else {
      actor = getActorForAction({ managerCode: lastCode });
    }
  } else {
    // Fallback to current actor state
    const role = window.__ff_actorRole || 'Manager';
    const actorName = window.__ff_actorName || 'Manager';
    actor = { role, name: actorName };
  }
  addHistoryEntry('Add technician to queue', actor, name);

}

// Bind Add Technician button and dialog buttons
function setupAddTechnicianButtons() {
  const addTechBtn = document.getElementById('addTechBtn');
  const addTechCancel = document.getElementById('addTechCancel');
  const addTechConfirm = document.getElementById('addTechConfirm');

  if (addTechBtn) addTechBtn.onclick = openAddTechDialog;

  // Cancel button handler with logging
  if (addTechCancel) {
    addTechCancel.onclick = (e) => {
      console.log("Cancel add technician clicked");
      e.preventDefault();
      e.stopPropagation();
      const dlg = document.getElementById('addTechDlg');
      if (dlg) {
        dlg.close();
      }
    };
    // Ensure button is interactive
    addTechCancel.style.pointerEvents = 'auto';
    addTechCancel.style.cursor = 'pointer';
  }

  // Add button handler with logging
  if (addTechConfirm) {
    addTechConfirm.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      addTechnicianToQueue();
    };
    // Ensure button is interactive
    addTechConfirm.style.pointerEvents = 'auto';
    addTechConfirm.style.cursor = 'pointer';
  }
}

// Initialize buttons on page load
const addTechBtn = document.getElementById('addTechBtn');
const addTechCancel = document.getElementById('addTechCancel');
const addTechConfirm = document.getElementById('addTechConfirm');

if (addTechBtn) addTechBtn.onclick = openAddTechDialog;
setupAddTechnicianButtons();

const eye=$("#togglePin");

eye.addEventListener("mousedown",()=>{ pinInput.type="text"; });

eye.addEventListener("touchstart",()=>{ pinInput.type="text"; },{passive:true});

const hide=()=>{ pinInput.type="password"; };

eye.addEventListener("mouseup",hide); eye.addEventListener("mouseleave",hide); eye.addEventListener("touchend",hide);



// Save

function save(){ ls("ffv24_settings",settings); ls("ffv24_queue",queue); ls("ffv24_service",service); ls("ffv24_log",log); }



// Init

function seedOnce(){

  if(!ls("ffv24_seeded")){

    queue.push({name:"Daniel",held:false});

    ls("ffv24_seeded",true); save();

  }

}

function init(){ 
  console.log('[init] Starting initialization...');
  
  // Get elements fresh
  const pinEl = document.getElementById("pinInput") || pinInput;
  const nameSelectEl = document.getElementById("nameSelect") || nameSelect;
  
  if (!pinEl) {
    console.error('[init] pinInput not found, DOM may not be ready');
    return;
  }
  
  if (!nameSelectEl) {
    console.error('[init] nameSelect not found, DOM may not be ready');
    // Try again after delay
    setTimeout(init, 200);
    return;
  }
  
  console.log('[init] Elements found, proceeding...');
  
  pinEl.type="password";

  // Ensure settings.workers is populated
  if (!settings.workers || !Array.isArray(settings.workers) || settings.workers.length === 0) {
    console.warn('[init] settings.workers is missing or empty, initializing from defaults');
    if (DEFAULTS.workers && Array.isArray(DEFAULTS.workers) && DEFAULTS.workers.length > 0) {
      settings.workers = DEFAULTS.workers.map(w => ({...w})); // Deep copy
      save();
      console.log('[init] Initialized', settings.workers.length, 'workers from defaults');
    }
  } else {
    console.log('[init] Found', settings.workers.length, 'workers in settings');
  }

  try {
    renderBrand(); 
    renderSelect(); 
    renderQueue(); 
    renderService(); 
    seedOnce();
    console.log('[init] Initialization complete');
  } catch (error) {
    console.error('[init] Error during initialization:', error);
  }
}

// Expose functions globally for app.js to call
window.renderSelect = renderSelect;
window.init = init;

// Ensure DOM is ready before calling init
if (document.readyState === 'loading') {
  console.log('[init] DOM is loading, waiting for DOMContentLoaded');
  document.addEventListener('DOMContentLoaded', () => {
    console.log('[init] DOMContentLoaded fired');
    setTimeout(init, 100); // Small delay to ensure all scripts are loaded
  });
} else {
  // DOM is already ready
  console.log('[init] DOM already ready, calling init');
  setTimeout(init, 100); // Small delay to ensure all scripts are loaded
}

// Also try to render when owner-view becomes visible (observer pattern)
if (!window.__uiObserver) {
  window.__uiObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
        const ownerView = document.getElementById("owner-view");
        if (ownerView && ownerView.style.display === 'block') {
          console.log('[Observer] owner-view became visible, calling renderSelect');
          setTimeout(() => {
            if (typeof renderSelect === 'function') {
              renderSelect();
            }
          }, 200);
        }
      }
    });
  });
}

// Start observing when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const ownerView = document.getElementById("owner-view");
    if (ownerView && window.__uiObserver) {
      window.__uiObserver.observe(ownerView, { attributes: true, attributeFilter: ['style'] });
    }
  });
} else {
  const ownerView = document.getElementById("owner-view");
  if (ownerView && window.__uiObserver) {
    window.__uiObserver.observe(ownerView, { attributes: true, attributeFilter: ['style'] });
  }
}



async function openSettings_DISABLED(){

  const code = await securePrompt("Enter admin code","password");

  if(!code) return;

  const saved = getState().adminCode || "";

  if(saved && code !== saved) { alert("Wrong admin code"); return; }

  document.getElementById("settingsModal").style.display="block";

}





const DEFAULT_SWATCHES = ['#FFF833','#FF7566','#66AFEA','#70F090']; // blue, red, green, yellow

function renderQuickColors(container, onPick){

  const wrap = document.createElement("div"); wrap.className="quick-colors";

  DEFAULT_SWATCHES.forEach(c=>{

    const b = document.createElement("button"); b.style.background=c;

    b.onclick=()=> onPick(c);

    wrap.appendChild(b);

  });

  container.parentNode.insertBefore(wrap, container);

}



function globalEscapeClose(e){

  if(e.key!=="Escape") return;

  const sp = document.getElementById("securePromptOverlay");

  if(sp && sp.style.display!=="none"){ sp.style.display="none"; sp.style.pointerEvents="none"; }

  const sm = document.getElementById("settingsModal");

  if(sm && sm.style.display!=="none"){ sm.style.display="none"; }

}

document.addEventListener("keydown", globalEscapeClose);



function hookSettingsGuard_DISABLED(){

  // Try common selectors

  const btns = Array.from(document.querySelectorAll('button, a')).filter(b => /\bSettings\b/i.test(b.textContent || ''));

  if(!btns.length) return;

  btns.forEach(btn => {

    const orig = btn.onclick;

    btn.onclick = async (ev)=>{

      ev?.preventDefault?.();

      const code = await window.securePromptOnce('Enter admin code');

      if(code==null) return;

      // Existing admin check logic uses native prompt in code; we replicate minimal acceptance here:

      try{

        // Try to call original (if it uses internal checks it will still run)

        if(orig) return orig.call(btn, ev);

        // Fallback: open settings modal if exists

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }catch(e){

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }

    };

  });

}

/* disabled hookSettingsGuard */

</script>





<!-- Lightweight password prompt (no layout changes elsewhere) -->

<div id="codePromptOverlay" class="code-dialog" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1100;align-items:center;justify-content:center;">

  <div style="background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:20px;min-width:280px;max-width:90%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">

    <div id="codePromptMsg" style="font-weight:600;margin-bottom:10px">Enter code</div>

    <div style="display:flex;gap:8px;align-items:center">

      <input id="codePromptInput" type="password" inputmode="numeric" pattern="[0-9]*" autocomplete="one-time-code" maxlength="6" style="flex:1;padding:10px 12px;border:1px solid #ddd;border-radius:8px;font-size:16px" />

      <button id="codePromptEye" aria-label="Show" style="border:1px solid #ddd;background:#fff;border-radius:8px;padding:8px 10px;cursor:pointer">ğŸ‘ï¸</button>

    </div>

    <div style="text-align:center;margin-top:8px;margin-bottom:4px;">
      <button id="codePromptForgotPin" type="button" style="background:none;border:none;color:#7b3fe4;cursor:pointer;text-decoration:underline;font-size:12px;padding:4px 8px;">Forgot Admin PIN?</button>
    </div>

    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">

      <button id="codePromptCancel" style="padding:8px 14px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Cancel</button>

      <button id="codePromptOk" style="padding:8px 14px;border-radius:8px;border:0;background:#111;color:#fff;cursor:pointer">OK</button>

    </div>

  </div>

</div>

<!-- RESET Confirmation Modal (Step 1) -->
<div id="resetConfirmOverlay" class="code-dialog" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1100;align-items:center;justify-content:center;">

  <div style="background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:20px;min-width:280px;max-width:90%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">

    <div id="resetConfirmMsg" style="font-weight:600;margin-bottom:16px;font-size:16px;text-align:center;">Are you sure you want to RESET THE DAY?</div>

    <div style="font-size:14px;color:#666;margin-bottom:20px;text-align:center;">This will clear all queues. History will NOT be deleted.</div>

    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">

      <button id="resetConfirmCancel" style="padding:8px 14px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Cancel</button>

      <button id="resetConfirmContinue" style="padding:8px 14px;border-radius:8px;border:0;background:#111;color:#fff;cursor:pointer">Continue</button>

    </div>

  </div>

</div>

<script>

(function(){

  const ov = document.getElementById("codePromptOverlay");

  const msg = document.getElementById("codePromptMsg");

  const input = document.getElementById("codePromptInput");

  const btnOk = document.getElementById("codePromptOk");

  const btnCancel = document.getElementById("codePromptCancel");

  const eye = document.getElementById("codePromptEye");

  let resolver = null;

  function show(m){

    msg.textContent = m || "Enter code";

    input.value = "";

    input.type = "password";

    ov.style.display = "flex";
    ov.style.pointerEvents = "auto";
    ov.style.visibility = "visible";
    ov.style.pointerEvents = "auto";
    ov.style.visibility = "visible";

    setTimeout(()=>input.focus(), 50);

    return new Promise((res)=>{ resolver = res; });

  }

  function hide(){ 
    ov.style.display = "none"; 
    ov.style.pointerEvents = "none";
    ov.style.visibility = "hidden";
  }

  btnOk.onclick = ()=>{ const v = input.value; hide(); resolver && resolver(v); };

  btnCancel.onclick = ()=>{ hide(); resolver && resolver(null); };

  eye.onmousedown = ()=>{ 
    // Toggle between password (hidden) and text (visible)
    input.type = (input.type === "password") ? "text" : "password";
  };

  eye.onmouseup = eye.onmouseleave = ()=>{ input.type="password"; };

  // Helper function to show toast messages
  function showToast(message, duration = 3000) {
    // Create toast element if it doesn't exist
    let toast = document.getElementById('admin-pin-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.id = 'admin-pin-toast';
      toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:12px 20px;border-radius:8px;font-size:14px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
      document.body.appendChild(toast);
    }
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => {
      toast.style.display = 'none';
    }, duration);
  }

  // Forgot Admin PIN button - generates PIN reset link
  // This replaces any previous Firebase password reset mechanism
  const forgotPinBtn = document.getElementById("codePromptForgotPin");
  if (forgotPinBtn) {
    forgotPinBtn.onclick = async (event) => {
      event.preventDefault(); // Stop any default action
      
      // Clear any previous error message
      const existingError = document.getElementById('codePromptError');
      if (existingError) {
        existingError.remove();
      }
      
      // Disable button to prevent multiple clicks
      forgotPinBtn.disabled = true;
      const originalText = forgotPinBtn.textContent;
      forgotPinBtn.textContent = 'Sending...';
      
      // Optional: Hide the PIN entry modal temporarily and show a loading message
      // Show non-blocking loading message
      const loadingMsg = document.createElement('div');
      loadingMsg.id = 'codePromptLoading';
      loadingMsg.style.cssText = 'color:#666;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;font-style:italic;';
      loadingMsg.textContent = 'Sending PIN reset link. Please wait...';
      
      // Insert loading message after the button
      const forgotPinContainer = forgotPinBtn.parentElement;
      if (forgotPinContainer && forgotPinContainer.parentElement) {
        forgotPinContainer.parentElement.insertBefore(loadingMsg, forgotPinContainer.nextSibling);
      }
      
      try {
        // Ensure Firebase Functions SDK is available
        if (!window.generatePinResetLink || typeof window.generatePinResetLink !== 'function') {
          throw new Error('Reset functionality is not available. Please refresh the page and try again.');
        }
        
        // Call the Cloud Function to generate reset link
        // Note: salonId is retrieved from the authenticated user's document by the Cloud Function
        const result = await window.generatePinResetLink();
        
        // Remove loading message
        const loadingMsg = document.getElementById('codePromptLoading');
        if (loadingMsg) {
          loadingMsg.remove();
        }
        
        // Success feedback - The function returns a message like "reset link sent successfully"
        const successMessage = result?.data?.message || 'Admin PIN reset link sent successfully to your email.';
        
        // Close the modal to prevent confusion
        hide();
        
        // Show success alert
        alert('Success! ' + successMessage);
        
        // Optionally show success modal (if you want a more polished UI)
        // showPinResetSuccessDialog();
        
      } catch (error) {
        console.error('[AdminPIN] Error requesting PIN reset:', error);
        
        // Remove loading message
        const loadingMsg = document.getElementById('codePromptLoading');
        if (loadingMsg) {
          loadingMsg.remove();
        }
        
        // Re-enable button
        forgotPinBtn.disabled = false;
        forgotPinBtn.textContent = originalText;
        
        // Display user-friendly error message based on the Cloud Function error type
        let errorMessage = 'Could not send reset link. ';
        
        if (error.code === 'unauthenticated') {
          errorMessage = 'Please log in to request a PIN reset.';
        } else if (error.code === 'failed-precondition') {
          errorMessage = 'Your account is not associated with a business. Please contact support.';
        } else if (error.code === 'internal') {
          errorMessage = 'Server error occurred. Please try again later or contact support.';
        } else if (error.message) {
          errorMessage = error.message;
        } else {
          errorMessage += 'Please try again or contact support.';
        }
        
        // Show error alert
        alert('Error: ' + errorMessage);
        
        // Also show error message in the dialog (if modal is still open)
        const errorMsg = document.createElement('div');
        errorMsg.id = 'codePromptError';
        errorMsg.style.cssText = 'color:#dc2626;font-size:13px;margin-top:8px;margin-bottom:8px;text-align:center;';
        errorMsg.textContent = errorMessage;
        
        // Insert error message after the "Forgot Admin PIN?" button container
        const forgotPinContainer = forgotPinBtn.parentElement;
        if (forgotPinContainer && forgotPinContainer.parentElement) {
          forgotPinContainer.parentElement.insertBefore(errorMsg, forgotPinContainer.nextSibling);
        }
      }
    };
  }
  
  // Show PIN reset success dialog
  function showPinResetSuccessDialog() {
    const modal = document.getElementById('pinResetSuccessModal');
    if (modal) {
      modal.style.display = 'flex';
    }
  }

  window.securePromptOnce = show; // expose

})();

// PIN Reset Success Modal handler
(function() {
  const modal = document.getElementById('pinResetSuccessModal');
  const closeBtn = document.getElementById('pinResetSuccessClose');
  
  if (closeBtn) {
    closeBtn.onclick = () => {
      if (modal) modal.style.display = 'none';
    };
  }
  
  // Close on overlay click
  if (modal) {
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
      }
    };
  }
})();

// =====================
// Reset Admin PIN Page Handler
// =====================
(function() {
  // Check URL for reset token on page load
  function checkResetToken() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (token) {
      // Show reset page
      const resetSection = document.getElementById('reset-admin-pin-section');
      const loginSection = document.getElementById('login-section');
      const signupSection = document.getElementById('signup-section');
      const mainApp = document.getElementById('main-app-content');
      
      if (resetSection) {
        // Hide other sections
        if (loginSection) loginSection.style.display = 'none';
        if (signupSection) signupSection.style.display = 'none';
        if (mainApp) mainApp.style.display = 'none';
        resetSection.style.display = 'block';
        
        // Verify token
        verifyResetToken(token);
      }
    }
  }
  
  // Verify reset token
  async function verifyResetToken(token) {
    const statusEl = document.getElementById('reset-pin-status');
    const formEl = document.getElementById('reset-pin-form');
    const errorStateEl = document.getElementById('reset-pin-error-state');
    const errorMsgEl = document.getElementById('reset-pin-error-message');
    
    try {
      if (window.verifyAdminPinResetToken && typeof window.verifyAdminPinResetToken === 'function') {
        const result = await window.verifyAdminPinResetToken(token);
        if (result.success) {
          // Token is valid, show form
          if (statusEl) statusEl.textContent = 'Enter your new admin PIN below.';
          if (formEl) formEl.style.display = 'block';
          if (errorStateEl) errorStateEl.style.display = 'none';
          
          // Store token for later use
          window.__resetToken = token;
        } else {
          throw new Error('Invalid token');
        }
      } else {
        throw new Error('Reset functionality not available');
      }
    } catch (error) {
      console.error('[AdminPIN] Error verifying token:', error);
      if (statusEl) statusEl.style.display = 'none';
      if (formEl) formEl.style.display = 'none';
      if (errorStateEl) errorStateEl.style.display = 'block';
      if (errorMsgEl) {
        errorMsgEl.textContent = 'This reset link is invalid or has expired. Please click "Forgot Admin PIN?" again to receive a new link.';
      }
    }
  }
  
  // Handle form submission
  function setupResetForm() {
    const submitBtn = document.getElementById('reset-pin-submit');
    const cancelBtn = document.getElementById('reset-pin-cancel');
    const closeBtn = document.getElementById('reset-pin-close');
    const tryAgainBtn = document.getElementById('reset-pin-try-again');
    const newPinInput = document.getElementById('reset-pin-new');
    const confirmPinInput = document.getElementById('reset-pin-confirm');
    const errorEl = document.getElementById('reset-pin-error');
    const formEl = document.getElementById('reset-pin-form');
    const successEl = document.getElementById('reset-pin-success');
    const errorStateEl = document.getElementById('reset-pin-error-state');
    
    if (submitBtn) {
      submitBtn.onclick = async () => {
        const newPin = newPinInput ? newPinInput.value.trim() : '';
        const confirmPin = confirmPinInput ? confirmPinInput.value.trim() : '';
        
        // Clear previous errors
        if (errorEl) errorEl.textContent = '';
        
        // Validation
        if (!newPin || !confirmPin) {
          if (errorEl) errorEl.textContent = 'Please enter both PIN fields.';
          return;
        }
        
        if (newPin.length < 4 || newPin.length > 6) {
          if (errorEl) errorEl.textContent = 'PIN must be 4-6 digits.';
          return;
        }
        
        if (!/^\d+$/.test(newPin) || !/^\d+$/.test(confirmPin)) {
          if (errorEl) errorEl.textContent = 'PIN must contain only numbers.';
          return;
        }
        
        if (newPin !== confirmPin) {
          if (errorEl) errorEl.textContent = 'PINs do not match.';
          return;
        }
        
        // Submit
        const token = window.__resetToken;
        if (!token) {
          if (errorEl) errorEl.textContent = 'Reset token is missing. Please request a new link.';
          return;
        }
        
        try {
          if (window.confirmPinReset && typeof window.confirmPinReset === 'function') {
            await window.confirmPinReset(token, newPin);
            
            // Success - show success message
            if (formEl) formEl.style.display = 'none';
            if (errorStateEl) errorStateEl.style.display = 'none';
            if (successEl) successEl.style.display = 'block';
            
            // Clear admin PIN cache
            if (window.clearAdminPinCache && typeof window.clearAdminPinCache === 'function') {
              window.clearAdminPinCache();
            }
          } else {
            throw new Error('Reset functionality not available');
          }
        } catch (error) {
          console.error('[AdminPIN] Error confirming reset:', error);
          if (errorEl) {
            errorEl.textContent = error.message || 'Failed to reset PIN. Please try again.';
          }
        }
      };
    }
    
    if (cancelBtn) {
      cancelBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
    
    if (closeBtn) {
      closeBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
    
    if (tryAgainBtn) {
      tryAgainBtn.onclick = () => {
        // Redirect to main app
        window.location.href = window.location.pathname;
      };
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      checkResetToken();
      setupResetForm();
    });
  } else {
    checkResetToken();
    setupResetForm();
  }
})();



function hookSettingsGuard_DISABLED(){

  // Try common selectors

  const btns = Array.from(document.querySelectorAll('button, a')).filter(b => /\bSettings\b/i.test(b.textContent || ''));

  if(!btns.length) return;

  btns.forEach(btn => {

    const orig = btn.onclick;

    btn.onclick = async (ev)=>{

      ev?.preventDefault?.();

      const code = await window.securePromptOnce('Enter admin code');

      if(code==null) return;

      // Existing admin check logic uses native prompt in code; we replicate minimal acceptance here:

      try{

        // Try to call original (if it uses internal checks it will still run)

        if(orig) return orig.call(btn, ev);

        // Fallback: open settings modal if exists

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }catch(e){

        const modal = document.getElementById('settingsModal');

        if(modal){ modal.style.display='block'; }

      }

    };

  });

}

/* disabled hookSettingsGuard */

</script>









<script id="ensure-eyes">

(function(){

  function isInsideSecurePrompt(el){

    if(!el || !el.closest) return false;
    
    // Skip if inside any code dialog (secure prompt, history modal, etc.)
    return !!(el.closest('#codePromptOverlay') || el.closest('.code-dialog'));

  }

  function hasAnyEye(el){

    if(!el || !el.parentElement) return false;

    // existing sibling button with eye text OR data-eye attr

    const sibs = el.parentElement.querySelectorAll('button, .eye, [data-eye]');

    for(const b of sibs){

      const t = (b.textContent||'').trim();

      if(t==='ğŸ‘' || b.dataset.eye!==undefined || b.classList.contains('eye')) return true;

    }

    return false;

  }

  function bind(btn, input){

    if(!btn || !input || btn.dataset.bound==='1') return;

    btn.addEventListener('click', ()=>{

      input.type = (input.type==='password') ? 'text' : 'password';

    });

    btn.dataset.bound='1';

  }

  function addEye(input){

    if(!input) return;

    if(input.id==='pinInput') return;              // JOIN bar has its own eye

    if(isInsideSecurePrompt(input)) return;        // skip secure prompt modal entirely

    if(input.dataset.hasEye==='1') return;

    if(hasAnyEye(input)){                          // if an eye already exists nearby, just bind it

      const found = input.parentElement.querySelector('button, .eye, [data-eye]');

      if(found) bind(found, input);

      input.dataset.hasEye='1';

      return;

    }

    // create a new minimal eye button

    const btn = document.createElement('button');

    btn.type='button'; btn.className='btn-mini ai-eye-button'; btn.textContent='ğŸ‘';

    btn.style.marginLeft='6px';

    bind(btn, input);

    input.insertAdjacentElement('afterend', btn);

    input.dataset.hasEye='1';

  }

  function sweep(root){

    (root||document).querySelectorAll('input[type="password"]').forEach(addEye);

  }

  document.addEventListener('DOMContentLoaded', ()=>sweep(document));

  document.addEventListener('ff:settings-rendered', ()=>{

    const dlg=document.getElementById('settingsDlg'); if(dlg) sweep(dlg);

  });

})();

</script>





<!-- Show Log: secure code input (hidden + single eye) wrapper only -->

<script>

(function(){

  if (typeof window.openLog !== 'function') return; // keep everything if not found

  const __origOpenLog = window.openLog;

  window.openLog = async function(){

    // Prefer existing securePromptOnce if available (hidden field + eye)

    if (window.securePromptOnce) {

      const code = await window.securePromptOnce("Enter admin code to view log");

      if (code == null) return;

      try {

        if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert("Admin only"); return; }

      } catch(e) { /* if check not available, don't block original */ }

      return __origOpenLog();

    }

    // Fallback tiny modal (hidden password + single eye)

    const ov = document.createElement('div');

    ov.style.cssText="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:99999";

    ov.innerHTML = `<div style="background:#fff;border-radius:14px;box-shadow:0 20px 70px rgba(0,0,0,.2);width:min(460px,92vw);padding:18px;font-family:inherit">
      <div style="font:600 18px/1.3 inherit;margin-bottom:10px">Enter admin code</div>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">
        <input id="__log_code" type="password" autocomplete="off" style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font:16px inherit"/>
        <button id="__log_eye" type="button" aria-label="toggle" style="border:0;border-radius:10px;width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer">ğŸ‘ï¸</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="__log_cancel" style="border:0;border-radius:10px;padding:9px 14px;background:#eee;font:600 14px inherit">Cancel</button>
        <button id="__log_ok" style="border:0;border-radius:10px;padding:9px 14px;background:#111;color:#fff;font:600 14px inherit">OK</button>
      </div></div>`;

    document.body.appendChild(ov);

    const inp = ov.querySelector('#__log_code');

    ov.querySelector('#__log_eye').onclick = ()=>{ inp.type = (inp.type==='password')?'text':'password'; };

    ov.querySelector('#__log_cancel').onclick = ()=>{ document.body.removeChild(ov); };

    ov.querySelector('#__log_ok').onclick = ()=>{

      const code = (inp.value||"").toString();

      try {

        if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert("Admin only"); return; }

      } catch(e) { /* ignore */ }

      document.body.removeChild(ov);

      __origOpenLog();

    };

    inp.focus();

  };

})();

</script>



<script>

// --- injected: secure show log ---

(function(){

  if (window.__logSecurePatched) return;

  window.__logSecurePatched = true;



  // inject styles

  const style = document.createElement('style');

  style.id = 'log-secure-style';

  style.textContent = ` /* --- Show Log secure modal (injected) --- */ #log-secure-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:99999} #log-secure{background:#fff;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:22px;min-width:360px;font-family:inherit} #log-secure h3{margin:0 0 12px;font-size:18px;font-weight:600} #log-secure .row{display:flex;gap:8px;align-items:center;margin:10px 0 18px} #log-secure input[type="password"],#log-secure input[type="text"]{flex:1;border:2px solid #111;border-radius:10px;padding:12px 40px 12px 12px;font-size:16px;outline:none} #log-secure .eye{width:38px;height:38px;border:1px solid #ddd;border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer} #log-secure .actions{display:flex;gap:10px;justify-content:flex-end} #log-secure button{border:none;border-radius:10px;padding:10px 16px;font-size:16px;cursor:pointer} #log-secure .ok{background:#111;color:#fff} #log-secure .cancel{background:#eee} `;

  document.head.appendChild(style);



  // inject html

  const wrap = document.createElement('div');

  wrap.innerHTML = ` <div id=\"log-secure-overlay\" class=\"code-dialog\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"log-secure-title\">   <div id=\"log-secure\">     <h3 id=\"log-secure-title\">Enter admin/manager code to view log</h3>     <div class=\"row\">       <input id=\"log-secure-input\" type=\"password\" autocomplete=\"off\" inputmode=\"numeric\" />       <div id=\"log-secure-eye\" class=\"eye\" title=\"Show/Hide\">ğŸ‘ï¸</div>     </div>     <div class=\"actions\">       <button class=\"cancel\" id=\"log-secure-cancel\">Cancel</button>       <button class=\"ok\" id=\"log-secure-ok\">OK</button>     </div>   </div> </div> `;

  document.body.appendChild(wrap.firstElementChild);



  function openSecurePrompt(){ 

    return new Promise((resolve,reject)=>{

      const ov = document.getElementById('log-secure-overlay');

      const inp = document.getElementById('log-secure-input');

      const eye = document.getElementById('log-secure-eye');

      const ok = document.getElementById('log-secure-ok');

      const cancel = document.getElementById('log-secure-cancel');

      ov.style.display = 'flex';
      ov.style.pointerEvents = 'auto';
      ov.style.visibility = 'visible';

      inp.value='';

      inp.type='password';

      setTimeout(()=>inp.focus(), 0);

      const close = () => { 
        ov.style.display='none'; 
        ov.style.pointerEvents='none';
        ov.style.visibility='hidden';
        handlers(false); 
      };

      const handlers = (on)=>{

        if(on){

          eye.addEventListener('click', toggle);

          cancel.addEventListener('click', onCancel);

          ok.addEventListener('click', onOk);

          inp.addEventListener('keydown', onKey);

        } else {

          eye.removeEventListener('click', toggle);

          cancel.removeEventListener('click', onCancel);

          ok.removeEventListener('click', onOk);

          inp.removeEventListener('keydown', onKey);

        }

      };

      function toggle(){

        inp.type = (inp.type==='password') ? 'text' : 'password';

      }

      function onCancel(){ close(); reject(new Error('cancel')); }

      function onOk(){ const v=inp.value.trim(); close(); resolve(v); }

      function onKey(e){ if(e.key==='Enter'){ onOk(); } if(e.key==='Escape'){ onCancel(); } }

      handlers(true);

    });

  }



  // patch openLog to use secure prompt

  const orig = window.openLog;

  window.openLog = async function(){

    try{

      const code = await openSecurePrompt();

      if(typeof orig === 'function'){ orig.call(this, code); } // let original continue if it supports param

      else {

        // If original openLog expected to call prompt itself, we replicate a minimal flow:

        if (window.showLogWithCode) { window.showLogWithCode(code); }

        else {

          // fallback: store to global expected variable

          window.__lastLogCode = code;

        }

      }

    }catch(e){ /* cancelled */ }

  };

})();

</script>

<!-- Show Log: secure hidden-code modal (single eye) â€” wrapper only -->

<script>

(function(){

  if (typeof window.openLog !== 'function' || window.__showlog_secure_wrapped) return;

  window.__showlog_secure_wrapped = true;

  const __origOpenLog = window.openLog;



  function showSecureCodePrompt(title){

    return new Promise(resolve => {

      const ov = document.createElement('div');

      ov.className = 'code-dialog';
      ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:99999';

      const box = document.createElement('div');

      box.style.cssText = 'background:#fff;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:18px;min-width:360px;font:16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial';

      box.innerHTML = ''

        + '<div style="font-weight:600;margin-bottom:10px">'+ (title||'Enter admin code') +'</div>'

        + '<div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">'

        +   '<input id="__sl_code" type="password" autocomplete="off" inputmode="numeric" '

        +   'style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font-size:16px" />'

        +   '<button id="__sl_eye" type="button" aria-label="toggle" '

        +   'style="width:40px;height:40px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer">ğŸ‘ï¸</button>'

        + '</div>'

        + '<div style="display:flex;gap:8px;justify-content:flex-end">'

        +   '<button id="__sl_cancel" type="button" style="border:1px solid #ddd;border-radius:10px;padding:8px 14px;background:#eee">Cancel</button>'

        +   '<button id="__sl_ok" type="button" style="border:0;border-radius:10px;padding:8px 16px;background:#111;color:#fff">OK</button>'

        + '</div>';

      ov.appendChild(box); document.body.appendChild(ov);

      const inp = box.querySelector('#__sl_code');

      const eye = box.querySelector('#__sl_eye');

      const ok  = box.querySelector('#__sl_ok');

      const cancel = box.querySelector('#__sl_cancel');

      function close(v){ document.body.removeChild(ov); resolve(v); }

      eye.onclick = ()=>{ inp.type = (inp.type==='password') ? 'text' : 'password'; };

      ok.onclick = ()=> close(inp.value.trim());

      cancel.onclick = ()=> close(null);

      inp.addEventListener('keydown', e=>{ if(e.key==='Enter') ok.click(); if(e.key==='Escape') cancel.click(); });

      setTimeout(()=>inp.focus(), 50);

    });

  }



  window.openLog = async function(){

    try{

      const code = await showSecureCodePrompt('Enter admin code to view log');

      if (!code) return;

      try { if (typeof isAdminCode === 'function' && !isAdminCode(code)) { alert('Admin only'); return; } } catch(e){}

      openHistoryModal();

    }catch(e){ /* cancelled */ }

  };

})();

</script>





<script>

// SHOW LOG â€” secure code input only (hidden + single eye), no other changes

window.openLog = async function(){

  if (!window.securePromptOnce) { alert("Admin only"); return; }

  const code = await window.securePromptOnce("Enter admin code to view log");

  try {

    if (code == null || !isAdminCode(code)) { alert("Admin only"); return; }

  } catch(e) { alert("Admin only"); return; }

  openHistoryModal();

};

</script>





<script>

/* SHOW LOG â€” safe wrapper ONLY. Does not delete or modify any existing functions. */

(function () {

  if (window.__sl_secure_wrapped) return; window.__sl_secure_wrapped = true;



  // Try to locate Show Log trigger robustly

  var showBtn = document.getElementById('logBtn') ||

    Array.from(document.querySelectorAll('button, a')).find(function (el) {

      return /show\s*log/i.test((el.textContent||'').trim());

    });

  if (!showBtn) return;



  var origClick = showBtn.onclick;



  showBtn.onclick = async function (ev) {

    try {

      if (ev) { ev.preventDefault(); ev.stopPropagation(); }



      // Use existing securePromptOnce if present; otherwise build a tiny modal

      async function askCode(title) {

        if (window.securePromptOnce) return await window.securePromptOnce(title||'Enter admin code to view log');

        return await new Promise(function(resolve){

          const ov = document.createElement('div');

          ov.className = 'code-dialog';
          ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:99999';

          const box = document.createElement('div');

          box.style.cssText='background:#fff;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:18px;min-width:360px;font:16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial';

          box.innerHTML = ''

            + '<div style="font-weight:600;margin-bottom:10px">'+(title||'Enter admin code')+'</div>'

            + '<div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">'

            + '  <input id="sl_codeX" type="password" autocomplete="off" inputmode="numeric" style="flex:1;border:2px solid #111;border-radius:10px;padding:10px 12px;font-size:16px" />'

            + '  <button id="sl_eyeX" type="button" aria-label="toggle" style="width:40px;height:40px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer">ğŸ‘ï¸</button>'

            + '</div>'

            + '<div style="display:flex;gap:8px;justify-content:flex-end">'

            + '  <button id="sl_cancelX" type="button" style="border:1px solid #ddd;border-radius:10px;padding:8px 14px;background:#eee">Cancel</button>'

            + '  <button id="sl_okX" type="button" style="border:0;border-radius:10px;padding:8px 16px;background:#111;color:#fff">OK</button>'

            + '</div>';

          ov.appendChild(box); document.body.appendChild(ov);

          const inp=box.querySelector('#sl_codeX'), eye=box.querySelector('#sl_eyeX');

          const ok=box.querySelector('#sl_okX'), cancel=box.querySelector('#sl_cancelX');

          function close(v){ document.body.removeChild(ov); resolve(v); }

          eye.onclick=()=>{ inp.type=(inp.type==='password')?'text':'password'; };

          ok.onclick=()=>close(inp.value.trim()); cancel.onclick=()=>close(null);

          inp.addEventListener('keydown', e=>{ if(e.key==='Enter') ok.click(); if(e.key==='Escape') cancel.click(); });

          setTimeout(()=>inp.focus(),50);

        });

      }



      const code = await askCode('Enter admin code to view log');

      if (!code || (typeof isAdminCode === 'function' && !isAdminCode(code))) {

        alert('Admin only'); return false;

      }



      // Open the History modal after successful admin code validation

      openHistoryModal();

      return false;

    } catch (e) {

      // On cancel or error, do nothing

      return false;

    }

  };

})();

</script>





<!-- RESET: secure hidden-code modal (single eye) â€” wrapper only -->

<script>

(function(){

  if (window.__reset_secure_wrapped) return; 

  window.__reset_secure_wrapped = true;

  try{

    var resetBtn = document.getElementById('resetBtn');

    if (!resetBtn) return;

    var originalReset = window.resetDay;



    resetBtn.onclick = async function(ev){
      console.log('RESET clicked (secure wrapper)');
      ensureTasksScreenHidden();
      
      try{

        if (ev) { ev.preventDefault(); ev.stopPropagation(); }

        // Ask for admin or manager code with hidden password + single eye

        if (!window.securePromptOnce) { alert('Admin or manager only'); return false; }

        const code = await window.securePromptOnce('Enter admin or manager code to RESET DAY');

        if (code == null) {

          return false;

        }

        const isAdmin = (typeof isAdminCode === 'function' && isAdminCode(code));

        const isManager = (typeof isManagerCode === 'function' && isManagerCode(code));

        if (!isAdmin && !isManager) {

          alert('Admin or manager only'); 

          return false;

        }

        // Confirm reset

        if (!confirm('Reset the day? This clears queues and history.')) return false;



        // Perform the original reset logic (without any visible prompts)

        try {

          // If original function exists and just does the clearing, call it

          if (typeof originalReset === 'function') {

            // Temporarily bypass gate functions if they exist inside originalReset (we already validated)

            const _gateAdmin = window.gateAdmin, _gateManager = window.gateManager;

            try {

              window.gateAdmin = function(){ return true; };

              window.gateManager = function(){ return true; };

              originalReset.call(this);

            } finally {

              window.gateAdmin = _gateAdmin;

              window.gateManager = _gateManager;

            }

          } else {

            // Fallback: manual clear

            window.queue = [];

            window.service = [];

            window.log = [];

            if (typeof save === 'function') save();

            if (typeof renderQueue === 'function') renderQueue();

            if (typeof renderService === 'function') renderService();

          }

        } catch(e){

          console.error('Reset error', e);

        }

        return false;

      }catch(e){

        return false;

      }

    };

  }catch(e){ /* ignore */ }

})();

</script>





<!-- === FAIR FLOW â€” Audit log (drop-in, zero behavior change) === -->

<script>

(function () {

  const LS_KEY = 'FF_AUDIT_LOG';



  const now = () => {

    const d = new Date();

    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'local';

    return d.toLocaleString([], {

      year:'numeric',month:'2-digit',day:'2-digit',

      hour:'2-digit',minute:'2-digit',second:'2-digit'

    }) + ` (${tz})`;

  };



  const load = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch { return []; } };

  const save = (arr) => localStorage.setItem(LS_KEY, JSON.stringify(arr));

  const actor = (type, name) => type==='worker'&&name ? `worker ${name}` : (type||'manager');



  function addLog({action, whoType, whoName, target}) {

    const arr = load();

    arr.unshift({ ts: now(), action, actor: actor(whoType, whoName), target: target||'' });

    save(arr);

    renderLog();

  }

  // Optional external call

  window.FF_AUDIT = { addLog };



  function rowName(el){

    const row = el.closest('[data-row], .queue-item, .row, li, .flex, .grid') || el.closest('*');

    if (!row) return '';

    const nameEl = row.querySelector('[data-name], .name, .worker, .tech, .badge, .chip, .pill, b, strong, span');

    if (nameEl && nameEl.textContent) return nameEl.textContent.trim();

    return ((row.textContent||'').trim().split(/\s+/)[0]||'').trim();

  }



  function renderLog(){

    const modal = document.querySelector('.history, .history-modal, [data-history], .modal-history, .modal:has(.history), .modal:has(#historyList)');

    if (!modal) return;

    let box =

      modal.querySelector('[data-history-list], #historyList, textarea, .list, ul') ||

      modal.querySelector('textarea, .list, ul');

    if (!box) return;



    const entries = load();

    const lines = entries.map(e => `[${e.ts}] ${e.actor} â†’ ${e.action}${e.target ? ` [${e.target}]` : ''}`);



    if (box.tagName === 'TEXTAREA' || box.tagName === 'INPUT') {

      box.value = lines.length ? lines.join('\n') : 'No activity';

    } else {

      const ul = box.tagName === 'UL' ? box : (box.querySelector('ul') || box.appendChild(document.createElement('ul')));

      ul.innerHTML = lines.length ? lines.map(l => `<li>${l}</li>`).join('') : '<li>No activity</li>';

    }

  }



  const mo = new MutationObserver(() => renderLog());

  mo.observe(document.documentElement, {subtree:true, childList:true});



  document.addEventListener('click', (ev) => {

    const btn = ev.target.closest('button, [role="button"]');

    if (!btn) return;

    const label = (btn.getAttribute('aria-label') || btn.textContent || '').trim().toUpperCase();



    // JOIN

    if (label === 'JOIN') {

      const sel = document.querySelector('select, [data-join-select]');

      const name = sel && sel.value ? sel.value : rowName(btn) || '';

      addLog({ action:'JOIN', whoType:'worker', whoName:name, target:name });

    }

    // Queue actions

    if (label === 'START' || label === 'START TOP') addLog({ action:'START', whoType:'manager', target:rowName(btn) });

    if (label === 'HOLD') addLog({ action:'HOLD', whoType:'manager', target:rowName(btn) });

    if (label === 'RELEASE' || label === 'RELEASE HOLD') addLog({ action:'RELEASE', whoType:'manager', target:rowName(btn) });

    if (label === 'FINISH') addLog({ action:'FINISH', whoType:'manager', target:rowName(btn) });

    if (label === 'LEAVE') addLog({ action:'LEAVE', whoType:'worker', target:rowName(btn) });

    // Reorder / move up/down

    if (label.includes('REORDER')) addLog({ action:'REORDER_TOGGLE', whoType:'manager' });

    if (label === 'UP' || label.includes('MOVE UP') || btn.textContent.trim() === 'â–²') addLog({ action:'MOVE_UP', whoType:'manager', target:rowName(btn) });

    if (label === 'DOWN' || label.includes('MOVE DOWN') || btn.textContent.trim() === 'â–¼') addLog({ action:'MOVE_DOWN', whoType:'manager', target:rowName(btn) });

    // Admin/Settings/Reset

    if (label === 'ADMIN') addLog({ action:'ADMIN_OPEN', whoType:'admin' });

    if (label === 'SETTINGS') addLog({ action:'SETTINGS_OPEN', whoType:'manager' });

    if (label === 'RESET' || label === 'RESET DAY') addLog({ action:'RESET', whoType:'admin' });

    // Show log lifecycle

    if (label === 'SHOW LOG' || label === 'HISTORY' || label === 'LOG') setTimeout(renderLog, 50);

    if (label === 'CLEAR') { save([]); renderLog(); }

    if (label === 'EXPORT') {

      const blob = new Blob([JSON.stringify(load(), null, 2)], {type:'application/json'});

      const url = URL.createObjectURL(blob), a = Object.assign(document.createElement('a'), {href:url, download:`fairflow-log-${Date.now()}.json`});

      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();

    }

  }, true);



  window.addEventListener('load', renderLog);

})();

</script>





<!-- Mini audit logger: pushes extra actions (REORDER/MOVE/Admin/Settings) into built-in `log` array -->

<script>

(function(){

  if (window.__ff_audit_wired) return; window.__ff_audit_wired = true;



  function stamp(){

    try { return (new Date()).toLocaleString(); } catch(e){ return String(new Date()); }

  }

  function rowName(el){

    try{

      var row = el.closest('li, .item, .row, tr, [data-row]');

      if(!row) return '';

      var pill = row.querySelector('.name-pill, .pill, b, strong, span');

      var txt = pill && (pill.textContent||'').trim();

      if(txt) return txt;

    }catch(e){}

    return '';

  }

  function add(msg){

    try{

      if(!window.log) window.log = [];

      if(typeof window.save === 'function'){

        window.log.unshift(stamp() + ' ' + msg);

        window.save();

      } else {

        window.log.unshift(stamp() + ' ' + msg);

      }

    }catch(e){}

  }



  document.addEventListener('click', function(ev){

    var btn = ev.target.closest('button, [role="button"]'); if(!btn) return;

    var raw = (btn.textContent || btn.value || '').trim();

    var t = raw.toUpperCase();



    // Only add entries the core app does NOT already record

    if (t === 'REORDER') { add('REORDER toggle'); return; }

    if (t === 'UP' || btn.textContent.trim() === 'â†‘' || btn.textContent.trim() === 'â–²') { add('MOVE UP: ' + rowName(btn)); return; }

    if (t === 'DOWN' || btn.textContent.trim() === 'â†“' || btn.textContent.trim() === 'â–¼') { add('MOVE DOWN: ' + rowName(btn)); return; }

    if (t === 'ADMIN') { add('ADMIN open'); return; }

    if (t === 'SETTINGS') { add('SETTINGS open'); return; }

  }, true);



  // Also patch reset to ensure an entry is kept before clearing

  try{

    var _reset = window.resetDay;

    window.resetDay = function(){

      try{ add('RESET day (confirmed)'); }catch(e){}

      return _reset ? _reset.apply(this, arguments) : undefined;

    }

  }catch(e){}

})();

</script>





<script>

// --- Guaranteed activity logger (adds entries to built-in `log` array) ---

(function(){

  if (window.__ff_force_logger) return; window.__ff_force_logger = true;

  function stamp(){ try { return (new Date()).toLocaleString(); } catch(e){ return String(new Date()); } }

  function saveLog(){ try{ if (typeof save === 'function') save(); }catch(e){} }

  function add(msg){

    try {

      if (!window.log) window.log = [];

      window.log.unshift(stamp() + " " + msg);

      saveLog();

    } catch(e){}

  }

  function rowName(el){

    try{

      var row = el.closest('li, .item, .row, tr, [data-row]') || el.parentElement;

      if (!row) return "";

      var pill = row.querySelector('.name-pill, .pill, b, strong, span');

      if (pill && pill.textContent) return pill.textContent.trim();

      return (row.textContent||"").trim().split(/\s+/)[0]||"";

    }catch(e){ return ""; }

  }

  // Wrap core functions if they exist to guarantee log lines

  try{

    if (typeof join === "function"){

      const _join = join;

      window.join = function(){ const before = (nameSelect && nameSelect.value)||""; const r = _join.apply(this, arguments); add("join: " + (nameSelect && nameSelect.value || before)); return r; }

    }

    if (typeof startSpecific === "function"){

      const _s = startSpecific;

      window.startSpecific = function(i){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add("START -> IN SERVICE: " + q.name); }catch(e){}; return _s.apply(this, arguments); }

    }

    if (typeof toggleHold === "function"){

      const _h = toggleHold;

      window.toggleHold = function(i){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add(((q.held?"RELEASE":"HOLD") + ": " + q.name)); }catch(e){}; return _h.apply(this, arguments); }

    }

    if (typeof finish === "function"){

      const _f = finish;

      window.finish = function(i){ try{ var s = (window.service||[])[i]; if(s&&s.name) add("FINISH -> Back to end: " + s.name); }catch(e){}; return _f.apply(this, arguments); }

    }

    if (typeof move === "function"){

      const _m = move;

      window.move = function(i,d){ try{ var q = (window.queue||[])[i]; if(q&&q.name) add((d<0?"MOVE UP: ":"MOVE DOWN: ") + q.name); }catch(e){}; return _m.apply(this, arguments); }

    }

    if (typeof resetDay === "function"){

      const _r = resetDay;

      window.resetDay = function(){ add("RESET day (confirmed)"); return _r.apply(this, arguments); }

    }

  }catch(e){}



  // Global click safety net (in case some actions bypass wrappers)

  document.addEventListener("click", function(ev){

    var btn = ev.target.closest("button, [role='button']"); if(!btn) return;

    var t = (btn.textContent||btn.value||"").trim().toUpperCase();

    if (t === "START" || t === "FINISH" || t === "HOLD" || t === "RELEASE" || t === "START TOP" ||

        t === "UP" || t === "DOWN" || t === "ADMIN" || t === "SETTINGS" || t === "REORDER" || t === "RESET"){

      var nm = rowName(btn);

      add(t + (nm?(" " + nm):""));

    }

    if (t === "JOIN"){

      var nm = (window.nameSelect && nameSelect.value) || rowName(btn);

      add("join: " + (nm||""));

    }

  }, true);

})();

</script>



<script>

// --- Merge any auxiliary audit entries into the Show log view (non-destructive) ---

(function(){

  if (window.__ff_merge_log) return; window.__ff_merge_log = true;

  var originalOpen = window.openLog;

  window.openLog = async function(){

    try{

      // Preserve any secure prompt already injected

      if (window.securePromptOnce){

        const code = await window.securePromptOnce("Enter admin code to view log");

        if (!code || (typeof isAdminCode === "function" && !isAdminCode(code))) { alert("Admin only"); return; }

        openHistoryModal();

      }

    }catch(e){}

  };

})();

</script>







<!-- AUDIT LOG PATCH -->

<script>

(function(){

  try{

    function setActor(role, name){

      try {

        window.__ff_actorRole = role || '';

        window.__ff_actorName = name || '';

        sessionStorage.setItem('ff_actor_role', window.__ff_actorRole);

        sessionStorage.setItem('ff_actor_name', window.__ff_actorName);

      } catch(e){}

    }

    function getActorSuffix(targetName){

      try{

        var role = window.__ff_actorRole || sessionStorage.getItem('ff_actor_role') || '';

        var nm   = window.__ff_actorName || sessionStorage.getItem('ff_actor_name') || '';

        if (role){ return ' â€¢ BY ' + role + (nm ? (' ' + nm) : ''); }

        if (targetName){ return ' â€¢ BY Worker ' + targetName; }

      }catch(e){}

      return '';

    }

    if (typeof window.securePromptOnce === 'function'){

      const _sec = window.securePromptOnce;

      window.securePromptOnce = async function(msg){

        const code = await _sec.call(this, msg);

        try{

          if (code != null){

            if (typeof isAdminCode === 'function' && isAdminCode(code)){

              var adminName = (window.settings && (settings.ownerName || settings.adminName || (settings.owner && settings.owner.name))) || '';

              setActor('Admin', adminName || '');

            } else if (typeof isManagerCode === 'function' && isManagerCode(code)){

              var mgrName = '';

              try{

                if (window.settings && Array.isArray(settings.managers)){

                  var m = settings.managers.find(m => String(m.code) === String(code));

                  if (m && m.name) mgrName = m.name;

                }

              }catch(e){}

              setActor('Manager', mgrName || '');

            }

          }

        }catch(e){}

        return code;

      };

    }

    if (typeof window.gateAdmin === 'function'){

      const _ga = window.gateAdmin;

      window.gateAdmin = function(){

        const ok = _ga.apply(this, arguments);

        if (ok){ setActor('Admin', (window.settings && (settings.ownerName || settings.adminName)) || ''); }

        return ok;

      };

    }

    if (typeof window.gateManager === 'function'){

      const _gm = window.gateManager;

      window.gateManager = function(){

        const ok = _gm.apply(this, arguments);

        if (ok){ if (!window.__ff_actorRole) setActor('Manager',''); }

        return ok;

      };

    }

  }catch(e){}



  function stamp(){ try{ return new Date().toLocaleString(); }catch(e){ return String(Date.now()); } }

  function sanitize(s){ return String(s).replace(/[&<>]/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;'}[m]; }); }

  function extractTargetName(line){

    var m = String(line).match(/\b(?:START|FINISH|HOLD|RELEASE|JOIN)\s+(.+)$/i);

    return m ? m[1].trim() : '';

  }

  window.log = Array.isArray(window.log) ? window.log : [];

  function addLine(base){

    try{

      var tgt = extractTargetName(base);

      var full = base + getActorSuffix(tgt);

      window.log.unshift(stamp() + ' Â· ' + full);

      if (typeof window.save === 'function'){ window.save(); }

      if (window.logBox){

        const list = window.log;

        window.logBox.innerHTML = list.length

          ? list.map(function(l){ return '<div>'+sanitize(l)+'</div>'; }).join('')

          : "<i>No activity</i>";

      }

    }catch(e){}

  }



  try{

    if (window.__ff_click_handler && document.removeEventListener){

      document.removeEventListener('click', window.__ff_click_handler, true);

    }

  }catch(e){}



  window.__ff_click_handler = function(ev){

    var t = ev.target.closest('button, [role=\"button\"]'); if(!t) return;

    var txt = (t.textContent||'').trim().toUpperCase();

    var wrap = t.closest('[data-worker], .row, .svc, .queue, .inservice');

    var nm = '';

    try{

      nm = (wrap && (wrap.getAttribute('data-worker') || wrap.querySelector('[data-name], .name, .worker-name, .badge')?.textContent?.trim())) || '';

    }catch(e){}



    if (txt === 'HOLD')        addLine('HOLD ' + nm);

    else if (txt === 'START')  addLine('START ' + nm);

    else if (txt === 'FINISH') addLine('FINISH ' + nm);

    else if (txt === 'JOIN')   addLine('JOIN ' + nm);

    else if (txt === 'RESET' || txt === 'RESET DAY') addLine('RESET');

    else if (txt === 'START TOP') addLine('START TOP');

    else if (/^(UP|DOWN)$/.test(txt) || t.classList.contains('reorder') || (t.dataset && t.dataset.action==='reorder')){

      addLine('REORDER');

    }

  };

  document.addEventListener('click', window.__ff_click_handler, true);

})();

</script>

  </div> <!-- End owner-view -->

  <!-- Reception View -->
  <div id="reception-view" style="display:none;">
    <h2>Reception view</h2>
    <button id="logout-button-reception">Log out</button>
  </div>

  <!-- Staff View -->
  <div id="staff-view" style="display:none;">
    <h2>Staff view</h2>
    <button id="logout-button-staff">Log out</button>
  </div>

  </div> <!-- End main-app-content -->

  <script type="module" src="app.js"></script>

</body>

</html>
